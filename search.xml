<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>矩阵的遍历与查找</title>
      <link href="2021/07/02/%E7%9F%A9%E9%98%B5/"/>
      <url>2021/07/02/%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<p>关于矩阵不同顺序的遍历，以及元素的查找，替换等操作。</p><h2 id="螺旋矩阵-顺时针遍历"><a href="#螺旋矩阵-顺时针遍历" class="headerlink" title="螺旋矩阵/顺时针遍历"></a>螺旋矩阵/顺时针遍历</h2><img src="/2021/07/02/%E7%9F%A9%E9%98%B5/mat.png" class><p>输入: [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出: [1,2,3,4,8,12,11,10,9,5,6,7]</p><p>思路：设置上，下，左，右四条边界，按照 上， 右， 下， 左的顺序(符合图中的顺序)遍历，每当遍历一行或者一列时，就向内收缩一次，比如起初top边界为0，当遍历完第一行时，top变为1 (向下移动)， 当最右边一列遍历完成后， right边界向左移动一位</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans; </span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>, bottom = matrix.size();  <span class="comment">//上下边界</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].size(); <span class="comment">//左右边界</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; top &lt; bottom)&#123;</span><br><span class="line"><span class="comment">//遍历最上面一行，遍历完成后top边界向下移动一行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;right;++i)&#123;</span><br><span class="line">ans.push_back(matrix[top][i]);</span><br><span class="line">&#125;</span><br><span class="line">top++;</span><br><span class="line"><span class="comment">//遍历最右边一列，遍历完后right向左移动一列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&lt;bottom;++i)&#123;</span><br><span class="line">ans.push_back(matrix[i][right<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">right--;</span><br><span class="line"><span class="comment">//判断边界条件</span></span><br><span class="line"><span class="keyword">if</span>(!(left &lt; right &amp;&amp; top &lt; bottom)) <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//遍历最下面一行，这里要从右往左遍历，遍历完成后bottom向上移动一行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=right<span class="number">-1</span>;i&gt;=left;--i)&#123;</span><br><span class="line">ans.push_back(matrix[bottom<span class="number">-1</span>][i]);</span><br><span class="line">&#125;</span><br><span class="line">bottom--;</span><br><span class="line"><span class="comment">//遍历最左边一列，这里要从下往上遍历，遍历完成后left向右移动一列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=bottom<span class="number">-1</span>;i&gt;=top;--i)&#123;</span><br><span class="line">ans.push_back(matrix[i][left]);</span><br><span class="line">&#125;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/diagonal-traverse/">LC498对角线遍历</a><br>思路:</p><ol><li>答案的顺序是按照 行列之和排列的</li><li>偶数和和奇数和的元素排列方式是相反的</li><li>利用python的字典序排序<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDiagonalOrder</span>(<span class="params">self, mat: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[int]:</span></span><br><span class="line"></span><br><span class="line">        diag=[]</span><br><span class="line">        res=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat[i])):</span><br><span class="line">                <span class="keyword">if</span> (i+j) %<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    diag.append((i+j,j,mat[i][j]))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    diag.append((i+j,-j,mat[i][j]))</span><br><span class="line"></span><br><span class="line">        diag.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(diag)):</span><br><span class="line">            res.append(diag[i][<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ol><h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">LC74搜索二维矩阵</a><br>在一个增序的矩阵里查找一个值是否存在。<br>思路：因为矩阵是严格递增，所以每一行的第一个数字大于上一行的最后一个数字。所以在搜索时，只需比较目标值是否大于每行的最后一个值，如果大于，就跳向下一行；如果小于，则说明目标值可能在这一行，遂进行查找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.size(),m=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> top=<span class="number">0</span>,bottom = n<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>] || target &gt; matrix[n<span class="number">-1</span>][m<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (target &gt; matrix[i][m<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">auto</span> it = find (matrix[i].begin(),matrix[i].end(),target);</span><br><span class="line">            <span class="keyword">return</span> it != matrix[i].end();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指offer04</a><br>相似情况，只不过这种情况下是每一行和每一列各自严格递增(所以存在上一行的数字大于下面行的数字)</p><p>思路：一种解法是把矩阵看成一个二叉树，根结点为左下角(或者右上角)的值，起始值为当前值，当目标值小于当前值，就向上移动一行，如果目标值大于当前值，就向右移动一列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=matrix.size()<span class="number">-1</span>,j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j &lt;matrix[<span class="number">0</span>].size())&#123;</span><br><span class="line"><span class="keyword">if</span>(target &lt; matrix[i][j]) i--;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(target &gt; matrix[i][j]) i++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="翻转矩阵"><a href="#翻转矩阵" class="headerlink" title="翻转矩阵"></a>翻转矩阵</h2><img src="/2021/07/02/%E7%9F%A9%E9%98%B5/mat2.png" class><h3 id="顺时针旋转90度。"><a href="#顺时针旋转90度。" class="headerlink" title="顺时针旋转90度。"></a>顺时针旋转90度。</h3><p>思路：类似于第一题的顺时针遍历。可以先想象四个角之间的转换，即左上角转到右上角，右上角转到右下角，右下角转到左上角。总共需要转 n-1 次 (nxn矩阵)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=matrix.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;  <span class="comment">//把矩阵分层，需要转的层数，如图中的矩阵为2层 (1,2,3,6,9,8,7,4为1层，5为第二层)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r-l;++i)&#123;  <span class="comment">//每一层需要旋转的次数</span></span><br><span class="line">            <span class="keyword">int</span> top = l, bottom = r;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//save topleft</span></span><br><span class="line">            <span class="keyword">int</span> topleft = matrix[top][l+i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//move bottom left into top left</span></span><br><span class="line">            matrix[top][l+i] = matrix[bottom-i][l];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//move bottom right to bottom left</span></span><br><span class="line">            matrix[bottom-i][l] = matrix[bottom][r-i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//move top right to bottom right</span></span><br><span class="line">            matrix[bottom][r-i] = matrix[top+i][r];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//move topleft to top right</span></span><br><span class="line">            matrix[top+i][r]=topleft;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        r--;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆时针旋转90度。"><a href="#逆时针旋转90度。" class="headerlink" title="逆时针旋转90度。"></a>逆时针旋转90度。</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=matrix.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r-l;++i)&#123; <span class="comment">//number of replacement</span></span><br><span class="line">            <span class="keyword">int</span> top = l, bottom = r;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//save topleft</span></span><br><span class="line">            <span class="keyword">int</span> topleft = matrix[top][l+i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//move top right into top left</span></span><br><span class="line">            matrix[top][l+i] = matrix[top+i][r];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//move bottom right to top right</span></span><br><span class="line">            matrix[top+i][r] = matrix[bottom][r-i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//move bottom left to bottom right</span></span><br><span class="line">            matrix[bottom][r-i] = matrix[bottom-i][l];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//move topleft to bottom left</span></span><br><span class="line">            matrix[bottom-i][l]=topleft;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        r--;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有点绕～</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数学基础算法</title>
      <link href="2021/06/26/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
      <url>2021/06/26/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="二进制幂"><a href="#二进制幂" class="headerlink" title="二进制幂"></a>二进制幂</h2><p>二进制幂是一种在计算机中更有效率计算 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="2.344ex" height="1.551ex" role="img" focusable="false" viewbox="0 -675.5 1036.3 685.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(562,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container> 的方法(时间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3401 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3012,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>)<br>首先幂的公式满足:<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="12.808ex" height="2.23ex" role="img" focusable="false" viewbox="0 -903.7 5661.2 985.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="TeXAtom" transform="translate(562,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mo" transform="translate(429,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(1207,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g></g></g><g data-mml-node="mo" transform="translate(2049.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msup" transform="translate(3105.2,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(562,413) scale(0.707)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g></g><g data-mml-node="mo" transform="translate(4242.8,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"/></g><g data-mml-node="msup" transform="translate(4743,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(562,413) scale(0.707)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g></g></g></g></svg></mjx-container> <mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="19.5ex" height="2.61ex" role="img" focusable="false" viewbox="0 -903.7 8619.1 1153.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="TeXAtom" transform="translate(562,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g></g></g><g data-mml-node="mo" transform="translate(1546.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msup" transform="translate(2602.5,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(562,413) scale(0.707)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g></g><g data-mml-node="mo" transform="translate(3740,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"/></g><g data-mml-node="msup" transform="translate(4240.3,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(562,413) scale(0.707)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g></g><g data-mml-node="mo" transform="translate(5433.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(6489.2,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(6878.2,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(562,413) scale(0.707)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g></g><g data-mml-node="msup" transform="translate(7793.5,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mn" transform="translate(422,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></g></svg></mjx-container><br>二进制幂就是把幂n，写成二进制的形式,比如:<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="23.097ex" height="2.203ex" role="img" focusable="false" viewbox="0 -891.7 10209 973.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(500,0)"/></g></g></g><g data-mml-node="mo" transform="translate(1567.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msup" transform="translate(2623.7,0)"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1000,0)"/><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(1500,0)"/></g></g></g><g data-mml-node="mo" transform="translate(4898.7,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msup" transform="translate(5954.4,0)"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mn" transform="translate(533,413) scale(0.707)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"/></g></g><g data-mml-node="mo" transform="translate(7113.2,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"/></g><g data-mml-node="msup" transform="translate(7613.4,0)"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mn" transform="translate(533,413) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/></g></g><g data-mml-node="mo" transform="translate(8772.2,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"/></g><g data-mml-node="msup" transform="translate(9272.4,0)"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mn" transform="translate(533,413) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></svg></mjx-container><br>一个数n在二进制中有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="9.236ex" height="2.034ex" role="img" focusable="false" viewbox="0 -694 4082.4 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(783,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mn" transform="translate(1260,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(1760,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2582.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(3582.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>位数，所以只需找出 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="17.967ex" height="2.37ex" role="img" focusable="false" viewbox="0 -853.7 7941.2 1047.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mn" transform="translate(562,363) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(965.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msup" transform="translate(1410.2,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mn" transform="translate(562,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2375.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msup" transform="translate(2820.4,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mn" transform="translate(562,363) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g><g data-mml-node="mo" transform="translate(3786,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mo" transform="translate(4230.7,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"/></g><g data-mml-node="mo" transform="translate(5569.3,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msup" transform="translate(6014,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="TeXAtom" transform="translate(562,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(783,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(1260,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></g></svg></mjx-container><br>通过上面的例子，可以找到规律:<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="6.267ex" height="2.185ex" role="img" focusable="false" viewbox="0 -883.9 2770.1 965.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mn" transform="translate(533,413) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(1214.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(2270.1,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g></g></svg></mjx-container><br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="14.151ex" height="2.565ex" role="img" focusable="false" viewbox="0 -883.9 6254.8 1133.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mn" transform="translate(533,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(1214.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2270.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(2659.1,0)"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mn" transform="translate(533,413) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="msup" transform="translate(3595.7,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mn" transform="translate(422,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(4699,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(5754.8,0)"><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z"/></g></g></g></svg></mjx-container><br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="15.282ex" height="2.583ex" role="img" focusable="false" viewbox="0 -891.7 6754.8 1141.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mn" transform="translate(533,413) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/></g></g><g data-mml-node="mo" transform="translate(1214.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2270.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(2659.1,0)"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mn" transform="translate(533,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="msup" transform="translate(3595.7,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mn" transform="translate(422,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(4699,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(5754.8,0)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"/><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"/></g></g></g></svg></mjx-container><br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="17.545ex" height="2.583ex" role="img" focusable="false" viewbox="0 -891.7 7754.8 1141.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mn" transform="translate(533,413) scale(0.707)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"/></g></g><g data-mml-node="mo" transform="translate(1214.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2270.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(2659.1,0)"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mn" transform="translate(533,413) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/></g></g><g data-mml-node="msup" transform="translate(3595.7,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mn" transform="translate(422,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(4699,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(5754.8,0)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(1000,0)"/><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(1500,0)"/></g></g></g></svg></mjx-container><br>每一个数都是前一个数的平方。<br>为了得到 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.937ex" role="img" focusable="false" viewbox="0 -833.9 1290.1 855.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(500,0)"/></g></g></g></g></g></svg></mjx-container>，只需要把对应二进制数位为1的数位乘起来:<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="28.059ex" height="2.185ex" role="img" focusable="false" viewbox="0 -883.9 12402.1 965.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="TeXAtom" transform="translate(533,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(500,0)"/></g></g></g><g data-mml-node="mo" transform="translate(1567.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(2623.7,0)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(1000,0)"/><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(1500,0)"/></g><g data-mml-node="mo" transform="translate(4845.9,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"/></g><g data-mml-node="mn" transform="translate(5346.1,0)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"/><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"/></g><g data-mml-node="mo" transform="translate(6568.3,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"/></g><g data-mml-node="mn" transform="translate(7068.6,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mo" transform="translate(7846.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(8902.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"/><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z" transform="translate(1000,0)"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1500,0)"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(2000,0)"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(2500,0)"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(3000,0)"/></g></g></g></svg></mjx-container><br>这种方法最多只需要进行<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="4.208ex" height="2.034ex" role="img" focusable="false" viewbox="0 -694 1860 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(783,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(1260,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>次计算，而不是n次。</p><h2 id="实现与应用"><a href="#实现与应用" class="headerlink" title="实现与应用"></a>实现与应用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">binpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>{</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n&gt;<span class="number">0</span>){</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>)  <span class="comment">//如果该位的值为1</span></span><br><span class="line">res*=a;</span><br><span class="line">a*=a;</span><br><span class="line">n&gt;&gt;=<span class="number">1</span>; <span class="comment">//查看下一位</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>计算 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="2.071ex" height="1.954ex" role="img" focusable="false" viewbox="0 -853.7 915.3 863.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(562,363) scale(0.707)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g></g></g></g></svg></mjx-container> mod m:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">binpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> m)</span> </span>{</span><br><span class="line">    a %= m;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * a % m;</span><br><span class="line">        a = a * a % m;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="最大公约数和最小公倍数-GCD-and-LCM"><a href="#最大公约数和最小公倍数-GCD-and-LCM" class="headerlink" title="最大公约数和最小公倍数(GCD and LCM)"></a>最大公约数和最小公倍数(GCD and LCM)</h2><p><strong>最大公约数</strong></p><p>a,b的最大公约数指他们两个共有约数(divisor)的最大的一个，如24,60的最大公约数为12。<br>辗转相除法，也称为欧几里得算法(Euclidean algorithm)常用来被计算最大公约数。</p><p>举例说明辗转相除法具体的算法: (24,60)<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="15.473ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 6838.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(500,0)"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1000,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(1500,0)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"/></g><g data-mml-node="mo" transform="translate(2777.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(3833.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(4500.2,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"/></g><g data-mml-node="mn" transform="translate(5838.9,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(500,0)"/></g></g></g></svg></mjx-container><br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="15.473ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 6838.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1000,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(1500,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(500,0)"/></g><g data-mml-node="mo" transform="translate(2777.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(3833.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(4500.2,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"/></g><g data-mml-node="mn" transform="translate(5838.9,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/></g></g></g></svg></mjx-container><br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="14.341ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 6338.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(500,0)"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1000,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(1500,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/></g><g data-mml-node="mo" transform="translate(2777.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(3833.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(4500.2,0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"/></g><g data-mml-node="mn" transform="translate(5838.9,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></svg></mjx-container><br>直到余数为0为止。</p><p>假设一对数为(a,b), 通过上面的例子可以得出一旦 a%b==0 的时候就返回答案，否则就是把a替换成b，把b替换成上一次的余数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>或者使用ternary operator来表达</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line"><span class="keyword">return</span> b ? gcd(b,a%b):a;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>非递归表达方法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line"><span class="keyword">while</span>(b){</span><br><span class="line">a %= b;</span><br><span class="line">swap(a,b);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>最小公倍数</strong></p><p>根据公式:<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="24.702ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 10918.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(298,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mi" transform="translate(731,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1609,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1998,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mo" transform="translate(2527,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(2971.7,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mo" transform="translate(3400.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(4067.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(5123.2,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mo" transform="translate(5874.4,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"/></g><g data-mml-node="mi" transform="translate(6374.7,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(6803.7,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mi" transform="translate(7303.7,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(7780.7,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mi" transform="translate(8213.7,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(8733.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(9122.7,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mo" transform="translate(9651.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(10096.3,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mo" transform="translate(10529.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line"><span class="keyword">return</span> a/gcd(a,b)*b;  <span class="comment">//这种写法是为了防止a.b过大而溢出</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="Linear-Diophantine-Equation"><a href="#Linear-Diophantine-Equation" class="headerlink" title="Linear Diophantine Equation"></a>Linear Diophantine Equation</h2><p>LDE 一般指以下形式的等式:<br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="11.333ex" height="2.034ex" role="img" focusable="false" viewbox="0 -694 5009 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(529,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mo" transform="translate(1323.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2323.4,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(2752.4,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3520.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(4576,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g></g></g></svg></mjx-container><br>a,b,c为整数(a,b != 0)，x,y为未知整数,这种等式一般有多个解。</p><ol><li><p>找到一个解:<br> <mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="18.522ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 8186.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(529,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mo" transform="translate(1323.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(2323.4,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mi" transform="translate(2752.4,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3520.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(4576,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(5053,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="mi" transform="translate(5486,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mo" transform="translate(6006,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(6395,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mo" transform="translate(6924,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(7368.7,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mo" transform="translate(7797.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container><br> 就是其中的一个解</p><p> 通过上面的gcd算法可以得出，设g为gcd(a,b)，到最后b为0，a为g。所以有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="10.367ex" height="1.971ex" role="img" focusable="false" viewbox="0 -666 4582 871"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(477,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mo" transform="translate(1271.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(2271.4,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(3049.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(4105,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g></g></g></svg></mjx-container>,所以 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="13.215ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5840.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mo" transform="translate(961,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1405.7,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1895.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2562.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(3618.2,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(4007.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(4507.2,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(4951.9,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(5451.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 就是一个解。</p><p> 因为(a,b)要转变成(b,a%b), 假设<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="7.431ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3284.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(961,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1461,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1905.7,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(2395.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(2895.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 为(b,a%b)的系数:<br> <mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="25.099ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 11093.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mo" transform="translate(651.2,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"/></g><g data-mml-node="mi" transform="translate(1151.4,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(1723.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(2445.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mo" transform="translate(3445.9,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(3834.9,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mtext" transform="translate(4363.9,0)"><path data-c="A0" d=""/><path data-c="6D" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q351 442 364 440T387 434T406 426T421 417T432 406T441 395T448 384T452 374T455 366L457 361L460 365Q463 369 466 373T475 384T488 397T503 410T523 422T546 432T572 439T603 442Q729 442 740 329Q741 322 741 190V104Q741 66 743 59T754 49Q775 46 803 46H819V0H811L788 1Q764 2 737 2T699 3Q596 3 587 0H579V46H595Q656 46 656 62Q657 64 657 200Q656 335 655 343Q649 371 635 385T611 402T585 404Q540 404 506 370Q479 343 472 315T464 232V168V108Q464 78 465 68T468 55T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(250,0)"/><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(1083,0)"/><path data-c="64" d="M376 495Q376 511 376 535T377 568Q377 613 367 624T316 637H298V660Q298 683 300 683L310 684Q320 685 339 686T376 688Q393 689 413 690T443 693T454 694H457V390Q457 84 458 81Q461 61 472 55T517 46H535V0Q533 0 459 -5T380 -11H373V44L365 37Q307 -11 235 -11Q158 -11 96 50T34 215Q34 315 97 378T244 442Q319 442 376 393V495ZM373 342Q328 405 260 405Q211 405 173 369Q146 341 139 305T131 211Q131 155 138 120T173 59Q203 26 251 26Q322 26 373 103V342Z" transform="translate(1583,0)"/><path data-c="A0" d="" transform="translate(2139,0)"/></g><g data-mml-node="mi" transform="translate(6752.9,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mo" transform="translate(7181.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(7793.1,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"/></g><g data-mml-node="mi" transform="translate(8293.3,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(8783.3,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(9561.1,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(10616.9,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g></g></g></svg></mjx-container><br> 我们想找到以下等式的<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.169ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2284.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mo" transform="translate(961,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1405.7,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1895.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>:<br> <mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="14.701ex" height="2.034ex" role="img" focusable="false" viewbox="0 -694 6497.9 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mo" transform="translate(751.2,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"/></g><g data-mml-node="mi" transform="translate(1251.4,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mo" transform="translate(2045.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(3045.9,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mo" transform="translate(3697.1,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"/></g><g data-mml-node="mi" transform="translate(4197.3,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(4965.1,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(6020.9,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g></g></g></svg></mjx-container><br> a mod b可以表达为:<br> <mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="22.216ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 9819.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mtext" transform="translate(529,0)"><path data-c="A0" d=""/><path data-c="6D" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q351 442 364 440T387 434T406 426T421 417T432 406T441 395T448 384T452 374T455 366L457 361L460 365Q463 369 466 373T475 384T488 397T503 410T523 422T546 432T572 439T603 442Q729 442 740 329Q741 322 741 190V104Q741 66 743 59T754 49Q775 46 803 46H819V0H811L788 1Q764 2 737 2T699 3Q596 3 587 0H579V46H595Q656 46 656 62Q657 64 657 200Q656 335 655 343Q649 371 635 385T611 402T585 404Q540 404 506 370Q479 343 472 315T464 232V168V108Q464 78 465 68T468 55T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(250,0)"/><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(1083,0)"/><path data-c="64" d="M376 495Q376 511 376 535T377 568Q377 613 367 624T316 637H298V660Q298 683 300 683L310 684Q320 685 339 686T376 688Q393 689 413 690T443 693T454 694H457V390Q457 84 458 81Q461 61 472 55T517 46H535V0Q533 0 459 -5T380 -11H373V44L365 37Q307 -11 235 -11Q158 -11 96 50T34 215Q34 315 97 378T244 442Q319 442 376 393V495ZM373 342Q328 405 260 405Q211 405 173 369Q146 341 139 305T131 211Q131 155 138 120T173 59Q203 26 251 26Q322 26 373 103V342Z" transform="translate(1583,0)"/><path data-c="A0" d="" transform="translate(2139,0)"/></g><g data-mml-node="mi" transform="translate(2918,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mo" transform="translate(3624.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(4680.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mo" transform="translate(5431.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mo" transform="translate(6432,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(6821,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(7350,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mi" transform="translate(7850,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mo" transform="translate(8279,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(8890.2,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"/></g><g data-mml-node="mi" transform="translate(9390.4,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g></g></g></svg></mjx-container><br> 这里的<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="3.299ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1458 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(529,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mi" transform="translate(1029,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g></g></g></svg></mjx-container>为整除，比如<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="8.673ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3833.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1000,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mn" transform="translate(1500,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"/></g><g data-mml-node="mo" transform="translate(2277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(3333.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></svg></mjx-container>。<br> 带入等式:<br> <mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="29.153ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 12885.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mo" transform="translate(754.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(1810.6,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mo" transform="translate(2461.8,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"/></g><g data-mml-node="mi" transform="translate(2962,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mn" transform="translate(3534,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(4256.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mo" transform="translate(5256.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(5645.4,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mo" transform="translate(6396.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mo" transform="translate(7396.9,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(7785.9,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(8314.9,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/></g></g><g data-mml-node="mi" transform="translate(8814.9,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mo" transform="translate(9243.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(9855.1,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"/></g><g data-mml-node="mi" transform="translate(10355.3,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mo" transform="translate(10784.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(11395.6,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"/></g><g data-mml-node="mi" transform="translate(11895.8,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(12385.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>队列&amp;栈</title>
      <link href="2021/06/24/%E9%98%9F%E5%88%97-%E6%A0%88/"/>
      <url>2021/06/24/%E9%98%9F%E5%88%97-%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>从头梳理队列和栈的实现及其应用。</p><h2 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h2><p>一种先进后出的数据结构。实现入队和出队:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000  <span class="comment">//设置队列大小</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> a[MAX]; </span><br><span class="line">        </span><br><span class="line">        Stack()&#123; top = <span class="number">-1</span>;&#125; <span class="comment">//初始化top为-1，表示队列为空</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Stack::push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top &gt;= (MAX<span class="number">-1</span>))&#123;。<span class="comment">//当队列元素数量大于max</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Stack Overflow&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        a[++top]=x;  <span class="comment">//x加入队列，并且top+1</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt;<span class="string">&quot; pushed into stack\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top&lt;<span class="number">0</span>)&#123; <span class="comment">//队列内没有元素</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Stack Underflow&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[top--]; <span class="comment">//取出元素</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(top&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Stack is empty&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Stack::isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列(queue)"></a>队列(queue)</h2><p>先进先出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">    <span class="keyword">int</span> a[MAX];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">         </span><br><span class="line">        Queue()&#123; </span><br><span class="line">            front = <span class="number">-1</span>;</span><br><span class="line">            rear = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">deQueue</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Queue::enQueue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rear == MAX - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;Queue Overflow&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(front == <span class="number">-1</span>)</span><br><span class="line">            front=<span class="number">0</span>;</span><br><span class="line">        a[++rear] = value;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; value &lt;&lt;<span class="string">&quot; pushed into queue\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Queue::deQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (front == <span class="number">-1</span> || front &gt; rear)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;Queue underflow&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[front++];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt;<span class="string">&quot; popped out from queue\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Queue::isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (front==<span class="number">-1</span>) &amp;&amp; (rear == <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    q.enQueue(<span class="number">1</span>);</span><br><span class="line">    q.enQueue(<span class="number">2</span>);</span><br><span class="line">    q.enQueue(<span class="number">3</span>);</span><br><span class="line">    q.deQueue();</span><br><span class="line">    q.deQueue();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>用两个指针分别来标志起始和结束为止，目的是重用之前被 pop的空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyCircularQueue(<span class="keyword">int</span> k)&#123; <span class="comment">//set vector to size k</span></span><br><span class="line">        data.resize(k);</span><br><span class="line">        head=<span class="number">-1</span>;</span><br><span class="line">        tail=<span class="number">-1</span>;</span><br><span class="line">        size=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())</span><br><span class="line">            head=<span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">        tail=(tail+<span class="number">1</span>)%size; </span><br><span class="line">        data[tail]=value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(head==tail)&#123;</span><br><span class="line">            head=<span class="number">-1</span>;</span><br><span class="line">            tail=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head=(head+<span class="number">1</span>)%size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> data[head];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> data[tail];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (head==<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((tail+<span class="number">1</span>)%size)==head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><p>给两个栈，使用栈先进后出的原则来模拟一个先进先出的队列。</p><p>思路:</p><ol><li>push(): 队列和栈的压入实现的方法是相同的，这里只需要使用任意一个栈来实现push<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    stack1.push(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/06/24/%E9%98%9F%E5%88%97-%E6%A0%88/pic1.png" class></li><li>pop(): 如上图所示，当stack1不为空时，就把top压入到stack2, 然后pop out stack2，stack2作用于pop stack1最下面的元素(最先进入的)，当一个pop操作完成后，stack2所有的元素再返回stack1中 (相当于只有最底线的元素被拿走了)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">    CQueue()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack1.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = stack1.top(); <span class="comment">//把栈最上面的元素存入一个临时的变量</span></span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">while</span>(!stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = stack2.top(); </span><br><span class="line">            stack2.pop();</span><br><span class="line">            stack1.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="两个队列实现栈"><a href="#两个队列实现栈" class="headerlink" title="两个队列实现栈"></a>两个队列实现栈</h2></li></ol><p>思路： </p><ol><li>push() 和上一题相似，选择一个queue压入元素。</li><li>pop() 当q1不为空的时候，把q1里的元素 (除了最后一个)全部放入q2, q1剩下的那一个元素就是top, pop出来就实现了栈的pop。实现之后再次把剩下的元素从q2放入到q1里<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q2;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        q1.push(x);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q1.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(q1.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = q1.front();</span><br><span class="line">            q1.pop();</span><br><span class="line">            q2.push(tmp);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = q1.front();</span><br><span class="line">        q1.pop();</span><br><span class="line">        <span class="keyword">while</span>(!q2.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = q2.front();</span><br><span class="line">            q2.pop();</span><br><span class="line">            q1.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q1.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(q1.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = q1.front();</span><br><span class="line">            q1.pop();</span><br><span class="line">            q2.push(tmp);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q1.front();   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="2021/06/24/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>2021/06/24/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>整理二分查找算法。</p><p>以一个二分最经典的例子开始:<br>在一个数组中查找一个元素:<br>input: nums=[-1,0,3,5,9,12], target=9<br>output: 4<br>9在nums中，且index为4</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=nums.size();</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;  <span class="comment">//这种写法防止溢出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)  <span class="comment">//当前值过小，就搜查后半段</span></span><br><span class="line">l=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//如果target不在nums中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个数组的长度为n,那么二分查找的<strong>时间复杂度为O(logn)</strong></p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>二分查找一般分为3个步骤:</p><ol><li>预处理：如果集合未排序，先排序</li><li>二分查找：在循环或递归中在每次比较后将查找空间分为两半</li><li>后处理：在剩余空间中确定可行的候选者</li></ol><h2 id="模版一"><a href="#模版一" class="headerlink" title="模版一"></a>模版一</h2><p>最基础的形式，用于查找可以通过访问数组中的单个索引来确定的元素或者条件。特点有:</p><ul><li>查找条件可以在不与元素两侧进行比较的情况下确定</li><li>不需要后处理，因为每一步都在检查是否找到了元素，如果到了末尾，则未找到元素。</li></ul><p><a href="https://leetcode-cn.com/problems/sqrtx/">LC69X的平方根</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">2</span>) <span class="keyword">return</span> x; </span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x/mid==mid)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x/mid&lt;mid)</span><br><span class="line">            r=mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">LC374猜数字大小</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123; <span class="comment">// 循环直至区间左右端点相同</span></span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>; <span class="comment">// 防止计算时溢出</span></span><br><span class="line">        <span class="keyword">if</span> (guess(mid) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            r = mid; <span class="comment">// 答案在区间 [left, mid] 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>; <span class="comment">// 答案在区间 [mid+1, right] 中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时有 left == right，区间缩为一个点，即为答案</span></span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">LC33搜索旋转排序数组</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=(<span class="keyword">int</span>)nums.size();</span><br><span class="line"><span class="keyword">if</span>(!n)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>]==target?<span class="number">0</span>:<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (l&lt;=r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid]==target) <span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">if</span> (nums[<span class="number">0</span>]&lt;=nums[mid])&#123;  <span class="comment">//[l,mid]是有序的</span></span><br><span class="line"><span class="keyword">if</span>(nums[<span class="number">0</span>]&lt;=target &amp;&amp; target&lt;=nums[mid])&#123;</span><br><span class="line">r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;   <span class="comment">//[mid+1,r]是有序的</span></span><br><span class="line"><span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target&lt;=nums[n<span class="number">-1</span>])</span><br><span class="line">l=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">r=mid<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模版二"><a href="#模版二" class="headerlink" title="模版二"></a>模版二</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=nums.size();</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid]==target) <span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target) l=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后处理,当剩下一个元素时，判断该元素是否符合条件</span></span><br><span class="line"><span class="keyword">if</span> (l!=n &amp;&amp; nums[l] == target) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/first-bad-version/">LC278第一个错误的版本</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isBadVersion(mid))&#123; <span class="comment">//如果为true，继续往前找</span></span><br><span class="line">            r=mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l; <span class="comment">//不断缩小 l到r的范围，直到l&lt;r</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/find-peak-element/">LC162寻找峰值</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这道题给出的假设是nums[-1]=nums[n]= -inf,比如一个数组为[2,1]</span></span><br><span class="line"><span class="comment">//其实默认的数组就是[-inf,2,1,-inf],所以2是峰值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.size();</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">1</span>]&gt;nums[<span class="number">0</span>]?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&lt;nums[mid+<span class="number">1</span>])&#123; <span class="comment">//峰值一定在右边</span></span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                    <span class="comment">//峰值一定在左边</span></span><br><span class="line">            r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">LC153寻找旋转排序数组中的最小值</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&lt;nums[r]) <span class="comment">//如果中间数小于最右边的，说明是升序，那么最小值一定在前半段</span></span><br><span class="line">            r=mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//反之，则在后半段</span></span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模版三"><a href="#模版三" class="headerlink" title="模版三"></a>模版三</h2><p>后处理，还剩下两个元素</p><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">LC34在排序数组中查找元素的第一个和最后一个位置</a><br>这里需要返回两个index</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整体思路为，先找到第一个等于target的位置，记为leftIdx,和第一个大于</span></span><br><span class="line"><span class="comment">//target位置-1， 比如[5,7,7,8,8,10],target=8, 第一个8的位置为3，第二个位置</span></span><br><span class="line"><span class="comment">//为第一个大于8的数字位置，也就是10的位置，减1，也就是5-1=4，所以结果为[3,4]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> target,<span class="keyword">bool</span> lower)</span></span>&#123; </span><br><span class="line"><span class="comment">//lower为true,则查找第一个大于等于target的下标，否则就找第一个大于target的下标</span></span><br><span class="line"><span class="keyword">int</span> n=nums.size();</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>,ans=n;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[mid]&gt;target || (lower &amp;&amp; nums[mid]&gt;= target))&#123;</span><br><span class="line">r=mid<span class="number">-1</span>;</span><br><span class="line">ans=mid;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> leftIdx=binarySearch(nums,target,<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">int</span> rightIdx=binarySearch(nums,target,<span class="literal">false</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.size() &amp;&amp; nums[leftIdx]==target &amp;&amp; nums[rightIdx]==target)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;leftIdx,rightIdx&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对称性递归</title>
      <link href="2021/06/22/%E5%AF%B9%E7%A7%B0%E6%80%A7%E9%80%92%E5%BD%92/"/>
      <url>2021/06/22/%E5%AF%B9%E7%A7%B0%E6%80%A7%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>对称性递归(考虑到左右子树)能够很有效的解决关于二叉树的算法问题，本篇博客整理了有关利用对称性递归解决的二叉树的问题，内容主要来源于<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-uhgs/">力扣题解</a></p><p>树题型主要分为两大类:</p><ul><li>不需要构造辅助函数。其中又分为单数问题，即只有一个树，和双树问题，即需要比较两棵树。</li><li>需要构造辅助函数。这类题目通常用到子树的某一部分进行递归，即要调用辅助函数来比较两个部分子树。</li></ul><h2 id="解题模版"><a href="#解题模版" class="headerlink" title="解题模版"></a>解题模版</h2><ol><li>递归结束条件: 特殊情况的判断。如果是单树问题，一般来说只需要进行以下判断:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!root-&gt;left) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!root-&gt;right) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br></pre></td></tr></table></figure>如果是双树问题(根结点分别为p,q):<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!p || !q) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li><li>返回值: 通常对称性递归的返回值是多个条件的复合判断<br> 可能是以下几种条件的组合:<ul><li>结点非空的判断</li><li>结点值比较判断</li><li>(单树)调用根结点左右子树的递归函数进行递归判断</li><li>(双树)调用两棵树的左右子树的递归函数进行递归判断</li></ul></li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://leetcode-cn.com/problems/same-tree/">LC100相同的树</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode*p,TreeNode*q)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!p &amp;&amp; !q)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//如果两棵树都是空树，那么相等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p &amp;&amp; q &amp;&amp;  <span class="comment">//两棵树都不为空</span></span><br><span class="line">   p-&gt;val == q-&gt;val &amp;&amp; <span class="comment">//根结点相同</span></span><br><span class="line">   (isSameTree(p-&gt;left,q-&gt;left)) &amp;&amp; <span class="comment">//两棵树的左子树相同</span></span><br><span class="line">   (isSameTree(p-&gt;right,q-&gt;right)); <span class="comment">//两棵树的右子树相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">LC104二叉树的最大深度</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> max(height(root-&gt;left),height(root-&gt;right)) + <span class="number">1</span>; <span class="comment">//左右子树的较大者加上根结点的1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">LC110平衡二叉树</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode*&amp;root)</span></span>&#123;</span><br><span class="line"><span class="comment">//特殊判断</span></span><br><span class="line"><span class="keyword">if</span>(!root)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值: 跟结点的左右子树高度相差&lt;=1 &amp;&amp; 左子树是平衡树 &amp;&amp;右子树是平衡树</span></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">abs</span>(height(root-&gt;left) - height(root-&gt;right)) &lt;= <span class="number">1</span>) &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/univalued-binary-tree/">LC965单值二叉树</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//特殊判断：1.空树是单值二叉树 2. 如果左子树非空且根结点与左子结点值不同，则false,右子树同理</span></span><br><span class="line"><span class="comment">//返回值：左子树是单值 &amp;&amp; 右子树是单值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUnivalTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> ((root-&gt;left &amp;&amp; root-&gt;left-&gt;val != root-&gt;val)||(root-&gt;right &amp;&amp; root-&gt;right-&gt;val != root-&gt;val))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> isUnivalTree(root-&gt;left) &amp;&amp; isUnivalTree(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">LC572另一个树的子树</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//特殊判断：有一颗树为空就不成立</span></span><br><span class="line"><span class="comment">//先判断两个树是否相同，如果是就true</span></span><br><span class="line"><span class="comment">//然后判断一棵树的左子树是否是另一棵树的子树/右同样</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode*root1, TreeNode*root2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root1 ||!root2)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(isSameTree(root1,root2))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> isSubtree(root1-&gt;left,root2) || isSubtree(root1-&gt;right,root2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">LC226翻转二叉树</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//特殊判断:空树的翻转依然是本身</span></span><br><span class="line"><span class="comment">//翻转左子树后替换右子树，翻转右子树后替换左子树</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode*left = invertTree(root-&gt;left);</span><br><span class="line">    TreeNode*right = invertTree(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    root-&gt;left=right;</span><br><span class="line">    root-&gt;right=left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">LC617合并二叉树</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//特殊判断: 如果一个为空，那就是另一个树，都是空返回nullptr</span></span><br><span class="line"><span class="comment">//如果都不为空，先把根结点相加，然后递归相加左右子树</span></span><br><span class="line"><span class="function">TreeNode*<span class="title">mergeTrees</span><span class="params">(TreeNode*root1, TreeNode*root2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root1 &amp;&amp; !root2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span>(!root1) <span class="keyword">return</span> root2;</span><br><span class="line"><span class="keyword">if</span>(!root2) <span class="keyword">return</span> root1;</span><br><span class="line"><span class="keyword">if</span>(root1 &amp;&amp; root2)</span><br><span class="line">root1-&gt;val+=root2-&gt;val;</span><br><span class="line"></span><br><span class="line">root1-&gt;left = mergeTrees(root1-&gt;left,root2-&gt;left);</span><br><span class="line">root1-&gt;right = mergeTrees(root1-&gt;right,root2-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>下面两题需要构建辅助函数</strong></p><p><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指offer28对称的二叉树</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个函数判断两棵树是否镜像相等</span></span><br><span class="line"><span class="comment">//特殊判断：都是空树满足，有一个空树不满足</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode*root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isMirror(root, root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode*p,TreeNode*q)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!p &amp;&amp; !q)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!p || !q)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; (isMirror(p-&gt;left,q-&gt;right)) &amp;&amp; (isMirror(p-&gt;right,q-&gt;left));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指offer26树的子结构</a><br>子结构和子树不同，子结构是只要满足至少两个结点的结构和指，而子树必须从结点到叶结点都相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断如果A，B根结点相同，B是不是A的子结构</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasSubStructure</span><span class="params">(TreeNode* A,TreeNode* B)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!B)    <span class="comment">//结束条件1: A的一个结点B的对应位置没有，可以认为是子结构</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(!A || A-&gt;val != B-&gt;val) <span class="comment">//条件2: B的一个结点A的对应位置没有，A,B对应位置结点值不一样</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> hasSubStructure(A-&gt;left,B-&gt;left) &amp;&amp; hasSubStructure(A-&gt;right,B-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!A || !B) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> hasSubStructure(A,B) || isSubStructure(A-&gt;left,B) ||isSubStructure(A-&gt;right,B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数位和增量公式</title>
      <link href="2021/06/19/%E6%95%B0%E4%BD%8D%E5%92%8C%E5%A2%9E%E9%87%8F%E5%85%AC%E5%BC%8F/"/>
      <url>2021/06/19/%E6%95%B0%E4%BD%8D%E5%92%8C%E5%A2%9E%E9%87%8F%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>如果想求一个数所有数位之和，那么很简单:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sums</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line">s+=n%<span class="number">10</span>; <span class="comment">//最后一位的数组</span></span><br><span class="line">n/=<span class="number">10</span>; <span class="comment">//左移一位</span></span><br><span class="line"><span class="comment">//是几进制就把两个10替换成几，比如如果计算二进制，就把10换成2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;  <span class="comment">//比如 16 -&gt; 1+6=7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在十进制情况下。设x的数位和为s(x),x+1的数位和为s(x+1)，则:</p><ol><li>当(x+1)%10 = 0时， s(x+1)=sx-8, 例如 19,20或者29,30的数位和差都是8。</li><li>当(x+1)%10 != 0时, s(x+1)=sx+1, 例如11，12的数位和分别是2，3。</li></ol><p>所以得出:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x+<span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? s_x+<span class="number">1</span> : s_x<span class="number">-8</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BFS&amp;DFS算法</title>
      <link href="2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/"/>
      <url>2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>最近遇到问题比较多的算法及其应用，广度优先和深度优先算法，本篇博客的目的是重新梳理一下这两种算法，整理常见的相关算法题。</p><p>两种算法都是图论里的图搜索算法，用来遍历图的每一个结点。</p><h2 id="BFS-广度优先搜索"><a href="#BFS-广度优先搜索" class="headerlink" title="BFS(广度优先搜索)"></a>BFS(广度优先搜索)</h2><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/bfs1.png" class><p>给出以上的一个图，这个图一共有7个结点，假设起点为1，现在要用广度优先搜索来遍历所有的结点。可以从名字中看出，是广度优先，所以第一次的查找就是与起点1相邻的所有点:</p><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/bfs2.png" class><p>蓝色的点为起点，红色的点是已经遍历到的点，所以第一次搜索的结果为2，4，5。<br>第二次搜索可以从上次搜索结果的任意一点开始，这里我们从最小的值2开始。</p><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/bfs3.png" class><p>绿色的点是第二次搜索的结果，结果为3，6，7，这时所有的点都已经遍历，所以广度优先搜索就完成了。所以整个搜索过程所遍历的结点为 1，2，4，5，3，6，7。<br>对于广度优先搜索，一旦找到某个结点的所有邻居后，这个结点就不会再用到，所以可以用队列(queue)这种先进先出的存储方式来记录结点的过程。</p><p>接下来通过一个稍微复杂的例子，完整的记录下广度优先搜索的过程:</p><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/bfs4.png" class><p>整个过程为下图:</p><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/bfs5.png" class><p>这里需要设置一个数组用来储存已经访问过的结点，还有一个队列用来记录，每一个新的结点都会进入队列，当这个结点寻找所有邻居结点前，先要出列，并且记录到已访问的结点。大概的过程就是1-&gt; 4,2,  4-&gt;3, 2-&gt;5,7,8, 3-&gt;9,10, 5-&gt;6。</p><p>用c++实现bfs</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj)</span></span>&#123;</span><br><span class="line"><span class="comment">//adjacency list representation</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">// number of nodes;</span></span><br><span class="line">    <span class="keyword">int</span> s; <span class="comment">//source vertex</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n)</span></span>;</span><br><span class="line">    vector&lt;int&gt; dist(n),pos(n);</span><br><span class="line"></span><br><span class="line">    q.push(s);</span><br><span class="line">    visited[s]=<span class="literal">true</span>;</span><br><span class="line">    pos[s]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> v=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u: adj[v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[u])&#123;</span><br><span class="line">                visited[u]=<span class="literal">true</span>;</span><br><span class="line">                q.push(u);</span><br><span class="line">                dist[u]=dist[v]+<span class="number">1</span>;</span><br><span class="line">                pos[u]=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS(深度优先搜索)"></a>DFS(深度优先搜索)</h2><p>以上一个图为例，深度优先搜索的第一次搜索为: 1,4,3,10</p><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/dfs1.png" class><p>当10不能再继续搜索的时候，需要回到上一个点3，然后搜索，结果为9</p><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/dfs2.png" class><p>9 不能接续搜索，再次回到3,接下来搜2的最大深度:</p><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/dfs3.png" class><p>到这里所有的结点都已经被访问。<br>深度优先用栈(stack)来记录结点。整个过程为:</p><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/dfs4.png" class><p>用C++实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visisted;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    visisted[v]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u:adj[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visisted[u])</span><br><span class="line">            dfs(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法比较"><a href="#算法比较" class="headerlink" title="算法比较"></a>算法比较</h2><p>在一般的算法问题中，两种算法都可以使用，只是在特定的情况下各有优劣。</p><p>广度优先搜索:</p><ul><li><p>优点:</p><ul><li>对于解决最短或长最少问题有效，搜寻深度小</li><li>每个结点只访问一次，结点总是以最短路径被访问。</li></ul></li><li><p>缺点:</p><ul><li>内存耗费较大(需要大量的数组单元来存储)</li></ul></li></ul><p>广度优先算法更适合在较大范围或不断扩大遍历范围找到相对最优解。比如走迷宫的最短路径，计算机网络数据链路层最短跳数。</p><p>深度优先搜索:</p><ul><li><p>优点:</p><ul><li>能找出所有解决方案</li><li>内存需求较少</li></ul></li><li><p>缺点：</p><ul><li>需要多次遍历，在时间方面效率不高</li></ul></li></ul><p>深度优先适合有明确目标或范围较小的情况。</p><h2 id="相关算法应用"><a href="#相关算法应用" class="headerlink" title="相关算法应用"></a>相关算法应用</h2><p>如果把图看成数的结构的话，那么广度优先搜索就可以表示二叉树的层序遍历，深度优先搜索就可以表示前序遍历。<br>举例：一个二叉树为</p><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/bt.png" class><ul><li>层序: [3,9,20,null,null,15,7]</li><li>前序: [3,9,20,15,null,null,7]</li><li>中序: [null,9,null,3,15,20,7]</li><li>后序: [null,null,9,15,7,20,3]</li></ul><p>用广度优先算法实现二叉树的层序遍历:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设树结点的数据结构已经给出</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root); <span class="comment">//首先把跟结点加入队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> curSize=q.size();</span><br><span class="line">        ans.push_back(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ());<span class="comment">//记录每一层的结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=curSize;++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> node=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            ans.back().push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; <span class="comment">// [[3],[9,20],[15,7]]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用深度优先实现二叉树的前序遍历:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">        s.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* cur = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        ans.push_back(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">            s.push(cur-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">            s.push(cur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/">LC1315 祖父结点值为偶数的结点和</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> gp,<span class="keyword">int</span> p,TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(gp % <span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            ans+=node-&gt;val;</span><br><span class="line"></span><br><span class="line">        dfs(p,node-&gt;val,node-&gt;left);</span><br><span class="line">        dfs(p,node-&gt;val,node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumEvenGrandparent</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">1</span>,root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="网格问题"><a href="#网格问题" class="headerlink" title="网格问题"></a>网格问题</h2><p><a href="https://leetcode-cn.com/problems/max-area-of-island/">LC695岛屿的最大面积</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;grid.size();++r)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;grid[<span class="number">0</span>].size();++c)&#123;</span><br><span class="line">                <span class="keyword">int</span> a= Area(grid,r,c); <span class="comment">//求出每个岛屿的面积</span></span><br><span class="line">                res=max(res,a); <span class="comment">//找出最大的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求面积</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Area</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!inArea(grid,r,c)) <span class="comment">//base case</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[r][c]!=<span class="number">1</span>) <span class="comment">//如果这个格子不是岛屿</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        grid[r][c]=<span class="number">2</span>;  <span class="comment">//把遍历过的点变成2，防止重复计算</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归分别找上下左右</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+Area(grid,r<span class="number">-1</span>,c)</span><br><span class="line">                +Area(grid,r+<span class="number">1</span>,c)</span><br><span class="line">                +Area(grid,r,c<span class="number">-1</span>)</span><br><span class="line">                +Area(grid,r,c+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断边界条件，是不是在格子内</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">inArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r&gt;=<span class="number">0</span>&amp;&amp;r&lt;grid.size()&amp;&amp;c&gt;=<span class="number">0</span>&amp;&amp;c&lt;grid[<span class="number">0</span>].size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/number-of-islands/">LC200岛屿数量</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.size();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].size();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!inArea(grid,i,j)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j]!=<span class="string">&#x27;1&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        dfs(grid,i<span class="number">-1</span>,j);</span><br><span class="line">        dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i,j<span class="number">-1</span>);</span><br><span class="line">        dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">inArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i&gt;=<span class="number">0</span> &amp;&amp; i&lt;grid.size() &amp;&amp; j&gt;=<span class="number">0</span> &amp;&amp; j&lt;grid[<span class="number">0</span>].size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/island-perimeter/">LC463岛屿的周长</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=grid.size(),m=grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)</span><br><span class="line">                    res+=Perimeter(i,j,grid,n,m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Perimeter</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=n || j&lt;<span class="number">0</span> || j&gt;=m ||grid[i][j]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j]!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        grid[i][j]=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;++k)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=i+dx[k];</span><br><span class="line">            <span class="keyword">int</span> y=j+dy[k];</span><br><span class="line">            p+=Perimeter(x,y,grid,n,m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/making-a-large-island/">LC827最大人工岛</a></p><p>岛屿面积的升级版，思路就是把每一个岛的面积及其标识(用color)放到一个map里面。需要两次遍历，第一次给每个岛屿上色，第二次插入一个陆地到海洋，然后计算最大面积。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n,color=<span class="number">2</span>,maxarea=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m; <span class="comment">// mark color to every island</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dir=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;; <span class="comment">//four direction</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        n=grid.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    color++;</span><br><span class="line">                    bfs(grid,i,j,color);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">//记录四周的颜色</span></span><br><span class="line">                    <span class="keyword">int</span> area=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;++k)&#123;</span><br><span class="line">                        <span class="keyword">int</span> x=i+dir[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y=j+dir[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;n &amp;&amp; !s.count(grid[x][y]))&#123;</span><br><span class="line">                            s.insert(grid[x][y]); <span class="comment">//插入颜色</span></span><br><span class="line">                            area+=m[grid[x][y]]; <span class="comment">//加入这种颜色的陆地面积</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxarea=max(maxarea,area);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxarea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> color)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> area=<span class="number">0</span>,x,y;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(&#123;i,j&#125;);</span><br><span class="line">        grid[i][j]=color;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            x=q.front().first;</span><br><span class="line">            y=q.front().second;</span><br><span class="line">            q.pop();</span><br><span class="line">            area++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;++k)&#123;</span><br><span class="line">                i=x+dir[k][<span class="number">0</span>];</span><br><span class="line">                j=y+dir[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=<span class="number">0</span> &amp;&amp; i&lt;n &amp;&amp; j&gt;=<span class="number">0</span> &amp;&amp; j&lt;n &amp;&amp; grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    q.push(&#123;i,j&#125;);</span><br><span class="line">                    grid[i][j]=color;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m[color]=area;</span><br><span class="line">        maxarea=max(maxarea,area);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer笔记</title>
      <link href="2021/06/14/C-Primer%E7%AC%94%E8%AE%B0/"/>
      <url>2021/06/14/C-Primer%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h2><h3 id="运算类型"><a href="#运算类型" class="headerlink" title="运算类型"></a>运算类型</h3><p><strong>(Arithmetic types)</strong></p><img src="/2021/06/14/C-Primer%E7%AC%94%E8%AE%B0/arithmetic.png" class><p><strong>运算类型分为两大类：整数类型（包括bool和char)和浮点类型。</strong><br>对于整数类型的大小，语言保证了short &lt;= int &lt;= long &lt;=long long。<br>对于浮点类型, float通常代表一个字(32bits),double代表两个字(64bits)，long double代表三个或四个字（96 or 128bits)。float和double分别产生7和16位有效数字。</p><h3 id="有符号和无符号类型"><a href="#有符号和无符号类型" class="headerlink" title="有符号和无符号类型"></a>有符号和无符号类型</h3><p><strong>(signed and unsigned types)</strong></p><p>除了bool和拓展的char类型(不包括char)，其他的整数类型都可以分为有符号的和无符号的。有符号的整数可以为负数或正数，无符号的整数只能为正数。int,short,long,long long都是有符号的，在其前面加上unsigned就变成无符号的，比如 unsigned long;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">-1</span>; <span class="comment">//unsigned是大于0的</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//打印出来并不是-1</span></span><br></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//conversion</span></span><br><span class="line"><span class="keyword">bool</span> b =<span class="number">42</span>;<span class="comment">// b is 1(true). the result is false if 0 and true otherwise</span></span><br><span class="line"><span class="keyword">int</span> i=b;  <span class="comment">//i=1</span></span><br><span class="line">i=<span class="number">3.14</span>; <span class="comment">//i=3</span></span><br><span class="line"><span class="keyword">double</span> pi=i; <span class="comment">//pi=3.0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c = <span class="number">-1</span>; <span class="comment">//假设一个char为8bits,c=255</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> c2=<span class="number">256</span>; <span class="comment">//假设一个char为8bits，c2 is undefined</span></span><br></pre></td></tr></table></figure><ul><li>如果给unsigned 赋值一个超出数据类型范围的值，如第六行，那么所得的值就是(unsigned)(赋值) % 256。在本例中就是(unsigned)-1 % 256 = 255</li><li>如果如果给signed<br>赋值一个超出数据类型范围的值，如第七行，那么就是undefined,可能为0，也可能出错。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>尽管都是用=符号来表示，初始化(initialize)和赋值(assignment)是两个不同的概念。初始化是在变量创建的时候给予一个值，赋值是消除对象现有的值并替换成一个新的值。<br>四种初始化方法:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中&#123;&#125;稍微特殊一点，如果初始化可能出现数据丢失的情况，那么就报错，比如</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld=<span class="number">3.1415926</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;ld&#125;,b=&#123;ld&#125;;<span class="comment">//错误</span></span><br><span class="line">int c(ld),d=ld; //允许，不过数据会消减</span><br></pre></td></tr></table></figure><h3 id="变量的声明和定义"><a href="#变量的声明和定义" class="headerlink" title="变量的声明和定义"></a>变量的声明和定义</h3><p><strong>(declarations and definitions)</strong></p><p>C++是可以多个文件共同编译的，也就意味着一个文件里可能会用到另一个文件里的变量，比如std::cout和std::cin就是来自于标准库的对象。<br>在C++中，有声明和定义这两个概念。声明就是当一个文件想用在另一个文件中定义的对象，声明明确了一个变量的名称和类型；定义就是创建了相关对象，定义在名称和类型之上，还分配了存储空间(可能会初始化）。<br><strong>定义一定是声明，但声明不一定是定义。</strong><br>为了获得一个声明而不是定义的变量，我们可以在前面加上一个关键字extern，但是不能初始化:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">//声明但没有定义i</span></span><br><span class="line"><span class="keyword">int</span> j; <span class="comment">//声明和定义j</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只要有初始化的值都是定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi=<span class="number">3.14</span>;<span class="comment">//定义，但是不能在函数中使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi=<span class="number">3.14</span>; <span class="comment">//错误</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>变量只能被定义一次，但可以被声明多次。</strong></p><p>在多个文件中，一个变量只能在一个文件中定义，其他文件使用这个变量的时候只能声明，不能定义。</p><h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> reused=<span class="number">42</span>; <span class="comment">//global scope</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> unique=<span class="number">0</span>;<span class="comment">//block scope, can only used inside &#123;&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;reused&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;unique&lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//42 0</span></span><br><span class="line">    <span class="keyword">int</span> reused=<span class="number">0</span>; <span class="comment">//new, local object named reused</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;reused&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;unique&lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//0 0</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;::reused&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;unique&lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//42 0 使用全局变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">100</span>,sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 100 45</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h3><p>const 提供了一种只读的变量，也就是不可修改。用来定义像buffer size这样固定不变的值。<br>const变量必须要初始化且不能更改。<br>在默认情况下，const对象只能在本文件使用(local to the file)。为了在多个文件中使用同一个const,需要在定义和声明的时候都加一个关键字extern:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bufsize=<span class="number">512</span>; <span class="comment">//只能在本文件使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//file1.cpp 定义一个可被其他文件使用的const</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufsize=fcn();</span><br><span class="line"></span><br><span class="line"><span class="comment">//file1.h文件中可以使用file1.cpp里定义的bufsize</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufsize;</span><br></pre></td></tr></table></figure><p><strong>引用一个const</strong></p><p>引用一个const和引用一个普通变量是不一样的，首先引用的类型要和const一样，且也不能改变</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1=ci; <span class="comment">//ok, both are const</span></span><br><span class="line">r1=<span class="number">42</span>; <span class="comment">//错误，r1也是一个const 不能更改</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2=ci; <span class="comment">//错误。非const不能引用一个const</span></span><br></pre></td></tr></table></figure><p><strong>引用const的初始化</strong></p><p>引用const初始化的类型几乎是所有类型（只要能满足初始化的类型能够转化成所引用的类型)，比如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1=i; <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2=<span class="number">42</span>; <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3=r1*<span class="number">2</span>; <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4= r1*<span class="number">2</span>; <span class="comment">//error.因为r4是一个nonconst</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dval=<span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri=dval;  <span class="comment">//ok,只不过这里的ri变为了3</span></span><br></pre></td></tr></table></figure><p><strong>指针和const</strong><br>和引用相似，指向一个const意味着这个指针不能再指向别的地方。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="number">3.14</span>; <span class="comment">//pi是一个const,它的值不能改变</span></span><br><span class="line"><span class="keyword">double</span> *ptr=&amp;pi;  <span class="comment">//错误，ptr只是一个普通的指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr=&amp;pi; <span class="comment">//ok</span></span><br><span class="line">*cptr=<span class="number">42</span>; <span class="comment">//错误，不能改变值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dval=<span class="number">3.14</span>; <span class="comment">//dval是double,可以改变值</span></span><br><span class="line">cptr = &amp;dval; <span class="comment">//ok，但是不能通过cptr改变dval</span></span><br></pre></td></tr></table></figure><p>const指针<br>pointer本身也可以是const</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> errNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr=&amp;errNum; <span class="comment">//curErr will always point to errNum</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip=&amp;pi; <span class="comment">//pip is a const pointer to a const object</span></span><br></pre></td></tr></table></figure><p>对于过长的声明，我们可以从右到左来理解。举一个例子，第二行代码，curErr是名字，它的左边是const，说明curErr是一个const对象，再往左是 * ， 说明curErr是一个const指针，最后是int，说明curErr是一个指向int类型的const指针。<br>同样的,pip是一个指向const double类型的一个const pointer。</p><p>const pointer只能说明这个指针指向的位置不能改变，并不代表所指向的值不能改变，所指向的值取决于它的类型，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*pip = <span class="number">2.72</span>; <span class="comment">//error.因为pip所指向的值是一个const</span></span><br><span class="line"><span class="comment">//如果curErr指向的值(errNum)是非0</span></span><br><span class="line"><span class="keyword">if</span>(*curErr)&#123;</span><br><span class="line">    errorHandler();</span><br><span class="line">    *curErr = <span class="number">0</span>; <span class="comment">//ok, 改变errNum的值为0.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Top-level const and low-level const</strong></p><p>顶层const是指对象本身就是const，底层const是指针指向一个const。顶层const可以应用于任何对象，比如 基本的运算类型，类 或者指针。底层const在一些复合类型如指针或引用中使用。对于指针类型，可以同时拥有顶层const和底层const。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1=&amp;i; <span class="comment">//p1的值不能改变，const是顶层</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=<span class="number">42</span>;  <span class="comment">//ci不能改变，const 是顶层</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2=&amp;ci; <span class="comment">//p2可以改变，const是底层</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3=p2; <span class="comment">//第一个const是底层，第二个是顶层</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = ci; <span class="comment">//引用类型的const 永远是底层</span></span><br></pre></td></tr></table></figure><p>当拷贝一个对象的时候，顶层const被忽略掉:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i=ci; <span class="comment">//ok: 拷贝ci的值， ci的顶层const被忽略</span></span><br><span class="line">p2=p3; <span class="comment">//ok： p3的顶层const被忽略</span></span><br></pre></td></tr></table></figure><p>底层const不能被忽略，当拷贝一个对象的时候，如果被拷贝一方是底层，那么另一方也必须是底层。我们可以把一个non-const转换成一个const, 但是反过来不行.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p = p3; <span class="comment">//error p3是low level, p不是</span></span><br><span class="line"><span class="keyword">int</span> p2=p3; <span class="comment">//ok， p2,p3都是low level</span></span><br><span class="line">p2=&amp;i; <span class="comment">//ok, 可以把int * 转换成const int *</span></span><br><span class="line"><span class="keyword">int</span> &amp;r=ci; <span class="comment">//error, not match</span></span><br><span class="line"><span class="keyword">const</span> inr &amp;r2 = i; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><p><strong>constexpr &amp; constant expressions</strong><br>constant expressions 是一个值不变的表达式，可以通过编译。所有的literal就是constant expressions, 比如 ‘a’, 1, 3.14159L 都是一个constant expressions, 如果一个const对象被初始化为constant expression, 那这个对象就是constant expression。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_files = <span class="number">20</span>; <span class="comment">// max_files 是constant expression</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> limit = max_files+<span class="number">1</span>; <span class="comment">// limit 是constant expression</span></span><br><span class="line"><span class="keyword">int</span> staff_size = <span class="number">27</span>; <span class="comment">// staff_size 不是c.e , 虽然初始化为一个literal ，但是它不是const对象</span></span><br><span class="line"><span class="keyword">const</span> in sz = get_size(); <span class="comment">//sz不是c.e, 因为get_size()在运行之前不知道是什么，所以sz也不是。</span></span><br></pre></td></tr></table></figure><p>constexpr 是C++11的新特性。在变量之前声明它就说明这个对象为const,而且必须以一个constant expression初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>; </span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> limit = mf+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = size(); <span class="comment">//ok if size() is a constexpr function</span></span><br></pre></td></tr></table></figure><p><strong>class类， 库I/O以及string类型不可以使用constexpr</strong></p><p><strong>指针与constexpr</strong><br>constexpr 与 const不同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>; <span class="comment">// p is a pointer to a const int</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> * q = <span class="literal">nullptr</span>; <span class="comment">//q is a const pointer to int </span></span><br><span class="line"><span class="comment">//上面的定义相当于。int const* q = nullptr;</span></span><br></pre></td></tr></table></figure><h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><p><strong>Type alias(别名)</strong><br>在C++中，有两种定义别名的方法:</p><ol><li>typedef <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages; <span class="comment">// wages 是double别名</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">// base 是double别名, p是double *</span></span><br><span class="line">wages hourly,weekly; <span class="comment">//等同于double hourly,weekly;</span></span><br></pre></td></tr></table></figure></li><li>在C++11新标准中，可以用using来定义 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">// SI 是Sales_item类的别名</span></span><br><span class="line">SI item;  <span class="comment">//等同于Sales_item item;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>pointer, const and type aliases</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr=<span class="number">0</span>; <span class="comment">// cstr is a constant pointer to char</span></span><br><span class="line"><span class="keyword">const</span> pstring *ps;   <span class="comment">//ps is a pointer to a constant pointer to char</span></span><br><span class="line"><span class="comment">//第二行等同于char *const cstr=0;</span></span><br></pre></td></tr></table></figure><p><strong>auto type</strong><br><strong>C++11新特性</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C/C++指针和引用</title>
      <link href="2021/06/07/C-C-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/"/>
      <url>2021/06/07/C-C-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>对我来说，C/C++语言中最大的难点就是指针和引用的概念及其应用，为了更好更深入的理解，我找到三本包含C/C++指针和引用的教科书。这篇文章是根据几本经典教材 <em>(reference在文末）</em>，以及网上的一些资料加上自己的理解整理而成。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>内存和地址</strong><br>我们可以把计算机的内存看作一条长街上的一排房屋，每个房屋都可以容纳数据，且有一个独特的房号来标识别。比如：</p><pre>  0   1   2   3  ...｜  ｜  ｜  ｜  ｜ ...</pre><p>这些位置的每一格都被称为字节(byte)，每个字节都包含了存储一个字符所需要的位数。在许多现代机器上(64位),每个字节包含8个位，可以存储无符号值0 - 255，或有符号值 -127 - 128。<br>为了存储更大的值，我们可以把两个或多个字节结合在一起作为一个更大的内存单位。比如</p><pre>    0     4    8   |    |    |    | </pre><p>上图是以4字节的字来表示，内存位置与图一相同。这时每个字(每一格)可以容纳无符号整数范围是 0-4294967295(2^32-1),有符号的整数范围是-2^31 - 2^31-1。<br>总结下来有两点需要注意：</p><ol><li>内存中的每个位置由一个独一无二的地址标识。</li><li>内存中的每个位置都包含一个值。</li></ol><p>需要注意的一点是：名字/编号与内存位置之间的关联并不是由硬件来提供的，而是由编译器为我们实现的。变量给了我们更方便的方法记住地址- <strong>硬件仍然通过地址访问内存地址</strong>。</p><p><strong>指针的定义为：一个存储其他变量地址的变量。</strong></p><p><strong>表达方式</strong></p><ul><li>指针: int * a =b, a 指向b的值。</li><li>在C语言中&amp;符号的代表着取址，这和C++中引用的概念不一样。<br>下面举一个例子：<pre>一段内存地址与值：a    b     c           d     e|112 | -1 | 107852331|100 |108  |a-b是地址的名称，他们分别对应的地址是 a=100,b=104,c=108,d=112,e=116</pre>接下来给出一些声明：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">112</span>,b=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">float</span> c=<span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> *d=&amp;a;  </span><br><span class="line"><span class="keyword">float</span> *e=&amp;c;</span><br></pre></td></tr></table></figure>那么结果为:<table><thead><tr><th align="left">表达式</th><th align="left">右值</th><th align="left">类型</th></tr></thead><tbody><tr><td align="left">a</td><td align="left">112</td><td align="left">int</td></tr><tr><td align="left">b</td><td align="left">-1</td><td align="left">int</td></tr><tr><td align="left">c</td><td align="left">3.14</td><td align="left">float</td></tr><tr><td align="left">d</td><td align="left">100</td><td align="left">int *</td></tr><tr><td align="left">e</td><td align="left">108</td><td align="left">float *</td></tr><tr><td align="left">*d</td><td align="left">112</td><td align="left">int</td></tr><tr><td align="left">*e</td><td align="left">3.14</td><td align="left">float</td></tr></tbody></table></li></ul><p>需要注意的是，d和e被声明为指针并不改变这些表达式的求值方式:一个变量的值就是分配给这个变量内存位置所存储的值。* d的值为112，是因为* d = &amp;a, 可以理解为a地址的内容。因此，d是一个指向整数的指针，* d是一个整数。<br>通过C代码来更一步的了解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a; <span class="comment">//声明一个整数a</span></span><br><span class="line">    <span class="keyword">int</span> *P; <span class="comment">//声明一个指针P</span></span><br><span class="line">    P=&amp;a; <span class="comment">//P 等于 a的地址</span></span><br><span class="line">    a=<span class="number">5</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address of a: %p\n&quot;</span>,&amp;a); <span class="comment">// a的地址，会打印一个十六进制的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address stored in pointer P: %p\n&quot;</span>,P); <span class="comment">//跟上一行打印的一样</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value of *P: %d\n&quot;</span>,*P); <span class="comment">//5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address of P: %p\n&quot;</span>,&amp;P); <span class="comment">//指针P的地址，也是一个十六进制数字</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    *P=<span class="number">8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value of a: %d\n&quot;</span>,a); <span class="comment">//8， a的值变为8</span></span><br><span class="line">    <span class="comment">//因为P是一个地址， *P表示P所指向的地址的值，也就是a</span></span><br><span class="line">    a=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value of a: %d\n&quot;</span>,*P); <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">20</span>; <span class="comment">//定义一个新的整数b=20</span></span><br><span class="line">    *P=b;   <span class="comment">//只是把P所指向地址的值改为20，即a改为20</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address stored in P is %p\n&quot;</span>,P); <span class="comment">//a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value at P is %d\n&quot;</span>,*P); <span class="comment">//20</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value of a: %d\n&quot;</span>,a); <span class="comment">//20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针的类型和运算"><a href="#指针的类型和运算" class="headerlink" title="指针的类型和运算"></a>指针的类型和运算</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    p=&amp;a;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of integer is %d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">//查看变量int的大小，为4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address stored in p: %d\n&quot;</span>,p); <span class="comment">//打印出p所指向的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address stored in p+1: %d\n&quot;</span>,p+<span class="number">1</span>); <span class="comment">//打印出原来p所指向地址的下一个地址， 比上面的地址大4。 如上一个地址是64，这次打印的就是68</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value at address p+1 is %d\n&quot;</span>,*(p+<span class="number">1</span>)); <span class="comment">//会产生一个随机数，因为在p+1地址上我们并没有定义一个整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1025</span>;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    p=&amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address at p = %d, value = %d\n&quot;</span>,p,*p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *p0; <span class="comment">//声明一个类型为char的指针</span></span><br><span class="line">    p0=(<span class="keyword">char</span> *)p; <span class="comment">//p0指向和p同一个地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of char is %d byte(s)\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)); <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address at p0 = %d,value = %d\n&quot;</span>,p0,*p0); <span class="comment">//p0的地址和p一样，但是这里的 *p0=1</span></span><br><span class="line">    <span class="comment">//原因如下：1025 如果用32位的二进制表示的话就是</span></span><br><span class="line">    <span class="comment">// 00000000 00000000 00000100 00000001 -&gt; 1+1x2^10 = 1025，总共有4个字节</span></span><br><span class="line">    <span class="comment">//因为p0指向和p相同的地址，而p0是char，只有一个字节的大小，</span></span><br><span class="line">    <span class="comment">//所以p0 只读到了 00000001,即1. (从最低为开始读)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address at p0+1 = %d,value = %d\n&quot;</span>,p0+<span class="number">1</span>,*(p0+<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//p0+1指向的地址比p0大1，这时*(p0+1)=4,因为这时读取第二个字节，也就是00000100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> **q; <span class="comment">// pointer to pointer</span></span><br><span class="line">    q=&amp;p;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p); <span class="comment">//5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address stored in p %d\n&quot;</span>,p); <span class="comment">// x的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*q); <span class="comment">// 指向指针p的值，p的值也就是x的地址，和上面一样</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(*q));<span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常绕，需要多看几遍，多敲几次代码！</p><h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">1</span>&#125;; <span class="comment">// 5x4=20 bytes in total， 数组</span></span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    p=A;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A);  <span class="comment">//数组A第一个元素的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;A[<span class="number">0</span>]); <span class="comment">//数组A第一个元素的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A[<span class="number">0</span>]); <span class="comment">//2，第一个元素的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*A); <span class="comment">//2，第一个元素的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(A+i)); <span class="comment">//2，4，5，8，1 遍历数组</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="C-中的引用-references"><a href="#C-中的引用-references" class="headerlink" title="C++中的引用(references)"></a>C++中的引用(references)</h2><p>声明引用就是某一变量的别名，对引用的操作与对变量直接操作完全一样。与C语言不同， &amp;不是求地址运算，而是起标识作用。比如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival=<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal=ival; <span class="comment">//refVal 是ival的引用，即别名</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal2; <span class="comment">//错误，声明引用必须对其进行初始化。</span></span><br></pre></td></tr></table></figure><ul><li>引用必须对其进行初始化</li><li>声明一个引用，不是定义了一个新变量，它只表示该引用名是目标变量的一个别名，它本身不是一个数据类型，因此不占用存储单元，系统也不会给分配存储单元。所以对引用求地址，就是对目标变量求地址，即 refVal= ival=1024; &amp;refVal=&amp;ival (地址)。</li><li>不能建立数组的引用。因为数组是由若干个元素组成的集合，所以无法建立一个数组的别名。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">refVal=<span class="number">2</span>; <span class="comment">// 给refVal所引用的赋值2，也就是给ival赋值为2</span></span><br><span class="line"><span class="keyword">int</span> ii = refVal; <span class="comment">// 等同于 ii=ival</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal3 = refVal; <span class="comment">// refVal3是refVal的引用，也就是ival的引用</span></span><br><span class="line"><span class="keyword">int</span> i = refVal; <span class="comment">// 初始化i的值为ival</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>定义引用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1024</span>,i2=<span class="number">2048</span>; <span class="comment">//i and i2 both ints</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = i, r2=i2; <span class="comment">//r is a reference bound to i; r2 is an int</span></span><br><span class="line"><span class="keyword">int</span> i3=<span class="number">1024</span>,&amp;ri=i3; <span class="comment">//i3 is int, ri is a reference bound to i3</span></span><br><span class="line"><span class="keyword">int</span> &amp;r3=i3,&amp;r4=i2; <span class="comment">// both r3 and r4 are references</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;refVal4=<span class="number">10</span>; <span class="comment">//错误，初始化必须为一个对象</span></span><br><span class="line"><span class="keyword">double</span> dval=<span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal5=dval; <span class="comment">//错误，这里的初始化必须为int</span></span><br></pre></td></tr></table></figure><h2 id="引用一个指针"><a href="#引用一个指针" class="headerlink" title="引用一个指针"></a>引用一个指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p; <span class="comment">//p是一个指向整数的指针</span></span><br><span class="line"><span class="keyword">int</span> *&amp;r=p; <span class="comment">// r是指针p的引用</span></span><br><span class="line"></span><br><span class="line">r=&amp;i; <span class="comment">//r 引用了一个指针，给r赋值&amp;i 相当于给p赋值&amp;i，也就是p指向i</span></span><br><span class="line">*r=<span class="number">0</span>; <span class="comment">//dereferencing r 产生i,i就是p所指向的，相当于把i变为0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ programming</title>
      <link href="2021/06/04/C-programming/"/>
      <url>2021/06/04/C-programming/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“If you do not change direction, you may end up where you were heading.”<br>– Lao Tzu</p></blockquote><p>本篇的主要框架和内容来自于新南威尔士大学(UNSW)课程COMP6771(Advanced C++ programming),用于记录和总结自己的学习成果,除此之外一些更为详细的补充内容都取自 <em>essential C++(Lippman)</em> 和 <em>C++ primer(Lippman)</em> 这两本经典教科书 (都出自同一人之手）。主要内容分为8部分（每一部分有更详细的划分），分别为:</p><ol><li><a href="#Intro">C++ Introduction</a></li><li><a href="#STL">STL (标准模版库)</a></li><li><a href="#Class">Class Types (类&amp;对象)</a></li><li>Exception Handling (异常处理)</li><li>Resource Management and Smart Pointers (内存管理和智能指针)</li><li>Templates (模版)</li><li>Advanced templates (进阶模版)</li><li>Advanced OO (进阶面向对象编程)</li></ol><p>博客的写作风格以代码为主，语言解释为辅，以知识点为主要框架进行，而且省略了不少细节(有关详细内容请参考另一篇博客C++Primer笔记)。着重记录了自己以前没有接触过的新知识以及容易犯错的知识点。</p><p>Let’s explore the world of C++!</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;   //iostrem 库的相关头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello,world!\n&quot;</span>;  <span class="comment">//print</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="variables"><a href="#variables" class="headerlink" title="variables"></a>variables</h3><p>c++中主要的数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>; <span class="comment">// i is an int</span></span><br><span class="line"><span class="keyword">double</span> j = <span class="number">2.5</span>; <span class="comment">//j is a double</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s= <span class="string">&quot;hello&quot;</span>;<span class="comment">//s is a string</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; <span class="comment">//c is a character</span></span><br><span class="line"><span class="keyword">auto</span> k=<span class="number">3.5</span>; <span class="comment">// k is a double, auto的数据类型取决于等号右边的类型</span></span><br><span class="line"><span class="keyword">auto</span> check = <span class="literal">true</span>; <span class="comment">//check is a boolean, either true or false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;check&lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//打印1. true为1，false为0</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f; <span class="comment">//vector 属于类模版，后面的尖括号定义了vector所包含的元素类型，为数组</span></span><br><span class="line"><span class="keyword">auto</span> a=f;<span class="comment">//  a is a vector (copy of f)</span></span><br><span class="line">f.push_back(<span class="number">5</span>); <span class="comment">// add 5 to f, 此时的f为 [5]</span></span><br><span class="line">f.push_back(<span class="number">4</span>); <span class="comment">//add 4 to f, 此时的f为[5,4]</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f.size() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//f的长度为2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;f[<span class="number">1</span>]&lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//打印结果为4， f[1]=4</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="constant"><a href="#constant" class="headerlink" title="constant"></a>constant</h3><p>只读<strong>const</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i; <span class="comment">// 错误，const初始化必须要赋值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">// i = 1 ，且不可修改</span></span><br><span class="line">i++; <span class="comment">//错误， i不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> m = <span class="number">42</span>; <span class="comment">//m is an int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h3><p>函数的应用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="comment">//求矩形面积的函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">rectangular_area</span><span class="params">(<span class="keyword">double</span> <span class="keyword">const</span> width,<span class="keyword">double</span> <span class="keyword">const</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> width * length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调色盘函数</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">rgb</span><span class="params">(<span class="keyword">short</span> r =<span class="number">0</span>,<span class="keyword">short</span> g=<span class="number">0</span>,<span class="keyword">short</span> b=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::stringsretam my_string;</span><br><span class="line">my_string &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; r &lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;g&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> my_string.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rectangular_area(<span class="number">2.0</span>,<span class="number">4.0</span>) &lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//8.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; rgb(); <span class="comment">// (0,0,0)  默认参数为0</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; rgb(<span class="number">100</span>); <span class="comment">// (100,0,0)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; rgb(<span class="number">100</span>,<span class="number">200</span>); <span class="comment">//(100,200,0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="references"><a href="#references" class="headerlink" title="references"></a>references</h3><p>c++的引用，具体细节在前一篇博客中有描述</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> i= <span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; j= i; <span class="comment">//j只是i的一个别名</span></span><br><span class="line">j= <span class="number">3</span> ; <span class="comment">//相当于i=3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;i &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt;j&lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// print &quot;3 3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> k= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span>&amp; ref= k;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ref&lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//1</span></span><br><span class="line">k++;  <span class="comment">//this is fine</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ref&lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//2</span></span><br><span class="line">ref++; <span class="comment">//错误， 因为ref为const</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span>&amp; mref = m;<span class="comment">// this is ok</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mref &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="enumration"><a href="#enumration" class="headerlink" title="enumration"></a>enumration</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">colors</span> &#123;</span> red = <span class="number">4</span>, black &#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">suit</span> &#123;</span> heart, diamond = <span class="number">8</span>, spade = <span class="number">4</span>, club &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//会打印4，5。 没有赋值的元素就是前一个的值加一（如果前面的元素赋值了）</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The value of color: &quot;</span> &lt;&lt; red &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; black &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">//会打印0，8，4，5。第一个元素没有赋值，所以为0.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The value of suit: &quot;</span> &lt;&lt; heart &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; diamond &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; spade &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; club</span><br><span class="line">          &lt;&lt; <span class="string">&quot;\n &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><ol><li>set中的元素是排序好的</li><li>set中的元素是唯一的，即不重复的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义一个无序set</span></span><br><span class="line"><span class="keyword">auto</span> computer_scientists = <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&#123;</span><br><span class="line"><span class="string">&quot;Lovelace&quot;</span>,</span><br><span class="line"><span class="string">&quot;Babbage&quot;</span>,</span><br><span class="line"><span class="string">&quot;Turing&quot;</span>,</span><br><span class="line"><span class="string">&quot;Hamilton&quot;</span>,</span><br><span class="line"><span class="string">&quot;Church&quot;</span>,</span><br><span class="line"><span class="string">&quot;Borg&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (computer_scientists.contains(<span class="string">&quot;Lovelace&quot;</span>)) &#123;  <span class="comment">//检查set是否包含某个关键值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;yes,Lovelace&quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">computer_scientists.insert(<span class="string">&quot;Gauss&quot;</span>); <span class="comment">//插入一个关键值</span></span><br><span class="line">computer_scientists.erase(<span class="string">&quot;Gauss&quot;</span>); <span class="comment">//删除一个关键值</span></span><br><span class="line"><span class="keyword">auto</span> ada = computer_scientists.find(<span class="string">&quot;Lovelace&quot;</span>); <span class="comment">//找到一个关键值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *ada &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// Lovelace</span></span><br><span class="line">computer_scientists.clear(); <span class="comment">//清空set</span></span><br><span class="line"><span class="keyword">if</span> (computer_scientists.empty()) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;empty set&quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot;\n&quot;</span>;    <span class="comment">// 打印empty set, 此时set 为空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>更多关于set的应用，会在以后的内容中提到。</li></ol><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>首先是array</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt; ages = &#123;<span class="number">18</span>,<span class="number">10</span>,<span class="number">20</span>&#125;; <span class="comment">//array是固定长度的</span></span><br><span class="line"><span class="comment">//介绍3种方法遍历数组</span></span><br><span class="line"><span class="comment">//1.利用数组大小</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ages.size();++i)&#123;  <span class="comment">//因为这里ages.size()的类型是unsigned int</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ages[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.利用array的迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = ages.begin();it!=ages.end();++it)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. const auto&amp;  仅限于C++11以上版本</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; age : ages)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; age&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是vector</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">//vector是不定长的数组</span></span><br><span class="line"><span class="keyword">int</span> input; <span class="comment">//可以自己输入一些数字进入数组</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; input)&#123;</span><br><span class="line">numbers.push_back(input); <span class="comment">//输入数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;1st element: &quot;</span>&lt;&lt; numbers.at(<span class="number">0</span>) &lt;&lt;<span class="string">&quot;\n&quot;</span>;<span class="comment">//1,根据数组的索引来查找</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;1st element: &quot;</span>&lt;&lt; numbers[<span class="number">1</span>] &lt;&lt;<span class="string">&quot;\n&quot;</span>;<span class="comment">//跟上面一样，另一种写法</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max size: &quot;</span> &lt;&lt; numbers.capacity() &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//计算数组的大小</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : numbers) &#123; <span class="comment">//遍历数组</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map被定义为一对数值，key通常是一个字符串，扮演索引的角色，是唯一的，每个key有对应的value(就像字典一样)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; words; <span class="comment">//定义一个map</span></span><br><span class="line"></span><br><span class="line">words[<span class="string">&quot;hello&quot;</span>] = <span class="number">1</span>; <span class="comment">//添加一对数值 (&quot;hello&quot;,1)</span></span><br><span class="line">words.emplace(<span class="string">&quot;cat&quot;</span>, <span class="number">2</span>); <span class="comment">//另一种添加方法</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> tword;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; tword) &#123;     <span class="comment">//向map输入数值，每当输入的key和map中的一样，就在其对应的value上加一</span></span><br><span class="line">words[tword]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = words.begin(); <span class="comment">//map的迭代器</span></span><br><span class="line"><span class="keyword">for</span> (; it != words.end(); ++it) &#123;  <span class="comment">//打印出map中所有的数值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;,value: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>; </span><br><span class="line"><span class="comment">//it -&gt; first 打印每个pair的第一个，也就是key, it-&gt;second打印每个pair的第二个，也就是数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找key</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">it = words.find(<span class="string">&quot;world&quot;</span>); <span class="comment">//find会返回一个迭代器，指向所找到的pair,如果找不着，返回end()</span></span><br><span class="line"><span class="keyword">if</span> (it != words.end()) &#123;</span><br><span class="line">count = it-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><p>迭代器用于检查容器内元素并遍历的一种数据类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; names= &#123;<span class="string">&quot;ada&quot;</span>, <span class="string">&quot;black&quot;</span>, <span class="string">&quot;cindy&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter=names.begin();iter!=names.end();++iter)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *iter&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = names.rbegin(); iter != names.rend(); ++iter) &#123; <span class="comment">//从后往前遍历</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>可以自定义数据类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myclass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">myclass(<span class="keyword">int</span> i) &#123;</span><br><span class="line">i_ = i;  <span class="comment">//class member variables have trailing underscores</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getval</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> i_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> i_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> mc = myclass&#123;<span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mc.getval() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">person()</span><br><span class="line">: name_&#123;<span class="string">&quot;Ming&quot;</span>&#125;</span><br><span class="line">, age_&#123;<span class="number">99</span>&#125; &#123;&#125;</span><br><span class="line">auto get_name() -&gt; std::string const&amp;;</span><br><span class="line">auto get_age() -&gt; int const&amp;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> age_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">auto person::get_name() -&gt; std::string const&amp; &#123;</span><br><span class="line"><span class="keyword">return</span> name_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto person::get_age() -&gt; int const&amp; &#123;</span><br><span class="line"><span class="keyword">return</span> age_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto main() -&gt; int &#123;</span><br><span class="line"><span class="keyword">auto</span> p = person();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p.get_name() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">//Ming</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如定义一个图书信息的类 Sales_item 在Sales_item.h文件里</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_item</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp;, Sales_item&amp;);</span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> Sales_item&amp;);</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Sales_item&amp;, <span class="keyword">const</span> Sales_item&amp;);</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> </span><br><span class="line"><span class="keyword">operator</span>==(<span class="keyword">const</span> Sales_item&amp;, <span class="keyword">const</span> Sales_item&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  </span><br><span class="line">    Sales_item() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_item(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book): bookNo(book) &#123; &#125;</span><br><span class="line">    Sales_item(<span class="built_in">std</span>::istream &amp;is) &#123; is &gt;&gt; *<span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    Sales_item&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Sales_item&amp;);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;       </span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后使用:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Sales_item.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Sales_item book; <span class="comment">//定义一个类book</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; book; <span class="comment">//输入book的信息：书的编号，书的销售量，书的单价</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;book&lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//最后显示书的编号，书的销量，书的总销售额，书的单价</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习算法导论</title>
      <link href="2021/05/27/%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
      <url>2021/05/27/%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“I thought clay must feel happy in the good potter’s hand.”<br>– Janet Fitch</p></blockquote><p>这学期结束后，利用短暂的假期，终于开启了著名的 <em>算法导论</em> 学习之旅。学习的时间比较仓促，由于平常还要实习，所以基本只学习了我认为经典和重要的数据结构和算法，耗时大概20天。</p><p>学习的方法就是书上的定义，例子，伪代码并且用python语言实现（可以在博客里的project里面查看代码），有些伪代码难以理解或者例子过于复杂，会选择更简单堆例子来实现。本书最精华也是最难的数学证明部分（证明算法的合法性，运算时间，所占空间等）我是直接跳过了，因为时间的原因。经典的作品是不能只读一遍的，也许在不久的将来，我会利用闲暇的时间再重读此书。第二次阅读的主要目标是巩固第一遍较难的算法。</p><p>首先总结一下学习的内容：</p><ol><li>排序算法。最为基础和经典的算法。书中给出了大约7中排序算法，选取了其中5种最常见的算法：插入，选择，冒泡，合并，堆排序，快速排序。其中较难理解的是合并以及快速排序。</li><li>分治策略。主要以最大子数组为例，没有太深入学习</li><li>基本数据结构。是本次学习中内容占比最大的。涉及到栈和队列，链表，散列表，二叉搜索树，红黑树。这次学习对这些基本的数据结构的实现有一定的理解，但还达不到手写出来的程度。</li><li>动态规划和贪心算法。在面试题中出现频率非常高的题型，有很强的技巧性，难度也通常比较大。通常涉及到最优子问题。</li><li>图论。广度优先搜索和深度优先搜索是非常重要的算法。kruskal和prim算法实现最小生成树，以及经典最短路径算法dijkstra。</li><li>字符串匹配。KMP算法。</li></ol><p>学习完的感受：<br>对这些基本的算法的原理有了一定的理解，也了解到了算法设计的应用及重要性。对于工作中算法的面试也有很大的帮助。由于在学习的过程中深入度不够，以及在很多问题思考不足就直接搜索思路，目前存在的问题是对于算法的理解没有那么深入，在实操的时候也很容易出错（达不到不借助任何辅助来实现这些算法）。由于目前的首要难关是面试中的算法题，所以接下来就是要多刷题，尽可能利用学到的算法来实现。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统经典进程通信问题</title>
      <link href="2021/02/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E9%97%AE%E9%A2%98/"/>
      <url>2021/02/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Rocks in my path? I keep them all. With them, I shall build my castle.</p></blockquote><h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><img src="/2021/02/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E9%97%AE%E9%A2%98/pic1.png" class><p>如图所示，有五位哲学家，每人有一盘意大利面，每两个盘子之前有一个叉子，要想顺利的吃到意大利面，哲学家必须同时使用两个叉子。哲学家的任务就是吃饭和思考，有没有一种方法能让每个哲学家没有停顿的做这两样事？<br>显然，叉子的数量是不能满足五个哲学家同时吃饭的。Dijkstra给出了解答。<br>先设想这么一种情况，一个哲学家先拿起左手边的叉子，然后检查右手边的叉子是否可用，如果不可用，就放下叉子等待，然后过一段时间再重复这个过程。这种情况在一种情况下是行不通的，那就是当五位哲学家同时拿起左手边的叉子（这里假设所有操作的时间都是一致的，比如每个哲学家等待的时间），这样就会导致他们永远拿不到右边的叉子。这种情况称为<font color="orange"><strong>饥饿状态(starvation)</strong></font>。<br>若把等待时间设定为随机的，在一定程度上可以解决这个问题。但在一些应用中，尤其是安全领域，是不行的。<br>最优的解决方法是要满足2个哲学家可以同时就餐。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N           5         <span class="comment">//number of philosophers</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT        (i+N-1)%N <span class="comment">//number of i&#x27;s left neighbor  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT       (i+1)%N  <span class="comment">//number of i&#x27;s right neighbor</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING     0       <span class="comment">//Philosopher is thinking</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGERY      1       <span class="comment">//Philosopher is trying to get forks</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING       2       <span class="comment">//Philosopher is eating</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;       <span class="comment">//semaphores are a special kind of int</span></span><br><span class="line"><span class="keyword">int</span> state[N];                <span class="comment">//array to keep track of everyone&#x27;s state</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;         <span class="comment">//mutual exclusion for critical regions</span></span><br><span class="line">semaphore s[N];              <span class="comment">//one semaphore per philosopher</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span>  <span class="comment">// i philosopher number from 0 to N-1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;         <span class="comment">//repeat forever</span></span><br><span class="line">think();        <span class="comment">// philosopher is thinking</span></span><br><span class="line">take_forks(i);  <span class="comment">//acquire two forks </span></span><br><span class="line">eat();          <span class="comment">//eating </span></span><br><span class="line">put_forks(i);   <span class="comment">//put both forks down</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_forks</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">down(&amp;mutex);        <span class="comment">//enter critical region </span></span><br><span class="line">state[i] = HUNGERY;   <span class="comment">//record that philosopher i is hungery</span></span><br><span class="line">test(i);             <span class="comment">//try to acquire 2 forks</span></span><br><span class="line">up(&amp;mutex);          <span class="comment">//exit critical region</span></span><br><span class="line">down(&amp;s[i]);         <span class="comment">//block if forks were not acquired</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_forks</span><span class="params">(i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">down(&amp;mutex);        <span class="comment">//enter critical region</span></span><br><span class="line">state[i] = THINKING; <span class="comment">//Philosopher has finished eating</span></span><br><span class="line">test(LEFT);          <span class="comment">//see if left neighbor can now eat.</span></span><br><span class="line">test(RIGHT);         <span class="comment">//see if right neighbor can now eat</span></span><br><span class="line">up(&amp;mutex);          <span class="comment">//exit critical region </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(state[i] == HUNGERY &amp;&amp; state[LEFT]!=EATING &amp;&amp; state[RIGHT]!= EATING)&#123;</span><br><span class="line">state[i] = EATING;</span><br><span class="line">up(&amp;s[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读者-作者问题-reader-and-writer-problem"><a href="#读者-作者问题-reader-and-writer-problem" class="headerlink" title="读者-作者问题(reader and writer problem)"></a>读者-作者问题(reader and writer problem)</h2><p>想象一个订票系统，多个进程会在同时读取数据库，当一个进程写入数据库时，其他的进程就不能读写，那么如何解决这个问题？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;    <span class="comment">//use your imagination</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;        <span class="comment">//controls access to &#x27;rc&#x27;</span></span><br><span class="line">semaphore db=<span class="number">1</span>;           <span class="comment">//controls access to the database</span></span><br><span class="line"><span class="keyword">int</span> rc = <span class="number">0</span>;               <span class="comment">//# of processes reading or wanting to </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">down(&amp;mutex);    <span class="comment">//get exclusive access to &#x27;rc&#x27;</span></span><br><span class="line">rc = rc+<span class="number">1</span>;       <span class="comment">//one reader more now</span></span><br><span class="line"><span class="keyword">if</span> (rc==<span class="number">1</span>) down(&amp;db); <span class="comment">//if this is the first reader.</span></span><br><span class="line">up(&amp;mutex);      <span class="comment">//release exclusive access to &#x27;rc&#x27;</span></span><br><span class="line">read_data_base(); <span class="comment">//access the data</span></span><br><span class="line">down(&amp;mutex);    <span class="comment">//get exclusive access to &#x27;rc&#x27;</span></span><br><span class="line">rc = rc<span class="number">-1</span>;        <span class="comment">//one reader fewer now </span></span><br><span class="line">up(&amp;mutex);       <span class="comment">//release exclusive access to &#x27;rc&#x27;</span></span><br><span class="line">use_data_read();   <span class="comment">//noncritical region</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">think_up_data();   <span class="comment">//noncritical region </span></span><br><span class="line">down(&amp;db);         <span class="comment">//get exclusive access</span></span><br><span class="line">write_data_base(); <span class="comment">//update the data</span></span><br><span class="line">up(&amp;db);           <span class="comment">//release exclusive access.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码给出了解答。当第一个读者进入数据库的时候，对数据库进行down操作，接下来的读者仅仅是增加了counter，直到最后一个读者离开的时候，才up database。这时如果有一个blocked writer，就可以进入。当一个读者在处理数据的时候，其他的读者也可以进入。<br>作者只有当读者全部离开的时候才能进入，如果每隔2秒进来一个读者，且每个读者要花5秒来完成工作，那么作者将永远无法进入。<br>为了防止这个问题，可以将持续进来的读者排在正等待的作者之后，也就是说，当一个读者离开临界区的时候，下一个进来的就是等待中的作者而不是另一个读者。</p><h2 id="睡眠理发师问题"><a href="#睡眠理发师问题" class="headerlink" title="睡眠理发师问题"></a>睡眠理发师问题</h2><p>假设一个理发店里有一个理发师，一个理发座椅还有n个顾客座椅。当没有顾客的时候，理发师在椅子上睡着了。如果一个顾客走进来，他需要唤醒理发师，接下来的顾客看到理发师正在工作，他们要么会在椅子上等待，要么就离开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHAIRS  5    <span class="comment">//#chairs for waiting customers</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore   <span class="comment">//use your imagination</span></span><br><span class="line"></span><br><span class="line">semaphore customers = <span class="number">0</span>;    <span class="comment">//# of customers waiting for service</span></span><br><span class="line">semaphore barber = <span class="number">0</span>;      <span class="comment">//# of barbers waiting for customers</span></span><br><span class="line">semaphore mutex =<span class="number">1</span>;      <span class="comment">//for mutual exclusion</span></span><br><span class="line"><span class="keyword">int</span> waiting = <span class="number">0</span>;       <span class="comment">//customers are waiting</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">barber</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">down（&amp;customers);  <span class="comment">//go to sleep if # of customers is 0</span></span><br><span class="line">down(&amp;mutex);       <span class="comment">//acquire access to waiting</span></span><br><span class="line">waiting = waiting01; <span class="comment">//decrement count of waiting customers</span></span><br><span class="line">up(&amp;barbers);       <span class="comment">//one barber is now ready to cut hair</span></span><br><span class="line">up(&amp;mutex);         <span class="comment">//release &quot;waiting&quot;</span></span><br><span class="line">cut_hair();         <span class="comment">//outside critical region</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">customer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">down(&amp;mutex);        <span class="comment">//enter critical region</span></span><br><span class="line"><span class="keyword">if</span>(waiting &lt; CHAIRS)&#123;   <span class="comment">//if no free chairs ,leave</span></span><br><span class="line">waiting = waiting +<span class="number">1</span>; <span class="comment">//increment count of waiting customers</span></span><br><span class="line">up(&amp;customer);     <span class="comment">//wake up barber.</span></span><br><span class="line">up(&amp;mutex);       <span class="comment">//release access to &quot;waiting&quot;</span></span><br><span class="line">down(&amp;barber);    <span class="comment">//go to sleep if # of free barber is 0</span></span><br><span class="line">get_haircut();    <span class="comment">//be seated and be serviced</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">up(&amp;mutex);      <span class="comment">//shop is full, do not wait </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之IPC3</title>
      <link href="2021/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIPC3/"/>
      <url>2021/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIPC3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Even though the future seems far away, it is actually beginning right now.<br>– Mattie Stepanek</p></blockquote><h2 id="互斥-mutexes"><a href="#互斥-mutexes" class="headerlink" title="互斥(mutexes)"></a>互斥(mutexes)</h2><p>互斥可以理解为简化版的信号量。互斥是一个变量，且有两种状态：锁和解锁(locked and unlocked)。在实际情况中，通常用0来表示解锁，其他的整数都表示锁。<br>当一个进程或者线程需要进入临界区，它会调用 <em>mutex_lock</em>。如果互斥是解锁状态(临界区是可以进入的)，线程就可以随意进入临界区。<br>当互斥已经锁住的情况下，线程会block，直到在临界区里的线程完成并且调用mutex_unlock。如果多个线程都被Block, mutex会随机选择一个进入临界区。<br>互斥可以利用TSL 来实现。代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock:</span><br><span class="line">TSL REGISTER,MUTEX        |copy mutex to register and set mutex to 1</span><br><span class="line">CMP REGISTER,#0           |was mutex 0?</span><br><span class="line">JZE ok                    |if it was 0,mutex was unlocked,so return ok</span><br><span class="line">CALL thread_yield         |mutex is busy, schedule another thread</span><br><span class="line">JMP mutex_lock            |try again later</span><br><span class="line">RET  |return to caller;critical region entered</span><br><span class="line"></span><br><span class="line">mutex_unlock:</span><br><span class="line">MOVE MUTEX,#0             |STORE 0</span><br><span class="line">RET                       |return to caller</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="管程（monitor）"><a href="#管程（monitor）" class="headerlink" title="管程（monitor）"></a>管程（monitor）</h2><p>如果操作不当，互斥会产生死锁（deadlock）。所以这里介绍管程的概念。管程是一个集程序，变量，数据结构的结合体。一个进程可以调用管程里的程序但是不能直接访问在管城外定义的数据结构。下面是管程的伪程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Monitor example:</span><br><span class="line">integer i;</span><br><span class="line">condition c;</span><br><span class="line"></span><br><span class="line">Procedure producer();</span><br><span class="line">.</span><br><span class="line">End</span><br><span class="line"></span><br><span class="line">Procedure consumer();</span><br><span class="line">.</span><br><span class="line">End</span><br><span class="line">End monitor;</span><br></pre></td></tr></table></figure><p>在管程中，任何时刻只能有一个进程运行。比如当一个进程调用管程的程序，这个程序会首先检查在管程内是否有其他运行的程序。如果有，进程会被悬挂直到其他进程离开；如果没有，进程可以直接进入。<br>如果缓存(buffer)已经满了，那么producer该如何操作？这里就要引入条件变量（condition variables）的概念，还有两种操作，<em>wait and signal</em>。当管程程序发现不能继续的时候，它就会在条件变量上做wait操作，比如把条件变量变成full。这个操作可以使准备调用的进程block并且会让之前等待的进程进入。<br>同样的，consumer会实行signal操作。为了不让两个进程同时在管程里运行，在signal操作之后就要结束管程。也就是，wait一定实在signal之前的。<br>Wait,signal和sleep,wakeup的区别是：一个进程可能会被同时sleep和wakeup，但wait,signal不会。<br>Java语言可以很好的利用管程解决生产者-消费者的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">100</span>;    <span class="comment">//constant giving the buffer size</span></span><br><span class="line"><span class="keyword">static</span> producer p = <span class="keyword">new</span> producer();   <span class="comment">//instantiate a new producer thread</span></span><br><span class="line"><span class="keyword">static</span> consumer c = <span class="keyword">new</span> consumer();   <span class="comment">//instantiate a new consumer thread</span></span><br><span class="line"><span class="keyword">static</span> our_monitor mon = <span class="keyword">new</span> our_monitor();  <span class="comment">// a new monitor</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">p.start();  <span class="comment">//start the producer thread</span></span><br><span class="line">c.statr();  <span class="comment">// start the consumer thread</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  <span class="comment">//run method contains the thread code.</span></span><br><span class="line"><span class="keyword">int</span> item;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123; <span class="comment">//producer loop</span></span><br><span class="line">item=produce_item();</span><br><span class="line">mon.insert(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">produce_item</span><span class="params">()</span> </span>&#123;...&#125; <span class="comment">// actually produce</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  <span class="comment">//run method contains the thread code.</span></span><br><span class="line"><span class="keyword">int</span> item;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123; <span class="comment">//consumer loop</span></span><br><span class="line">item=mon.remove();</span><br><span class="line">consume_item;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume_item</span><span class="params">()</span> </span>&#123;...&#125; <span class="comment">// actually consume</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">our_monitor</span></span>&#123; <span class="comment">// this is a monitor </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> buffer[] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>,lo=<span class="number">0</span>,hi=<span class="number">0</span>; <span class="comment">//counters and indices</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(count==N) go_to_sleep(); <span class="comment">//if the buffer is full,go to sleep</span></span><br><span class="line">buffer[hi] = val;          <span class="comment">//insert an item into the buffer</span></span><br><span class="line">hi = (hi+<span class="number">1</span>)%N;             <span class="comment">//slot to place net item in.</span></span><br><span class="line">count = count + <span class="number">1</span>;         <span class="comment">// one more item in the buffer now</span></span><br><span class="line"><span class="keyword">if</span>(count ==<span class="number">1</span>) notify();    <span class="comment">// if consumer was sleeping, wake it up</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">if</span>(count==<span class="number">0</span>) go_to_sleep();  <span class="comment">//if the buffer is empty,go to sleep </span></span><br><span class="line">val = buffer[lo];      <span class="comment">//fetch an item from the buffer</span></span><br><span class="line">lo =(lo+<span class="number">1</span>) % N;        <span class="comment">//slot to fetch next item from </span></span><br><span class="line">count = count -<span class="number">1</span>;     <span class="comment">//one few items in the buffer</span></span><br><span class="line"><span class="keyword">if</span>(count == N-<span class="number">1</span>) notify(); <span class="comment">//if producer was sleeping ,wake it up.</span></span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">go_to_sleep</span><span class="params">()</span> </span>&#123;<span class="keyword">try</span> &#123;wait();&#125; carcg（InterruptedException exc)&#123;&#125;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法之排序1</title>
      <link href="2021/02/08/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F1/"/>
      <url>2021/02/08/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>I’ll be back.</p></blockquote><h2 id="冒泡排序法"><a href="#冒泡排序法" class="headerlink" title="冒泡排序法"></a>冒泡排序法</h2><p>冒泡排序法从第一个元素开始比较，比较相邻元素的大小，若大小顺序有误，则对调后再进行下一个元素的比较。扫描一遍后就可以确保最后一个元素处于正确的顺序，接着进行第二次扫描，直到所有的元素的排序完成为止。</p><p>以数列[55,23,87,62,16]为例</p><ol><li>第一次扫描会比较4组数据<ul><li>23 55 87 62 16</li><li>23 55 87 62 16</li><li>23 55 62 87 16</li><li>23 55 62 16 87</li></ul></li><li>第二次扫描比较3组数据(87的位置以及确定):<ul><li>23 55 62 16 87</li><li>23 55 62 16 87</li><li>23 55 16 62 87</li></ul></li><li>第三次比较2组数据:<ul><li>23 55 16 62 87</li><li>23 16 55 62 87</li></ul></li><li>第四次比较1组数据:<ul><li>16 23 55 62 87</li></ul></li></ol><p>实现代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,tmp;</span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">5</span>] = &#123;<span class="number">55</span>,<span class="number">23</span>,<span class="number">87</span>,<span class="number">62</span>,<span class="number">16</span>&#125;; <span class="comment">//原始数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;冒泡排序法:\n原始数据为: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">4</span>;i&gt;<span class="number">0</span>;i--)&#123;     <span class="comment">//扫描4次</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;i;j++)&#123;  <span class="comment">//每次扫描的比较次数</span></span><br><span class="line">            <span class="keyword">if</span>(data[j]&gt;data[j+<span class="number">1</span>])&#123;   <span class="comment">//交换</span></span><br><span class="line">                tmp = data[j];</span><br><span class="line">                data[j] = data[j+<span class="number">1</span>];</span><br><span class="line">                data[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第 %d 次的排序结果是: &quot;</span>,<span class="number">5</span>-i);</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,data[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序法:</span><br><span class="line">原始数据为:  55 23 87 62 16</span><br><span class="line">第 1 次的排序结果是:  23 55 62 16 87</span><br><span class="line">第 2 次的排序结果是:  23 55 16 62 87</span><br><span class="line">第 3 次的排序结果是:  23 16 55 62 87</span><br><span class="line">第 4 次的排序结果是:  16 23 55 62 87</span><br></pre></td></tr></table></figure><h2 id="选择排序-selection-sort"><a href="#选择排序-selection-sort" class="headerlink" title="选择排序(selection sort)"></a>选择排序(selection sort)</h2><p>选择排序的算法就是反复从未排序的数列中取出最小的元素，加入到另一个数组。如果是从小到大排，最小的就放在第一个位置，如果从大到小，就放在最后一个。<br>依然以[55,23,87,62,16] 为例：</p><ol><li>第一次扫描，发现最小的值为16，把16和第一个数交换:<ul><li>16 55 23 87 62 </li></ul></li><li>第二次扫描，从第二个数开始，发现最小的值为23，把23和第二个数交换:<ul><li>16 23 87 62 55</li></ul></li><li>第三次扫描，从第三个数开始，发现最小的值为55，把55和第三个交换:<ul><li>16 23 55 62 87</li></ul></li><li>第四次扫描，从第三个数开始，发现最小的值为62，把62和第四个数交换(不变):<ul><li>16 23 55 62 87</li></ul></li></ol><p>用C语言实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showdata</span><span class="params">(<span class="keyword">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">5</span>] = &#123;<span class="number">55</span>,<span class="number">23</span>,<span class="number">87</span>,<span class="number">62</span>,<span class="number">16</span>&#125;; <span class="comment">//原始数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;选择排序法:\n原始数据为: &quot;</span>);</span><br><span class="line">    showdata(data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序过程: \n&quot;</span>);</span><br><span class="line">    select(data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最终排序结果: &quot;</span>);</span><br><span class="line">    showdata(data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showdata</span><span class="params">(<span class="keyword">int</span> data[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> data[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,tmp;</span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;    <span class="comment">//扫描4次</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;<span class="number">5</span>;j++)&#123;   <span class="comment">//从i+1开始比较</span></span><br><span class="line">            <span class="keyword">if</span>(data[i]&gt;data[j])&#123;</span><br><span class="line">                tmp = data[i];</span><br><span class="line">                data[i] = data[j];</span><br><span class="line">                data[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        showdata(data);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">选择排序法:</span><br><span class="line">原始数据为:  55 23 87 62 16</span><br><span class="line">排序过程: </span><br><span class="line"> 16 55 87 62 23</span><br><span class="line"> 16 23 87 62 55</span><br><span class="line"> 16 23 55 87 62</span><br><span class="line"> 16 23 55 62 87</span><br><span class="line">最终排序结果:  16 23 55 62 87</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法之递归</title>
      <link href="2021/02/08/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92/"/>
      <url>2021/02/08/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<blockquote><p>The good thing about computers is that they do what you tell them to do. The bad news is that they do what you tell them to do.<br>– Ted Nelson</p></blockquote><p>该系列的学习笔记是关于主要的数据结构和算法,使用的编程语言为C语言。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>如果一个函数或子程序是由自身定义或调用的，就称为<font color="orange"><strong>递归(recursion)</strong></font>。它至少要定义两个条件:</p><ol><li>一个可以反复执行的递归过程</li><li>一个跳出执行的出口。</li></ol><p>以常见的阶乘函数为例，n!=nx(n-1)x(n-2)x…1</p><p>下面把5！运算过程拆开：<br>5!=(5x4!)<br>  &nbsp;&nbsp;=5x(4x3!)<br>  &nbsp;&nbsp;=5x4x(3x2!)<br>  &nbsp;&nbsp;=5x4x3x(2x1)<br>  &nbsp;&nbsp;=5x4x3x2<br>  &nbsp;&nbsp;=5x4x6<br>  &nbsp;&nbsp;=5x24<br>  &nbsp;&nbsp;=120</p><p>用代码表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)     <span class="comment">//递归终止的条件，跳出递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        res = n*factorial(n<span class="number">-1</span>); <span class="comment">//反复执行递归过程</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个经典的递归例子，就是斐波那契数列(Fibonacci polynomial), 就是0,1,1,2,3,5,8… 当前的数字是前两个数字的和。</p><p>如果我们想要通过程序来求第n项的数字:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)          <span class="comment">//第一项永远为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">1</span> || n==<span class="number">2</span>)  <span class="comment">//第二项和第三项也永远为1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>)); <span class="comment">//否则返回前两项之和ss</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之IPC2</title>
      <link href="2021/02/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIPC2/"/>
      <url>2021/02/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIPC2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>If it weren’t for electricity, we’d all be watching television by candlelight.<br>– George Gobel</p></blockquote><h2 id="休眠和唤醒"><a href="#休眠和唤醒" class="headerlink" title="休眠和唤醒"></a>休眠和唤醒</h2><p>前文介绍的互斥方法，peterson或是TSL，的缺点就是会大量两份CPU的时间，而且还会引发一些问题。比如，一个高优先级的进程H，和一个低优先级的进程L, 根据调度规则，高优先级的任务只要在ready的状态就需要运行，假设这时L在临界区内，H需要运行，这时候H就进入了busy waiting(一直在等机会进入临界区)。但是因为L优先级较低，在H运行的时候不会被调度，所以也就不会离开临界区，H就进入了无限循环。这种情况被称为<strong>优先级反转问题</strong>(priority inversion problem)。</p><p>采用Block能解决这个问题。Sleep和wakeup就是一个例子。Sleep 是一个系统调用，它开业使一个进程悬挂起来，直到另一个进程唤醒它。Wakeup可以唤醒一个进程。Sleep和wakeup各有一个参数，那就是用来互相关联的内存地址。</p><h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p>假设有两个进程共享一个固定大小的缓存区(buffer)。其中一个，我们可以称其为生产者，把信息存入缓存里，另一个，称其为消费者，把信息取出。<br>问题是如果缓存已经存满了，生产者就不能继续往里存储信息。所以这时候生产者进入sleep状态，等消费者从缓存中取出信息。相反，如果缓存是空的，消费者就要进入sleep。<br>我们需要一个计数器,count，来记录缓冲里信息的数量。如果一个缓存只能存储N个信息，那么生产者就要首先检查count是否为N，如果是的，就进入sleep。如果不是，加入信息，并且 coun++。<br>同样的，对于消费者，就是检查count是否为0,如果是0,就进入sleep。如果不是，就取出，并且count–。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100    <span class="comment">//number of slots in the buffer</span></span></span><br><span class="line"><span class="meta">#int count = 0<span class="comment">//number of items in the buffer</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">item = produce_item();   <span class="comment">//generate next item</span></span><br><span class="line"><span class="keyword">if</span> (count == N) sleep();</span><br><span class="line">insert_item(item);</span><br><span class="line">count = count+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">1</span>) wakeup(consumer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) sleep();</span><br><span class="line">item = remove_item();</span><br><span class="line">count = count01;</span><br><span class="line"><span class="keyword">if</span> (count == N<span class="number">-1</span>) wakeup(producer);</span><br><span class="line">consume_item(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码可以大概表达出生产者和消费者的运行流程。但是这个代码是有可能产生竞争的，因为count可以无限制访问(by producer and consumer)。最后会导致两者都进入永远的sleep。<br>引起这个原因的根本是wakeup signal的丢失(因为wakeup发给了并没有进入sleep的进程)。解决办法是加入一个 <font color="orange"><strong>wakeup waiting bit</strong></font>。当wakeup信号发送给一个已经唤醒的进程，这个bit就被设定。如果这个进程要进入sleep，如果waiting bit 是设定了的，那么就会被关闭，进程继续保持唤醒。Wakeup waiting bit 就类似于wakeup信号的存钱罐。</p><h2 id="信号量-semaphores"><a href="#信号量-semaphores" class="headerlink" title="信号量(semaphores)"></a>信号量(semaphores)</h2><p>信号量是用来记录wakeup数量的一个变量。如果信号量为0，就代表没有一个wakeup被存储，或者是一个正数，代表着有一个或多个wakeup被保存。<br>Dijkstra （提出著名最短路径算法的科学家）把信号量分成两个操作，down和up（分别代表sleep和wakeup）。Down操作检查信号量的值是否大于0，如果是的话，就减一(确保只有一个wakeup储存)。如果值为0的话，进程就会sleep。<br>检查数值，改变数值，或是进入sleep，所有的操作被看作一个整体且不能分开操作，就被称为<font color="orange"><strong>原子操作(atomic action)</strong></font>。这确保了在一个信号量执行的时候，另一个进程不会进入信号量。原子化在同步问题和避免条件竞争都非常重要。<br>Up操作给信号量的值增加。如果在这个信号量中，有一个或多个进程正在sleeping，且不能完成down操作，其中的一个进程就会被系统随机选择进行down操作。因此，当有sleeping进程的信号量实行up操作之后，信号量依然为0，但是会少一个正在sleeping的进程。这个过程同样也是原子操作。</p><h2 id="用信号量解决生产者-消费者问题"><a href="#用信号量解决生产者-消费者问题" class="headerlink" title="用信号量解决生产者-消费者问题"></a>用信号量解决生产者-消费者问题</h2><p>信号量可以解决wakeup丢失的问题。如下面的代码所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100    <span class="comment">//number of slots in buffer</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;      <span class="comment">//semaphores are a special kind of int</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//control access to critical region</span></span><br><span class="line">semaphore empty = N;<span class="comment">//counts empty buffer slot </span></span><br><span class="line">semaphore full = <span class="number">0</span>;<span class="comment">//counts full buffer slots</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">item = produce_item();    <span class="comment">//generate something to put in buffer</span></span><br><span class="line">down(&amp;empty);  <span class="comment">//decrement empty count</span></span><br><span class="line">down(&amp;mutex);  <span class="comment">//enter critical region</span></span><br><span class="line">insert_item(item);   <span class="comment">//put new item in buffer</span></span><br><span class="line">up(&amp;mutex);  <span class="comment">//leave critical region </span></span><br><span class="line">up(&amp;full);  <span class="comment">//increment count of full slots </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">down(&amp;full);  <span class="comment">//decrement full count</span></span><br><span class="line">down(&amp;mutex);  <span class="comment">//enter critical region</span></span><br><span class="line">item = remove_item(item);   <span class="comment">//remoev item from buffer</span></span><br><span class="line">up(&amp;mutex);  <span class="comment">//leave critical region </span></span><br><span class="line">up(&amp;empty);  <span class="comment">//increment count of empty slots </span></span><br><span class="line">consume_item(item);  <span class="comment">// do something with item.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="powderblue"><strong>互斥的实现是在同一个进程中进行的一对PV操作。<br><br>同步的实现是在两个进程中进行的，在一个进程中执行P操作，在另一个进程中执行V操作。（down和up也可以用P和V来表示)。</strong></font></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言4</title>
      <link href="2021/02/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804/"/>
      <url>2021/02/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804/</url>
      
        <content type="html"><![CDATA[<blockquote><p>There are three things extremely hard: steel, a diamond, and to know one’s self.<br>– Benjamin Franklin</p></blockquote><h2 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h2><ul><li><p>段的划分来自CPU。</p><img src="/2021/02/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804/pic1.png" class><p>如上图，可以认为该段的起始地址(基础地址)为10000H，段地址为1000H(因为基础地址=段地址x16,在十六进制中向右偏移1位相当于x16)。大小为100H。<br>也可以认为地址10000H - 1007FH，10080H-100FFH的内存单元组成两个段，起始地址(基础地址)为:10000H,10080H,段地址为，1000H，1008H，大小都为80F。</p></li><li><p>用段地址x16定位段段起始地址(基础地址),用偏移地址定位段中的内存单元。有2点需要注意</p><ol><li>起始地址必然是16的倍数</li><li>偏移地址为16位，16位的寻址能力为64KB,所以一个段的长度最大为64KB</li></ol></li></ul><p><font color="powderblue"><strong>(1)CPU可以用不同的段地址和偏移地址形成一个物理地址。<br><br>    SAx16+EA = PA<br><br>    对于8086CPU地址的描述有两种方法:<br><br>    1. 数据存在2000:1F60单元中<br><br>    2. 数据存在内存的2000H段中的1F60H单元中<br><br>    这两种都表示数据在内存21F60H中</strong></font></p><p><font color="powderblue"><strong>(2)如果给定一个段地址，仅通过变化偏移地址来寻址，最多可以定位多少个内存单元？<br><br>偏移地址16位，变化范围为 0-FFFFH，仅用偏移地址最多可以寻64KB个内存单元。</strong><br></font></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ol><li>给定段地址0001H，仅通过偏移地址寻址,CPU的寻址范围为 0010H 到 1000FH<br><font color="orange">解释: 因为偏移地址的范围为0-FFFFH，SAx16为0010H，所以寻址的范围为 0010+0 - 0010+ffff = 0010H - 100FH。</font></li><li>有一数据存放在内存20000H单元中，现给定段地址为SA，若想用偏移地址寻址此单元。SA的范围应是: 1001H - 2000H<br><font color="orange">解释: 由上面的公示可以计算SA。<br><br> SA = (20000H- EA)/16<br><br> SA = 2000H - EA/16<br><br> 最小SA = 2000H - FFFFH/16 = 1001H<br><br> 最大SA = 2000H - 0 / 16 = 2000H</font></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之IPC1</title>
      <link href="2021/02/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIPC1/"/>
      <url>2021/02/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIPC1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Astronomy’s much more fun when you’re not an astronomer.<br>– Brian May</p></blockquote><h2 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h2><p><font color="orange"><strong>进程通信</strong>(interprocess communication)</font>是一种不需要中断的进程之间的交流。可以简称为IPC。关于这个交流，有三个问题是需要我们事先考虑的：</p><ol><li> 一个进程如何向另一个进程传递信息</li><li>   多个线程之间如何做到不互相干扰</li><li>   在交流中如何保证合适的时序性</li></ol><p>线程同样会面临这三个问题，只不过难度不一样。比如线程传递信息更容易因为线程享有相同的地址空间。</p><h2 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h2><p>在很多操作系统中，进程之间会有一个共享的存储空间，这个空间一般在主存里或者其他文件里。举一个例子来说明进程之间是怎样交流的：后台打印程序(print spooler)。当一个进程想要打印一个文件，它会进入一个由后台文件夹下的文件。另一个进程，打印机后台程序，定期检查是否有需要打印的文件，如果有，那就打印，然后把文件的名字从后台文件夹下移除。<br>假设后台文件夹有很多 0，1，2… 每一个文件都可以保存一个文件名。同时有2个共享的变量，一个是out,指向下一个需要打印的文件，一个是in，指向下一个可执行的文件夹(编号)。这两个变量保证了每个文件都至少包含了2个字（WORD）。这时，进程A和进程B都想把一个文件加入打印列队。这个过程如下图所示:</p><img src="/2021/02/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIPC1/pic1.png" class><p>这样就会出现一种情况：进程A读取in并储存7，在一个名为next_free_slot的本地变量中。就在这时，时钟中断出现了因为CPU任务进程A运行太长时间了，要切换成进程B。进程B也读取了in，也就是7, 然后也把7储存到了next_free_slot。这时，两个进程都认为下一个可执行的文件是7号。<br>进程B继续运行，并把文件名字存进文件夹7然后把in升级为8。<br>然后进程A重新运行，从它停止的那一步开始，所以它会把文件名写入7号文件夹，这样就把进程B的文件替换掉了。然后把in升级为8。所以进程B的文件永远不会被打印。<br>对于这种情况，多个进程读写共享的数据而且结果由进程运行的时刻所影响，就叫做<font color="orange"><strong>条件竞争</strong>(race conditions)</font>。</p><h2 id="临界区-critical-regions"><a href="#临界区-critical-regions" class="headerlink" title="临界区(critical regions)"></a>临界区(critical regions)</h2><p>如何避免条件竞争？我们需要引入互斥(mutual exclusion)这种方法，也就是当一个进程在使用共享变量或者文件时，其他的进程就不能做同样的事。这种方法的难点就在于当进程B使用共享变量的时候，进程A还没有完成。<br>一个共享空间的程序被称为<font color="orange"><strong>临界区</strong></font>。如果可以保证两个进程不同时出现在临界区，就可以避免条件竞争.<br>如果想要并行进程更有效率的话，还需要满足4个条件：</p><ol><li> 两个进程不同时出现在临界区里</li><li>   对CPU的速度和数量没有要求</li><li>   在临界区外运行的进程不应该block其他的进程</li><li>   每一个进程都可以进入临界区</li></ol><p>下图展示了在临界区产生的互斥:</p><img src="/2021/02/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIPC1/pic2.png" class><h2 id="忙碌等待中的互斥"><a href="#忙碌等待中的互斥" class="headerlink" title="忙碌等待中的互斥"></a>忙碌等待中的互斥</h2><p>下面详细介绍实现互斥的几种方案：</p><ul><li><p><font color="orange"><strong>去使能中断(disable interrupt)</strong></font><br>一个最简单的互斥方法就是在进入临界区后disable每个进程的中断，然后它们离开的时候重新使能(re-enable)。因为CPU只能通过中断(时钟或其他)来从一个进程转到另一个进程，所以关闭中断就保证了CPU不能转换进程。<br>这种方法的问题在于把中断关闭后，如果不把中断再打开就会引发系统的终结。还有一种情况是在多核处理器的情况下，中断能影响到一个CPU。总结下来就是，去使能中断对于操作系统本身很有用，但是对于用户进程就不适合</p></li><li><p><font color="orange"><strong>锁变量(lock variables)</strong></font><br>假如有一个共享(锁)变量，一开始是0。当一个进程想进入临界区之前，要检查这个锁变量。如果锁是0，进程就把它设置为1然后进入临界区，如果锁以及是1了，那就等待锁变为0。0代表着临界区没有进程，1代表了临界区里有进程。<br>这种方法的问题在于如果一个进程在把锁设置为1之前，另一个进程突然进入然后把锁设置为1，这样两个进程都会进入。这是因为在进程2把锁设置为1时，进程1已经检查过了锁(判断为0),所以竞争已经发生。</p></li><li><p><font color="orange"><strong>严格变更(strict alternation)</strong></font><br>下面的两部分代码展示这种方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(True)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">0</span>)</span><br><span class="line">Critical_region();</span><br><span class="line">Turn = <span class="number">1</span>;</span><br><span class="line">Noncritical_region();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="powderblue">process0</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(True)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">1</span>)</span><br><span class="line">Critical_region();</span><br><span class="line">Turn = <span class="number">0</span>;</span><br><span class="line">Noncritical_region();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><font color="powderblue">process1</font><br>Turn 的初始值是0。Process0 检查turn，发现turn是0，所以进入<em>critical_region</em>（不进入while）。Process1检查turn,也发现是0，所以进入循环(因为turn != 1)检查什么时候turn变为1。这种用循环检查值的方法被称为busy waiting,这种方法通常会浪费CPU时间，所以在短时间等待的情况下比较适用。一个用busy waiting的锁被称为<font color="orange"><strong>spin lock（旋转锁）</strong></font>。<br>当process0离开临界区的时候，会把turn设为1来让process1进入临界区，当process1完成任务的时候，就会把turn设为0，并离开临界区。然后process0再次进入循环，设turn为1…<br>如果这时，process0想进入临界区，但process1在临界区外，也就是说turn还是1，所以process0进入不了临界区，只能进入while循环。所以这种方法对于运行速度差异较大的是不适用的。而且违法了上文所提到的第三个条件:process0被临界区之外的进程block。<br>所以这种方法严格要求了两个进程的替换顺序，尽管它能够避免了竞争，但也不是一个很好的解决方法，因为违法了第三个条件。</p></li><li><p><font color="orange"><strong>Peterson’s solution</strong></font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N   2 <span class="comment">/*number of processes*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> turn;</span><br><span class="line"><span class="keyword">int</span> interested[N];  <span class="comment">// all values initially 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter_region</span><span class="params">(<span class="keyword">int</span> process)</span>    <span class="comment">// 1 or 0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> other；                    <span class="comment">//number of other process</span></span><br><span class="line"></span><br><span class="line">other = <span class="number">1</span>-process;  <span class="comment">// the opposite of process</span></span><br><span class="line">interested[process] = TRUE;  <span class="comment">// show that you are interested.</span></span><br><span class="line">turn = process; <span class="comment">//set flag</span></span><br><span class="line"><span class="keyword">while</span> (turn == process &amp;&amp; interested[other] == TRUE)<span class="comment">//null statement</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leave_region</span><span class="params">(<span class="keyword">int</span> process)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">interested[process] = FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><font color="orange"><strong>TSL 指令</strong></font><br>这个方法是需要借助硬件来实现的，一般的计算机都会有指令<br><code>TSL RX,LOCK</code><br>Test and set lock。这个指令把lock的内存放入寄存器RX然后存储一个非零数在lock的内存地址。这个指令保证了在它执行完成之前，其他的处理器都不能进入。<br>下面的汇编代码给出了详细解答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">TSL REGISTER,LOCK              |copy lock to register and set lock to 1</span><br><span class="line">CMP REGISTER,#0       |was lock 0?</span><br><span class="line">JNE enter_region       |if it was non zero, lock was set so loop</span><br><span class="line">RET           |return to caller;critical region entered</span><br><span class="line"></span><br><span class="line">leave_region:</span><br><span class="line">MOVE LOCK,#0       |store 0 in lock </span><br><span class="line">RET       </span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之线程2</title>
      <link href="2021/02/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B2/"/>
      <url>2021/02/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>The Lord made us all out of iron. Then he turns up the heat to forge some of us into steel.<br>– Marie Osmond</p></blockquote><h2 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h2><p>线程表存放在内核中，当一个线程想要创建新的线程或者删除已有的线程，需要从内核中调用。相比于用户层，线程在内核中更容易实现Block，当一个线程进入Block状态，内核有两个选择，一是让同一进程的另一线程来运行，二是让其他进程的线程来运行。<br>内核线程不需要任何新的，非block的系统调用。当一个线程遇到了page fault，内核可以很容易的检查到进程内是否还有其他可运行的线程。这种方法的缺点是系统调用的成本会非常大。</p><h2 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h2><p>把以上两种实现混合起来，就可以结合各自的优点。如图所示，在这种情况下，每一个内核线程上都会有一组用户空间线程。</p><img src="/2021/02/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B2/pic1.png" class><h2 id="调度器激活机制"><a href="#调度器激活机制" class="headerlink" title="调度器激活机制"></a>调度器激活机制</h2><p>用户线程的优点是高性能，内核线程的优点是操作简洁。<font color="orange"><strong>调度器激活</strong>(scheduler activations)</font>很好的把这两种优点结合在一起。<br>调度激活器的主要目的是减少内核线程的工作流程并在同时保证高性能。提高效率的办法就是减少用户和内核中不必要的交互。<br>这种机制就是当调度器激活启动的时候，内核会给每一个进程指定一个虚拟的处理器然后通过用户系统给这些处理器分配线程。同样的，这个机制也可以用于多进程(multiprocessor)，只不过这里的虚拟处理器是真正的CPU。<br>工作原理是当内核知道线程Blocked(通过运行blocking调用或者出现page fault)。内核会通知用户层关于线程的状态，这种通知是通过内核在一个设定好的地址上激活用户层，这种机制称为upcall。<br>在激活后，用户系统会重新安排线程，通常是block现行的线程然后把其他的线程安排到ready list里，初始化它的寄存器然后重启。</p><h2 id="总结-进程和线程的区别"><a href="#总结-进程和线程的区别" class="headerlink" title="总结:进程和线程的区别"></a>总结:进程和线程的区别</h2><font color="orange">1. 线程可以被理解为轻量级的进程<br>2. 进程把所有资源整合在一起，线程是一个个被CPU调度的条目<br>3. 线程有相同的地址空间，它们共享全局变量，打开文件，信号等。<br>...待补充</font>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言3</title>
      <link href="2021/02/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%803/"/>
      <url>2021/02/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%803/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Set your course by the stars, not by the lights of every passing ship.<br>-Omar Bradley</p></blockquote><h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>每一个内存单元在空间中都有唯一的地址，这个唯一的地址就是物理地址</p><h2 id="16位结构的CPU"><a href="#16位结构的CPU" class="headerlink" title="16位结构的CPU"></a>16位结构的CPU</h2><p>CPU特性:</p><ul><li>运算器一次最多可以处理16位的数据</li><li>寄存器的最大宽度为16位</li><li>寄存器和运算器之间的通路为16位</li></ul><h2 id="8086CPU给出物理地址的方法"><a href="#8086CPU给出物理地址的方法" class="headerlink" title="8086CPU给出物理地址的方法"></a>8086CPU给出物理地址的方法</h2><p>8086CPU有20位地址总线，可以传送20位地址，达到1MB的寻址能力。但CPU又是16位结构，在内部一次性处理，传输，暂时存储的地址为16位。<br>所以CPU采用在内部内使用两个16位地址合成方法来形成一个20位的物理地址。CPU的逻辑结构如图所示</p><img src="/2021/02/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%803/pic1.png" class><ol><li>相关部件提供2个16位地址，一个叫段地址，一个叫偏移地址</li><li>段地址和偏移地址通过内部总线送入一个称为地址加法器的部件</li><li>地址加法器将2个16位的地址合成一个20为的物理地址</li><li>通过内部总线将20位物理地址送入输入输出控制电路</li><li>输入输出控制电路将20位物理地址送上地址总线</li><li>20位物理地址被地址总线传送到存储器</li></ol><p><strong>物理地址 = 段地址x16+偏移地址</strong><br>如果CPU要访问地址为123C8H的内存单元，那么过程如下图所示：</p><img src="/2021/02/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%803/pic2.png" class><h2 id="“物理地址-段地址x16-偏移地址”-的本质意义"><a href="#“物理地址-段地址x16-偏移地址”-的本质意义" class="headerlink" title="“物理地址 = 段地址x16+偏移地址” 的本质意义"></a>“物理地址 = 段地址x16+偏移地址” 的本质意义</h2><p>CPU在访问内存时，用一个基础的地址(段地址x16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。</p><p>以2个和CPU无关的例子来说明:<br>第一个比喻说明”基础地址+偏移地址=物理地址”的思想:<br>学校，体育馆和图书馆在一条路上</p><img src="/2021/02/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%803/pic3.png" class><p>有两种方式描述图书馆的地址:</p><ol><li>从学校走2826m到图书馆。这2826m可以认为是图书馆的物理地址</li><li>从学校走2000m到体育馆，从体育馆再走826m到图书馆。第一个2000m相当于是基础地址，第二个826m是相对于基础地址的偏移地址。</li></ol><p>第二个比喻说明了”段地址x16+偏移地址=物理地址”:</p><p>如果只能通过纸条来互相通信，且一张纸条只能写3个数字，所以我不能写下2826这个数字，所以只能用2个纸条，一个写200,一个写826。然后根据我们事先的约定，得到纸条后做这样的运算: 200(段地址)x10+826(偏移地址) = 2826(物理地址)</p><p>8086CPU就是这样只能提供2张3位数据纸条的CPU。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之线程1</title>
      <link href="2021/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B1/"/>
      <url>2021/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>We are all apprentices in a craft where no one ever becomes a master.<br>– Ernest Hemingway</p></blockquote><h2 id="线程介绍"><a href="#线程介绍" class="headerlink" title="线程介绍"></a>线程介绍</h2><p><font color="orange"><strong>线程</strong>(thread)</font>和<font color="orange"><strong>进程</strong>(process)</font>非常相似，但确是完全不同的概念。和进程一样，线程有它的程序计数器，用来追踪下一个指令是什么。线程有寄存器，用来保存正在工作的变量。它有一个堆栈，用来记录运行历史。进程是把所有的资源整合在一起，线程是一个个被调度的条目，等待CPU的处理。<br>多个线程可以共同的运行在一个进程里，这就好比多个进程可以共同运行在一台计算机里。线程可以共享地址空间，打开文件或者其他资源。进程可以共享物理上的内存，硬盘，打印机等。所以线程有时会被理解为<font color="orange"><strong>轻量级进程</strong>(lightweight processes)</font>。<font color="orange"><strong>多线程</strong>(multithreading)</font>是指多个线程在同一个进程里运行。进程和线程的关系如下图：</p><img src="/2021/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B1/pic1.png" class><p>不同于进程的是，线程有相同的地址空间，这也就意味着它们共享相同的全局变量。</p><img src="/2021/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B1/pic2.png" class><p>上图说明了，process items是进程的属性，所以对于thread是共享的而不是独有的。所以第一张图的a是当三个进程完全不相关的，图b是三个线程都是同一个任务的一部分。</p><p>和进程一样，线程也有几种状态:<u>running, blocked,ready or terminated</u>。<br>每个线程都有自己的堆栈(stack)，如图所示</p><img src="/2021/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B1/pic3.png" class><p>每个堆栈包含了以及调用而还没有返回的程序，堆栈里包括了程序的本地变量以及返回时需要的地址。每个线程都会调用不同的程序，也就产生了不同的运行历史。<br>在一个进程里，多线程任务通常都是由单线程开始的。这个单线程可以通过调用库程序(Library procedure), <em>thread_create</em>。因为所有的线程都是相同的，所以不像进程那样有层次之分。<br>当线程完成任务时，会通过调用库程序，<em>thread_exit</em>来结束。<br><em>Thread_yield</em>也是一个重要的程序。这个调用可以让线程自愿放弃CPU使用，来让位给其他线程。</p><h2 id="线程的应用"><a href="#线程的应用" class="headerlink" title="线程的应用"></a>线程的应用</h2><p>我们为什么要用线程，而不是只用进程来处理任务呢？线程相比于进程主要有4点优势：</p><ol><li> 线程的并行能力(parallel ability)更强，因为它们享有共同的地址空间和数据。</li><li>   更容易建立和删除。因为不像进程那样有很多资源附着在上面</li><li>   当有大量的计算或者I/O设备时，线程速度更快因为线程允许这些任务相互覆盖</li><li>   对于多核系统，线程可以实现真正的并行。</li></ol><p>举一个实际的例子，一款文字处理软件通常由三个线程协作完成:它们分别用来交互，整理和保存。比如当用户在第一页删除了一行后，用来交互的线程就会告诉整理线程来重新编排整个文档，这时候交互的线程就可以做其他的操作了。很多文件处理软件运用了保存线程，会每隔一段时间自动保存来防止内容丢失。</p><img src="/2021/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B1/pic4.png" class><p>Web 的服务器也通常使用线程。在一个网站里，一个页面的浏览量通常会大于另一个页面(一般来说主页的浏览量最大)。所以web服务器会把频繁访问的页面放在主内存里而不是硬盘里，这个过程被称为缓存(cache)。<br>下图展示了有一个线程，dispatcher，从网络那边得到了请求，然后把请求交给一个idle worker thread。然后把这个worker thread唤醒，使它从blocked 状态变成ready状态。</p><img src="/2021/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B1/pic5.png" class><p>当worker唤醒后，它会去检查请求是否满足缓存的需求。如果不满足，它就进行read操作来读取硬盘中的页面然后进入Block直到操作完成。当它Block之后，其他的线程就会工作。<br>Dispatcher的程序包含了一个无限循环来接收工作并把它传给worker:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">Get_next_request(&amp;buf);</span><br><span class="line">Handoff_work(&amp;buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Worker的程序包含了一个无限循环来接收请求，检查web缓存来寻找页面是否存在。如果存在，就返回给客户端并且自己进入block状态等待新任务。如果不存在，就从硬盘中查找然后进入block状态等待新任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">Wait_for_work(&amp;buf);</span><br><span class="line">Look_for_page_in_cache(&amp;buf,&amp;page);</span><br><span class="line">If(page_not_in_cache(&amp;page))</span><br><span class="line">Read_page_from_disk(&amp;buf,&amp;page);</span><br><span class="line">return_page(&amp;page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户级"><a href="#用户级" class="headerlink" title="用户级"></a>用户级</h2><p>有两种实现线程的方法: 在用户空间和在内核里。下文给出了这两种方法的解释和优劣。</p><img src="/2021/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B1/pic6.png" class><p>如上图所示，当线程被用户空间管理的时候，每个进程需要自己的<font color="orange"><strong>thread table</strong></font>来追踪线程。这个Table就类似于在内核中的进程表(process table)，只不过这个table只追踪thread独有的信息，程序计数器，堆栈指针，寄存器，状态等。当一个进程被移到ready或者Block状态的时候，所需要重启的信息就存在thread table里面。<br>线程跟进程有一个关键的区别。当线程结束的时候，比如，调用<em>thread_yield</em>，<em>thread_yield</em>里的代码会把线程的信息存入到线程表里，这些储存线程状态和调度器(scheduler)的程序都是本地程序，所以调用非常快速。这也就是线程调度速度快的原因。<br>用户层面的线程还有其他的一些优势。比如它可以使每个进程有自己的调度算法，而且不会占用内核的空间。</p><h3 id="用户线程的劣势："><a href="#用户线程的劣势：" class="headerlink" title="用户线程的劣势："></a>用户线程的劣势：</h3><p>Blocking系统调用在线程之间会互相影响<br>当一个线程运行的时候，在这个进程中的其他线程是不能运行的，除非运行的线程自愿放弃。这个问题的解决方法就是使运行的系统每秒产生一个中断，但是这种方法往往太复杂，更低效。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>十六进制的转换及运算</title>
      <link href="2021/02/01/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8F%8A%E8%BF%90%E7%AE%97/"/>
      <url>2021/02/01/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8F%8A%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Don’t reinvent the wheel, just realign it.<br>– Anthony D’Angelo</p></blockquote><h2 id="关于十六进制"><a href="#关于十六进制" class="headerlink" title="关于十六进制"></a>关于十六进制</h2><p>一个字节(byte)包含8bits。如果用二进制表示的话，那么数据的范围为0000 0000 - 1111 1111，如果用十进制表示，那就是 0 - 255(2的8次方-1)。这两种表达方法还不够简洁。所以这时候<font color="orange"><strong>十六进制</strong>(hexadecimal)</font>就派上用场了，十六进制就是当每一位上满16就往前进一位,具体转换方法和运算将在下文中演示。十六进制由数字0到9和字母A到F(A到F分别对应十进制的10到15)16个值组成。下面的表格展示了二进制(binary)，十进制(decimal)和十六进制(hex digit)之间相对应的值:</p><img src="/2021/02/01/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8F%8A%E8%BF%90%E7%AE%97/pic1.png" class><p>这样一个字节用16进制表达的范围就是00-FF。在C语言中，16进制通常以0x或者0X开头来表示，比如0xFF(不区分大小写)。</p><h2 id="十六进制和二进制之间的转换"><a href="#十六进制和二进制之间的转换" class="headerlink" title="十六进制和二进制之间的转换"></a>十六进制和二进制之间的转换</h2><p>比如，给到一个数字 0x173A4C,把它转为二进制应该是：<br>十六进制: 1&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;C<br>二进制: 0001 0111 0011 1010 0100 1100</p><p>同样的，从二进制到十六进制可以使用同样的方法<br>二进制:&nbsp;&nbsp;11 1100 1010 1101 1011 0011<br>十六进制: 3&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;D&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;3</p><p><font color="powderblue">NOTE:如果二进制的最高位为0的话，可以在表达的时候省略，比如上面的例子，0011 可以写为11</font></p><h2 id="十六进制和十进制之间的转换"><a href="#十六进制和十进制之间的转换" class="headerlink" title="十六进制和十进制之间的转换"></a>十六进制和十进制之间的转换</h2><h3 id="一种巧妙算法"><a href="#一种巧妙算法" class="headerlink" title="一种巧妙算法"></a>一种巧妙算法</h3><p>在介绍这两种进制的普遍转换算法之前，先介绍一种巧妙的算法，这种算法限于十进制数为2的n次幂(比如2，4，8，16… 1024),也就是这个数 = 2<sup>n</sup>。我们都了解这种数的二进制就是一个1然后加上n个0(2是10，4是100，8是1000，1024是10000000000)。因为2<sup>4</sup> = 16,所以十六进制的一个0相当于二进制的4个0。所以n可以写成 i + 4j的形式，其中 0&lt;= i =&lt;3。举例说明，x = 2048 = 2<sup>11</sup>, n = 11 = 3+4x2,所以十六进制就可以写成0x800(8表示2<sup>3</sup>,后面跟两个0因为4x2里面的2)。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><table><thead><tr><th align="left">n</th><th align="left">decimal</th><th align="left">hexdecimal</th></tr></thead><tbody><tr><td align="left">9</td><td align="left">512</td><td align="left">0x200</td></tr><tr><td align="left">19</td><td align="left">524288</td><td align="left">0x80000</td></tr><tr><td align="left">16</td><td align="left">65536</td><td align="left">0x10000</td></tr></tbody></table><p><font color="orange">解释: 9 = 1+4x2, 所以十六进制为 2<sup>1</sup> 0 0 = 200<br>19 = 3+4x4,所以十六进制为 2<sup>3</sup> 0 0 0 0 = 80000<br>16 = 0+4x4,所以十六进制为2<sup>0</sup> 0 0 0 0 = 10000</font></p><h3 id="普遍算法"><a href="#普遍算法" class="headerlink" title="普遍算法"></a>普遍算法</h3><p>下面来介绍十进制和十六进制之间的普遍算法:<br>和二进制转换的方法相似，十进制数可以写成 x = qx16+r的形式, q代表商，r为余数。<br>举例说明，把314156转换为十六进制:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;314156 = 19634x16+12&nbsp;&nbsp;&nbsp;&nbsp;(C)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19634 = 1227x16+2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1227 = 76x16+11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(B)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;76 = 4x16+12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(C)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 = 0x16+4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4)</p><p>直到q等于0为止。然后从“下往上”写， 十六进制为 0x4CB2C。</p><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><table><thead><tr><th align="left">decimal</th><th align="left">binary</th><th align="left">hexdecimal</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0000 0000</td><td align="left">0x00</td></tr><tr><td align="left">167</td><td align="left">1010 0111</td><td align="left">0xA7</td></tr><tr><td align="left">62</td><td align="left">1010</td><td align="left">0x3E</td></tr></tbody></table><h2 id="十六进制的加减"><a href="#十六进制的加减" class="headerlink" title="十六进制的加减"></a>十六进制的加减</h2><p>和十进制的运算相似，十六进制的加减包含了进位和借位，只是这些位是16而不是10。<br>比如 0x503c + 0x8<br>&nbsp;&nbsp;&nbsp;5 0 3 c<br>&nbsp;&nbsp;&nbsp;+ &nbsp;&nbsp;&nbsp;&nbsp;8<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;&nbsp;_______<br>&nbsp;&nbsp;&nbsp;5 0 4 4</p><p><font color="orange">解释:从最低位开始加起,c+8,因为c对应的值是12,所以c+8=20。因为满16，所以加4进1位。3加上进的1位就是4，因为不到16，所以不需要继续进位。</font></p><p>减法: 0x503c - 0x40<br>&nbsp;&nbsp;&nbsp;. .<br>&nbsp;&nbsp;&nbsp;5 0 3 c<br>&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;4 0<br>&nbsp;&nbsp;&nbsp;_______<br>&nbsp;&nbsp;&nbsp;4 f f c</p><p><font color="orange">解释:从最低位开始减，c-0=c。因为3小于4，所以要向前借一位，也就是借来16，这时候就是16+3-4 = 15 = f,但0也要向前面的5借一位，并借给了3一位，所以就是16-1 = 15 =f。</font></p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>本文中的概念及图片均来源于 <em>深入理解计算机系统</em> (Randal E.Bryant,David R. O’Hallaron)的2.1.1节。经过修改和提炼形成此文。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之进程</title>
      <link href="2021/02/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B/"/>
      <url>2021/02/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Writing means sharing. It’s part of the human condition to want to share things – thoughts, ideas, opinions.<br>– Paulo Coelho</p></blockquote><h2 id="进程简介"><a href="#进程简介" class="headerlink" title="进程简介"></a>进程简介</h2><p>在任何操作系统中，最核心的概念就是进程：在抽象的意义上是一个运行的程序。在现代操作系统中，计算机在运行一个程序的同时，可以从磁盘(disk)中读取然后输出到屏幕上。但是严格的来说，在某一个特定的时刻，CPU只能运行一个程序，因为每个程序运行的时间非常短暂(通常以毫秒，也就是10^-3秒，为单位)，所以在1秒的时间里，CPU会运行多个程序，从而使得用户有多个程序同时运行的感觉。</p><p>计算机中所有可运行的程序，有时甚至包括操作系统本身，都可以被称为<font color="orange"><strong>进程</strong>(processes)</font>。CPU在不同的程序之间快速切换，被称为<font color="orange"><strong>多道程序</strong>(multiprogramming)</font>。</p><p>前文提到过进程是抽象意义上的<font color="orange"><strong>程序</strong>(program)</font>，但两者之间还是有细微的区别。书中给出一个很形象的类比来解释这两个概念，比如有一位父亲想给他的女儿做一个蛋糕，但他只是一个程序员并不是一个专业的蛋糕师。所以他需要找到一份做蛋糕的配方，以及原料：比如鸡蛋，牛奶，糖等。在这个情况下，配方就相当于程序(program)，这位父亲就是CPU，原料就是输入的数据，然而进程是指他做蛋糕的整个过程：包括阅读配方，加入原料以及放入烤箱。</p><p>继续我们的类比，假设这时这位程序员的儿子跑了进来，并说他在踢球时受伤了。所以程序员会暂停阅读蛋糕配方(正在进行的进程被保存)，找出急救指南(关于如何包扎伤口)，然后按指示给儿子包扎。在这里，CPU（程序员）从一个进程（做蛋糕）切换到优先级更高的进程（包扎伤口），每个进程都有不同的程序（蛋糕配方和急救指南）。当他处理完伤口，然后会去继续完成他的蛋糕制作。</p><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>有四个基本的事件可以创建进程:</p><ol><li> 系统的初始化</li><li> 通过一个正在运行的进程系统调用(system call)创建一个进程</li><li>   用户要求创建一个新的进程</li><li>   开始一个Batch job</li></ol><p>下面分别对这四种情况进行详细解释:<br>当操作系统启动的时候，一些进程会被创建，这些进程包括前台进程（与用户交互的一些进程），以及<font color="orange"><strong>后台进程</strong>(daemons)</font>。后台进程一般包括邮件的接收，web的创建以及打印等。在UNIX系统种，ps可以查看正在运行的进程，在windows系统中，可以通过任务管理器(task manage)来查看。</p><p>一个正在运行的进程可以通过系统调用来创建一个新的进程来协助它的工作。比如，想要通过网络来接收大量的数据，一个进程可以接收数据并且把它们放在一个共享的缓冲(buffer)里，第二个进程可以移除这些数据并且处理。</p><p>在一个交互的系统里(现在大部分使用的操作系统都是)，用户可以通过命令行或者双击图标来开始一个进程。</p><p>最后一种情况就是利用batch system(通常在大型的主机上)创建进程。</p><p>笼统的讲，所有的进程都是由一个已经存在的进程所创建的。在UNIX系统里，只有一个系统调用可以创建新的进程：<font color="orange"><strong>fork</strong></font>，它会克隆一个被调用的进程（被称为父进程和子进程）。父进程和子进程的内存映像(memory image)，environment string,以及打开文件(open files)都是相同的。通常情况下，子进程会运行execve或者类似的系统调用来改变它的内存映像，然后运行一个新的程序。比如，当我们在命令行打下 sort，shell会fork一个子进程然后这个子进程来运行sort。这样做原因是运行子进程在fork之后能够操作自己的文件描述符(file descriptor)，同时在运行execve之前来完成标准输出，输入，错误(standard input, output,error)的重定向(redirection)。</p><p><font color="powderblue">Note: 文件描述符(file descriptor)-在文件被读写之前，它必须被打开，而且打开的权限会被检查。如果权限允许，系统会返回一个整数，这个整数就是文件描述符。如果权限不允许，就会返回错误代码</font></p><p>在UNIX和windows系统种，当一个进程被创建后，父进程和子进程都有各自不同的地址空间。</p><h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h2><p>天下没有不散的宴席，这句话也适用于进程。通常有4种情况可以结束一个进程：</p><ol><li> 正常退出（自愿）</li><li>   错误退出(自愿)</li><li>   严重错误（非自愿）</li><li>   由其他进程终止（非自愿）</li></ol><p>大多数的进程都是在完成工作后终止。由系统调用（在UNIX里是exit,在windows里是ExitProcess）来终止。</p><p>第二种情况是进程发现了一些错误。比如，如果用户在命令行输入 cc foo.c 但是foo.c这个文件并不存在。这时编译器就会终止。</p><p>第三种情况通常是由于程序的bug，比如处理一些非法指令，指定一些不存在的内存，或者除数为0等。</p><p>第四种情况是由其他进程来终止。在UNIX里被称为kill, 在windows里是TerminateProcess。通常‘killer’会有一定的权限来执行。</p><h2 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h2><p>一个进程可以产生一个或者多个进程，它和它的”后代们”会组成一个进程Group。当用户通过键盘向这个Group 发送一个信号时，所有的成员都可以收到，同时每个进程都有自己的权力来处理这个信号（接收或忽略）。<br>在UNIX系统里，所有的进程可以被看成一个树的结构，且只有一个根，那就是 <strong>init</strong><br>相反在windows系统里，所有的进程都是平等的(有若干个树)。</p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p>尽管所有的进程都是独立存在(有自己的程序计数器，内部状态)。但大部分情况下进程之间都是交互的，一个进程的输出可能会是另一个进程的输入。比如在shell中的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat chapter1 chapter2 chapter3 | grep tree</span><br></pre></td></tr></table></figure><p>第一个进程运行了cat，把3个文件整合起来并输出。第二个进程运行了grep ，选中所有包含”tree”的行。由于程序的复杂度以CPU处理速度等因素，会出现grep以及准备运行但是前面的cat还没有运行完毕。所以这时候，grep就会进入blocked的状态直到接收到前面的输入。</p><p>进程进入blocked状态有两种情况 :第一种就是上文提到的因为接收不到输入。第二种情况就是操作系统会使CPU处理其他的进程。这两种情况是完全不同的。</p><p>一个进程通常有3种状态</p><ol><li><p> running（在这一刻用CPU）</p></li><li><p>   ready（可运行的；等待其他进程运行）</p></li><li><p>blocked（由于一些外部情况不能运行）</p> <img src="/2021/02/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B/Picture1.png" class></li></ol><p>如上图所示，操作系统状态之间的转换过程有4种。过程1表示一个进程发现它不能运行。在UNIX系统里，当进程接收不到输入的时候，它便自动进入blocked。</p><p>过程2和3是由<font color="orange"><strong>进程调度器</strong>(process scheduler)</font>引起的。进程调度器是操作系统自带的。过程2是当一个进程运行时间过长，调度器决定让其他进程运行。过程3是因为其他的进程都有相当的运行时间是，调度器会让第一个进程重新运行(通常是原来停止运行的进程)。<br>过程4是由于一些外部事件的发送（如接收到输入。</p><h2 id="实现进程"><a href="#实现进程" class="headerlink" title="实现进程"></a>实现进程</h2><p>操作系统以数组的结构来管理进程，这个结构通常被称为<font color="orange"><strong>进程表</strong></font>(process table)或者进程控制块(process control blocks)。每一个条目(entry)包含一个进程。这些条目包含了进程的有关信息，包括进程状态，程序计数器，堆栈指针，内存分配，打开文件的状态，调度信息等。下图展示了一个操作系统的进程条目:<br>    <img src="/2021/02/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B/Picture2.png" class></p><p>对于每一个I/O设备(如软盘，硬盘，计时器，终端)有一个对应的地址(通常在内存的底层)被称为<font color="orange"><strong>中断向量</strong>(interrupt vector)</font>,它包含了中断服务的地址。假设一个磁盘的中断在进程3运行时发生，进程3的程序计数器，程序状态，一个或多个寄存器都会被中断硬件推进堆栈。计算机会跳转到磁盘中断向量的地址上。这就是硬件所做的所有工作，剩下的就要交给软件来做，比如中断服务过程。</p><p>所有的中断都要先保存寄存器，通常在目前进程的进程表里。然后被中断硬件推入堆栈的信息会被移除，然后堆栈指针通过进程处理器指向一个临时的堆栈。通常保存寄存器和设定堆栈指针是由汇编语言完成的，然后剩下的工作由C语言完成(大多数的操作系统是由C语言编写的)。</p><p>中断处理以及调度可以总结为以下几个步骤:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">硬件堆入程序计数器等</span><br><span class="line">硬件从中断向量里提取新的程序计数器</span><br><span class="line">汇编语言保存寄存器</span><br><span class="line">汇编语言设立新的堆栈</span><br><span class="line">C语言中断服务运行（通常是读取或者输入）</span><br><span class="line">调度器决定该运行哪个进程</span><br><span class="line">C语言转回汇编语言</span><br><span class="line">由汇编语言开启新的进程</span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>本系列关于操作系统的理论知识及图片来源于<em>现代操作系统</em> (Andrew S. Tanenbaum, Herbert Bos)。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言2</title>
      <link href="2021/01/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%802/"/>
      <url>2021/01/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%802/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Vessels large may venture more, but little boats should keep near shore.<br>-Benjamin Franklin</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文主要讨论有关寄存器的话题。一个典型的CPU由运算器，控制器，寄存器等器件构成，这些器件靠内部总线连接。在CPU中：</p><ul><li>运算器进行信息处理</li><li>寄存器进行信息存储</li><li>控制器控制各种器件进行工作</li><li>内部总线连接各种器件，在他们之间进行数据的传送。<br>寄存器是CPU中程序员可以用指令读写的部件，程序员通过改变各种寄存器中的内容来实现对CPU的控制。</li></ul><p>不同的CPU，寄存器的个数，结构是不同的。8086CPU中有14个寄存器，每个寄存器有一个名称。这些寄存器是：AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW。</p><h2 id="不同种类的寄存器"><a href="#不同种类的寄存器" class="headerlink" title="不同种类的寄存器"></a>不同种类的寄存器</h2><ol><li><p>通用寄存器</p><ul><li>AX,BX,CX,DX这4个寄存器通常用来存放一般性的数据<img src="/2021/01/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%802/reg.png" class></li><li>如图所示，在8086中，所有的寄存器都是16位。这4个寄存器都能分为两个可以独立使用的8位寄存器<ul><li>AX可以分为AH和AL</li><li>BX可以分为BH和BL</li><li>CX可以分为CH和CL</li><li>DX可以分为DH和DL<br>AX的低8位(0-7位)构成了AL寄存器，高8位构成了AH寄存器。AH和AL是可以独立使用的8位寄存器。</li></ul></li></ul></li><li><p>字(word)在寄存器中的存储</p><ul><li><p>8086CPU可以一次性处理两种尺寸的数据，字节和字(byte and word)</p><ul><li><p>字节：由8个bit组成，可以存在8位寄存器中</p></li><li><p>字：由2个字节组成，这两个字节分别称为这个字的高位字节和低位字节,如下图所示</p><img src="/2021/01/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%802/reg2.png" class></li><li><p>所以例子中的寄存器既可以被看成一个字(大小为20000),也可以看成两个独立的字节(分别是78和32)</p></li></ul></li></ul></li><li><p>汇编指令</p><ul><li>举几个指令的例子<table><thead><tr><th align="left">汇编指令</th><th align="left">控制CPU的操作</th><th align="left">高级语言描述</th></tr></thead><tbody><tr><td align="left">mov ax,18</td><td align="left">将18送入寄存器AX</td><td align="left">AX=18</td></tr><tr><td align="left">mov ah,78</td><td align="left">将78送入寄存器AH</td><td align="left">AH=78</td></tr><tr><td align="left">add ax,8</td><td align="left">将寄存器AX的值加8</td><td align="left">AX=AX+8</td></tr><tr><td align="left">mov ax,bx</td><td align="left">将寄存器BX的值送入AX</td><td align="left">AX=BX</td></tr></tbody></table></li></ul></li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ol><li>mov ax,62627        AX = <u>F4A3H</u>   <font color="orange">#AX为16位寄存器，只能存放4位十六进制的数据,H代表十六进制</font></li><li>mov ah,31H        AX = <u>31A3H</u></li><li>mov al,23H        AX = <u>3123H</u></li><li>add ax,ax        AX = <u>6246H</u></li><li>mov bx,826CH        BX = <u>826CH</u></li><li>mov cx,ax        CX = <u>6246H</u></li><li>mov ax,bx        AX = <u>826CH</u></li><li>add ax,bx        AX = <u>04D8H</u></li><li>mov al,bh        AX = <u>0482H</u></li><li>mov ah,bl       AX = <u>6C82H</u></li></ol><p>关于十六进制的运算,请参考另一篇博客 <a href="/2021/02/01/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8F%8A%E8%BF%90%E7%AE%97/" title="十六进制的转换及运算">十六进制的转换及运算</a></p><p>例题2:<br>用目前学过的汇编指令，最多使用4条指令，编程计算2的4次方。<br><font color="orange">解答：<br>    mov ax,2&nbsp;&nbsp;&nbsp;&nbsp;ax=2<br>    add ax,ax&nbsp;&nbsp;&nbsp;ax=4<br>    add ax,ax&nbsp;&nbsp;&nbsp;ax=8<br>    add ax,ax&nbsp;&nbsp;&nbsp;ax=16<br></font></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言1</title>
      <link href="2021/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801/"/>
      <url>2021/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801/</url>
      
        <content type="html"><![CDATA[<blockquote><p>One man’s ‘magic’ is another man’s engineering.<br>– Robert Heinlein</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这个系列的笔记是关于汇编语言的学习，所用的教材是清华大学出版社出版的<em>汇编语言</em>。主要内容就是来自教科书中的重要概念，练习题以及实验。这本书采用8086CPU来进行教学，学习中用到了DOSBox这款软件。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>汇编语言的核心是汇编指令，汇编语言工作的过程如图：</p><img src="/2021/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801/ass.png" class><ol><li><p>存储器</p><ul><li>又称为内存</li><li>存放指令和数据</li></ul></li><li><p>指令和数据</p><ul><li>是应用上的概念(二进制信息)</li><li>比如，内存中的二进制信息1000100111011000，计算机可以把它看成大小为89D8H的数据，也可以看作是指令 mov ax,bx来执行</li><li>1000100111011000 -&gt; 89D8H (数据)， 1000100111011000 -&gt; mov ax,bx(程序)</li></ul></li><li><p>存储单元<br>|   |   |   |   |   |   |   |   |<br> 0    1   2    …   125  126  127</p><ul><li>存储器被分成若干个存储单元，如一个存储器有128个存储单元，编号从0 - 127</li><li>一个单元可以存储一个byte(8bits), 比如0001 0001。上面的存储器的大小就是128个字节</li><li>1KB=1024B, 1MB=1204KB,1GB=1024MB,1TB=1024GB (B代表Byte)</li></ul></li><li><p>CPU对存储器的读写</p><ul><li>CPU需要和芯片交互3种信息<ol><li>存储单元的地址(地址信息)</li><li>器件的选择，读或写的命令(控制信息)</li><li>读或写的数据(数据信息)</li></ol></li><li>CPU和内存在物理上通过导线交互，通常称为总线；在逻辑上分为地址总线，控制总线和数据总线<img src="/2021/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801/ass2.png" class>上图的具体步骤为:<ol><li>CPU通过地址总线讲地址信息3发出</li><li>CPU通过控制总线发出内存读命令，选中单元，并通知</li><li>存储器将3号单元中的数据08通过数据线送入CPU</li></ol></li><li>举例:<br>  机器码：10100001 00000011 00000000<br>  对应汇编：MOV AX,[3]<br>  含义：传送3号单元的内容到AX</li></ul><p>下面分别对这3个总线进行解释:</p></li><li><p>地址总线</p><ul><li><p>用来指定存储器单元，传送一条信息对应一个单元</p></li><li><p>如果一个CPU有10根地址总线，用二进制表示，就可以传输2^10 = 1024个不同的数据(0-1023)</p></li><li><p>下图展示了具有10根地址线的CPU向内存发出信息地址11时，10根地址线上传送的二进制信息</p><img src="/2021/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801/ass3.png" class></li></ul></li><li><p>数据总线</p><ul><li><p>数据总线的宽度决定了CPU和外界传输的速度，8根总线可以传送一个8位二进制(一个字节)</p></li><li><p>下图展示了8086CPU有16根数据总线，可以传输16位数据</p><img src="/2021/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801/ass4.png" class></li></ul></li><li><p>控制总线</p><ul><li>一根控制总线代表着CPU对外设的一种控制，宽度决定了CPU的控制能力</li><li>读和写操作分别有两根控制线负责。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">汇编指令是机器指令的助记符</span><br><span class="line">每一种CPU都有自己的汇编指令集</span><br><span class="line">CPU可以使用的信息在存储器中存放</span><br><span class="line">在存储器中指令和数据没有区别，都是二进制信息</span><br><span class="line">存储单元从0开始顺序编号</span><br><span class="line">一个存储单元可以存储8个bit,即8位二进制数</span><br><span class="line">1B &#x3D; 8bit, 1KB &#x3D; 1024B, 1MB &#x3D; 1024KB, 1GB &#x3D; 1024 MB</span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>文中所有的概念和图片均来自于王爽的<em>汇编语言</em></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>freeRTOS实时操作系统</title>
      <link href="2021/01/30/freeRTOS%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/01/30/freeRTOS%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>It is not the mountain we conquer but ourselves.<br>– Sir Edmund Hillary</p></blockquote><p>这是一篇总结自己在实习的时候最开始接触的一个项目：把freeRTOS操作系统移植到VEGAboard-一款以RISC-V为架构的开发板。大概是这个样子的：</p><img src="/2021/01/30/freeRTOS%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/vegaboard.jpg" class><p>关于硬件方面以及RISCV指令集，在这篇文章里不会提到。本篇的主要内容是对freeRTOS内核代码的简介，包括从硬件上电到主程序运行的过程。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>FreeRTOS的源码主要可以分成三大部分：1.用于处理任务（task）的代码，有大概一半的freeRTOS的代码用来处理task。其中task.c和task.h文件做了大部分创建和管理任务的工作。2.不同task之间的交流，在queue.c和queue.h文件里，任务或者中断之间可以互相发送数据以及使用semaphores和mutexes来通信和共享信息。3.还有一部分代码是用来沟通软件和硬件之间的代码，如port.c 和portasm.s。本文是以官方提供的blinky demo来举例。</p><h2 id="初始化和复位"><a href="#初始化和复位" class="headerlink" title="初始化和复位"></a>初始化和复位</h2><p>当开发板通电后，驱动程序（device driver）里的startup，以及链接文件用来初始化和复位：</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Reset Handler */</span></span><br><span class="line"><span class="symbol">Reset_Handler:</span></span><br><span class="line">    <span class="comment"># Disable global interrupt. */</span></span><br><span class="line">    csrci mstatus, <span class="number">8</span></span><br><span class="line">    <span class="comment"># initialize stack pointer</span></span><br><span class="line">    la <span class="built_in">sp</span>, __StackTop</span><br><span class="line">    <span class="comment"># initialize global pointer</span></span><br><span class="line">    la gp, __global_pointer</span><br></pre></td></tr></table></figure><p>为了保证整个startup的过程不受外设中断的影响，Reset_Handler首先会关闭全局中断(disable),然后初始化堆栈指针（la sp,__StackTOP)。紧接着，程序会执行SystemInit函数，这个函数的功能主要是相关寄存器的复位以及时钟的初始化，包括关闭看门狗(watchdog),初始化中断向量表的地址。在systemInit()中，下面的两行代码把Flash中的代码拷贝到RAM中运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy_section(&amp;__etext, &amp;__data_start__, &amp;__data_end__);</span><br><span class="line">zero_section(&amp;__bss_start__, &amp;__bss_end__);</span><br></pre></td></tr></table></figure><p>然后跳转到main函数。</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable global interrupt. */</span></span><br><span class="line"><span class="symbol">csrsi</span> mstatus, <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">jal</span> main</span><br></pre></td></tr></table></figure><p>连接文件（RV32M1_ri5cy_flash.ld）用来初始化C语言的堆栈。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   .data : AT(__DATA_ROM)</span><br><span class="line"> &#123;</span><br><span class="line">   . &#x3D; ALIGN(4);</span><br><span class="line">   __DATA_RAM &#x3D; .;</span><br><span class="line">   __data_start__ &#x3D; .;      &#x2F;* create a global symbol at data start *&#x2F;</span><br><span class="line">   *(.data)                 &#x2F;* .data sections *&#x2F;</span><br><span class="line">   *(.data*)                &#x2F;* .data* sections *&#x2F;</span><br><span class="line">   *(.sdata .sdata.*)</span><br><span class="line">   *(.heapsram*)            &#x2F;* This is only for the pulpino official test code. *&#x2F;</span><br><span class="line">   __noncachedata_start__ &#x3D; .;   &#x2F;* create a global symbol at ncache data start *&#x2F;</span><br><span class="line">*(NonCacheable)</span><br><span class="line">   __noncachedata_end__ &#x3D; .;     &#x2F;* define a global symbol at ncache data end *&#x2F;</span><br><span class="line">   KEEP(*(.jcr*))</span><br><span class="line">   . &#x3D; ALIGN(4);</span><br><span class="line">   __data_end__ &#x3D; .;        &#x2F;* define a global symbol at data end *&#x2F;</span><br><span class="line"> &#125; &gt; m_data</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>.data 是C语言中已经初始化的变量，.bss是没有初始化的变量，没有初始化的值为零。以上就完成了变量的初始化。</p><h2 id="接口文件"><a href="#接口文件" class="headerlink" title="接口文件"></a>接口文件</h2><p>操作系统的内核代码（如task.c）通过port.c,portASM.S等文件与底层硬件交流。比如在task.h中有以下一行代码是使一个任务进入critical section来防止其他的任务进入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> taskENTER_CRITICAL()               portENTER_CRITICAL()</span></span><br></pre></td></tr></table></figure><p>这里的portENTER_CRITICAL()就是在portmarco.h里定义的，这样就使得task.c不用与底层的硬件交流，对于不同的硬件设备只需要更改port文件就可以。<br>portASM.S 是一个汇编接口文件，这个文件适用于所有的芯片。但它包含了一个特定于某个芯片的头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;freertos_risc_v_chip_specific_extensions.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>比如在本文中的demo里，这个头文件包含了针对RISC-V-RV32的一些额外寄存器的存储以及复位。这样就可以解决不同的芯片需要一些不同的寄存器。</p><h2 id="安排任务"><a href="#安排任务" class="headerlink" title="安排任务"></a>安排任务</h2><p>每一个任务需要被指定一个优先级，这个优先级的数字从0 到 configMAX_PRIORITIES-1 （在freeRTOSConfig.h里被定义）。如果configMAX_PRIORITIES被设置为5，那么每个任务可以使用0（最低），1，2，3，4（最高）作为优先的等级。<br>FreeRTOS使用一个准备列表（ready list）来收集所有准备运行的任务。定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PRIVILEGED_DATA <span class="keyword">static</span> List_t pxReadyTasksLists[ configMAX_PRIORITIES ];</span><br></pre></td></tr></table></figure><p>比如，pxReadyTasksLists[1]是所有优先级为1且准备运行任务的列表。<br>vTaskSwitchContext()函数会终止现在的任务而选择优先级更高的任务然后把这个任务放入pxCurrentTCB：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> taskSELECT_HIGHEST_PRIORITY_TASK()                                </span></span><br><span class="line">&#123;                                                                         </span><br><span class="line">    UBaseType_t uxTopPriority = uxTopReadyPriority;                       </span><br><span class="line">                                                                          </span><br><span class="line">    <span class="comment">/* Find the highest priority queue that contains ready tasks. */</span>      </span><br><span class="line">    <span class="keyword">while</span>( listLIST_IS_EMPTY( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) ) </span><br><span class="line">    &#123;  </span><br><span class="line">        configASSERT( uxTopPriority );                                    </span><br><span class="line">        --uxTopPriority;                                                  </span><br><span class="line">    &#125;                                                                     </span><br><span class="line">                                                                          </span><br><span class="line">    <span class="comment">/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of </span></span><br><span class="line"><span class="comment">     * the  same priority get an equal share of the processor time. */</span>                    </span><br><span class="line">    listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;( pxReadyTasksLists[ uxTopPriority ] ) ); </span><br><span class="line">    uxTopReadyPriority = uxTopPriority;                                                   </span><br><span class="line">&#125; <span class="comment">/* taskSELECT_HIGHEST_PRIORITY_TASK */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的函数确保了优先级高的任务先执行，首先要确保uxTopReadyPriority大于或等于有最高优先级的等待任务。在while循环里，从uxTopReadyPriority优先级开始，在pxReadyTasksLists[]里寻找准备任务的最高优先级。listGET_OWNER_OF_NEXT_ENTRY()函数可以从ready list里抓取下一个任务。<br>接下来pxCurrentTCB 指向最高优先级的任务，vTaskSwitchContext()就会使硬件执行任务。</p><h2 id="建立任务"><a href="#建立任务" class="headerlink" title="建立任务"></a>建立任务</h2><p>xTaskCreate用于创建新的任务。每一个任务都会有一个对应的TCB(task control block),TCB包含了任务的信息，包括任务名称，优先级，内存地址等。这些TCB都储存在一个堆栈里，pxPortInitialiseStack()函数会在新任务准备运行之前初始化堆栈。<br>以官方提供的demo为例(C:\FreeRTOS_RISCV\FreeRTOS\Demo\RISC-V_RV32M1_Vega_GCC_Eclipse\projects\RTOSDemo_ri5cy)。在main.c文件里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">prvSetupHardware();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The mainCREATE_SIMPLE_BLINKY_DEMO_ONLY setting is described at the top</span></span><br><span class="line"><span class="comment">of this file. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>( mainCREATE_SIMPLE_BLINKY_DEMO_ONLY == 1 )</span></span><br><span class="line">&#123;</span><br><span class="line">main_blinky();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">&#123;</span><br><span class="line">main_full();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>首先prvSetupHardware()用来初始化硬件，然后调用在main_full.c里的main_full()函数（因为mainCREATE_SIMPLE_BLINKY_DEMO_ONLY被设为0）。<br>在main_full()中，有三个任务被创建,其中前两个是 ‘register check’,用来检查register是否正常，他们被设置为最低优先级，以便被其他的任务覆盖。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xTaskCreate( prvRegTestTaskEntry1, <span class="comment">/* The function that implements the task. */</span></span><br><span class="line"><span class="string">&quot;Reg1&quot;</span>, <span class="comment">/* The name of the task. */</span></span><br><span class="line">mainREG_TEST_STACK_SIZE_WORDS,  <span class="comment">/* Size of stack to allocate for the task - in words not bytes!. */</span></span><br><span class="line">mainREG_TEST_TASK_1_PARAMETER,  <span class="comment">/* Parameter passed into the task. */</span></span><br><span class="line">tskIDLE_PRIORITY, <span class="comment">/* Priority of the task. */</span></span><br><span class="line"><span class="literal">NULL</span> );<span class="comment">/* Can be used to pass out a handle to the created task. */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>prvCheckTask()是用来检查所有的demo 任务以及上面的两个register check。当程序运行的时候，prvCheckTask()会在终端显示中打印一个 ‘pass’并且每成功一个循环(所有的demo和2个register test)都会打印一个 ‘.’，而且LED灯闪烁一次。最后 vTaskStartScheduler()使最高优先级的任务进入running mode(运行)。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了硬件上电后初始化的代码(主要为汇编代码)，链接硬件和软件的接口文件(port)。以及最基础的任务运行原理(高优先级替换低优先级)。经过一段时间的学习，我对freeRTOS及操作系统的理解还相对较浅。随着项目的深入和学习，更多关于此话题的文章会更新。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
