<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>十六进制的转换及运算</title>
      <link href="2021/02/01/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8F%8A%E8%BF%90%E7%AE%97/"/>
      <url>2021/02/01/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8F%8A%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Don’t reinvent the wheel, just realign it.<br>– Anthony D’Angelo</p></blockquote><h2 id="关于十六进制"><a href="#关于十六进制" class="headerlink" title="关于十六进制"></a>关于十六进制</h2><p>一个字节(byte)包含8bits。如果用二进制表示的话，那么数据的范围为0000 0000 - 1111 1111，如果用十进制表示，那就是 0 - 255(2的8次方-1)。这两种表达方法还不够简洁。所以这时候<font color="orange"><strong>十六进制</strong>(hexadecimal)</font>就派上用场了，十六进制就是当每一位上满16就往前进一位,具体转换方法和运算将在下文中演示。十六进制由数字0到9和字母A到F(A到F分别对应十进制的10到15)16个值组成。下面的表格展示了二进制(binary)，十进制(decimal)和十六进制(hex digit)之间相对应的值:</p><img src="/2021/02/01/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8F%8A%E8%BF%90%E7%AE%97/pic1.png" class><p>这样一个字节用16进制表达的范围就是00-FF。在C语言中，16进制通常以0x或者0X开头来表示，比如0xFF(不区分大小写)。</p><h2 id="十六进制和二进制之间的转换"><a href="#十六进制和二进制之间的转换" class="headerlink" title="十六进制和二进制之间的转换"></a>十六进制和二进制之间的转换</h2><p>比如，给到一个数字 0x173A4C,把它转为二进制应该是：<br>十六进制: 1&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;C<br>二进制: 0001 0111 0011 1010 0100 1100</p><p>同样的，从二进制到十六进制可以使用同样的方法<br>二进制:&nbsp;&nbsp;11 1100 1010 1101 1011 0011<br>十六进制: 3&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;D&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;3</p><p><font color="powderblue">NOTE:如果二进制的最高位为0的话，可以在表达的时候省略，比如上面的例子，0011 可以写为11</font></p><h2 id="十六进制和十进制之间的转换"><a href="#十六进制和十进制之间的转换" class="headerlink" title="十六进制和十进制之间的转换"></a>十六进制和十进制之间的转换</h2><h3 id="一种巧妙算法"><a href="#一种巧妙算法" class="headerlink" title="一种巧妙算法"></a>一种巧妙算法</h3><p>在介绍这两种进制的普遍转换算法之前，先介绍一种巧妙的算法，这种算法限于十进制数为2的n次幂(比如2，4，8，16… 1024),也就是这个数 = 2<sup>n</sup>。我们都了解这种数的二进制就是一个1然后加上n个0(2是10，4是100，8是1000，1024是10000000000)。因为2<sup>4</sup> = 16,所以十六进制的一个0相当于二进制的4个0。所以n可以写成 i + 4j的形式，其中 0&lt;= i =&lt;3。举例说明，x = 2048 = 2<sup>11</sup>, n = 11 = 3+4x2,所以十六进制就可以写成0x800(8表示2<sup>3</sup>,后面跟两个0因为4x2里面的2)。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><table><thead><tr><th align="left">n</th><th align="left">decimal</th><th align="left">hexdecimal</th></tr></thead><tbody><tr><td align="left">9</td><td align="left">512</td><td align="left">0x200</td></tr><tr><td align="left">19</td><td align="left">524288</td><td align="left">0x80000</td></tr><tr><td align="left">16</td><td align="left">65536</td><td align="left">0x10000</td></tr></tbody></table><p><font color="orange">解释: 9 = 1+4x2, 所以十六进制为 2<sup>1</sup> 0 0 = 200<br>19 = 3+4x4,所以十六进制为 2<sup>3</sup> 0 0 0 0 = 80000<br>16 = 0+4x4,所以十六进制为2<sup>0</sup> 0 0 0 0 = 10000</font></p><h3 id="普遍算法"><a href="#普遍算法" class="headerlink" title="普遍算法"></a>普遍算法</h3><p>下面来介绍十进制和十六进制之间的普遍算法:<br>和二进制转换的方法相似，十进制数可以写成 x = qx16+r的形式, q代表商，r为余数。<br>举例说明，把314156转换为十六进制:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;314156 = 19634x16+12&nbsp;&nbsp;&nbsp;&nbsp;(C)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19634 = 1227x16+2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1227 = 76x16+11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(B)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;76 = 4x16+12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(C)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 = 0x16+4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4)</p><p>直到q等于0为止。然后从“下往上”写， 十六进制为 0x4CB2C。</p><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><table><thead><tr><th align="left">decimal</th><th align="left">binary</th><th align="left">hexdecimal</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0000 0000</td><td align="left">0x00</td></tr><tr><td align="left">167</td><td align="left">1010 0111</td><td align="left">0xA7</td></tr><tr><td align="left">62</td><td align="left">1010</td><td align="left">0x3E</td></tr></tbody></table><h2 id="十六进制的加减"><a href="#十六进制的加减" class="headerlink" title="十六进制的加减"></a>十六进制的加减</h2><p>和十进制的运算相似，十六进制的加减包含了进位和借位，只是这些位是16而不是10。<br>比如 0x503c + 0x8<br>&nbsp;&nbsp;&nbsp;5 0 3 c<br>&nbsp;&nbsp;&nbsp;+ &nbsp;&nbsp;&nbsp;&nbsp;8<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;&nbsp;_______<br>&nbsp;&nbsp;&nbsp;5 0 4 4</p><p><font color="orange">解释:从最低位开始加起,c+8,因为c对应的值是12,所以c+8=20。因为满16，所以加4进1位。3加上进的1位就是4，因为不到16，所以不需要继续进位。</font></p><p>减法: 0x503c - 0x40<br>&nbsp;&nbsp;&nbsp;. .<br>&nbsp;&nbsp;&nbsp;5 0 3 c<br>&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;4 0<br>&nbsp;&nbsp;&nbsp;_______<br>&nbsp;&nbsp;&nbsp;4 f f c</p><p><font color="orange">解释:从最低位开始减，c-0=c。因为3小于4，所以要向前借一位，也就是借来16，这时候就是16+3-4 = 15 = f,但0也要向前面的5借一位，并借给了3一位，所以就是16-1 = 15 =f。</font></p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>本文中的概念及图片均来源于 <em>深入理解计算机系统</em> (Randal E.Bryant,David R. O’Hallaron)的2.1.1节。经过修改和提炼形成此文。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之进程</title>
      <link href="2021/02/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B/"/>
      <url>2021/02/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Writing means sharing. It’s part of the human condition to want to share things – thoughts, ideas, opinions.<br>– Paulo Coelho</p></blockquote><h2 id="进程简介"><a href="#进程简介" class="headerlink" title="进程简介"></a>进程简介</h2><p>在任何操作系统中，最核心的概念就是进程：在抽象的意义上是一个运行的程序。在现代操作系统中，计算机在运行一个程序的同时，可以从磁盘(disk)中读取然后输出到屏幕上。但是严格的来说，在某一个特定的时刻，CPU只能运行一个程序，因为每个程序运行的时间非常短暂(通常以毫秒，也就是10^-3秒，为单位)，所以在1秒的时间里，CPU会运行多个程序，从而使得用户有多个程序同时运行的感觉。</p><p>计算机中所有可运行的程序，有时甚至包括操作系统本身，都可以被称为<font color="orange"><strong>进程</strong>(processes)</font>。CPU在不同的程序之间快速切换，被称为<font color="orange"><strong>多道程序</strong>(multiprogramming)</font>。</p><p>前文提到过进程是抽象意义上的<font color="orange"><strong>程序</strong>(program)</font>，但两者之间还是有细微的区别。书中给出一个很形象的类比来解释这两个概念，比如有一位父亲想给他的女儿做一个蛋糕，但他只是一个程序员并不是一个专业的蛋糕师。所以他需要找到一份做蛋糕的配方，以及原料：比如鸡蛋，牛奶，糖等。在这个情况下，配方就相当于程序(program)，这位父亲就是CPU，原料就是输入的数据，然而进程是指他做蛋糕的整个过程：包括阅读配方，加入原料以及放入烤箱。</p><p>继续我们的类比，假设这时这位程序员的儿子跑了进来，并说他在踢球时受伤了。所以程序员会暂停阅读蛋糕配方(正在进行的进程被保存)，找出急救指南(关于如何包扎伤口)，然后按指示给儿子包扎。在这里，CPU（程序员）从一个进程（做蛋糕）切换到优先级更高的进程（包扎伤口），每个进程都有不同的程序（蛋糕配方和急救指南）。当他处理完伤口，然后会去继续完成他的蛋糕制作。</p><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>有四个基本的事件可以创建进程:</p><ol><li> 系统的初始化</li><li> 通过一个正在运行的进程系统调用(system call)创建一个进程</li><li>   用户要求创建一个新的进程</li><li>   开始一个Batch job</li></ol><p>下面分别对这四种情况进行详细解释:<br>当操作系统启动的时候，一些进程会被创建，这些进程包括前台进程（与用户交互的一些进程），以及<font color="orange"><strong>后台进程</strong>(daemons)</font>。后台进程一般包括邮件的接收，web的创建以及打印等。在UNIX系统种，ps可以查看正在运行的进程，在windows系统中，可以通过任务管理器(task manage)来查看。</p><p>一个正在运行的进程可以通过系统调用来创建一个新的进程来协助它的工作。比如，想要通过网络来接收大量的数据，一个进程可以接收数据并且把它们放在一个共享的缓冲(buffer)里，第二个进程可以移除这些数据并且处理。</p><p>在一个交互的系统里(现在大部分使用的操作系统都是)，用户可以通过命令行或者双击图标来开始一个进程。</p><p>最后一种情况就是利用batch system(通常在大型的主机上)创建进程。</p><p>笼统的讲，所有的进程都是由一个已经存在的进程所创建的。在UNIX系统里，只有一个系统调用可以创建新的进程：<font color="orange"><strong>fork</strong></font>，它会克隆一个被调用的进程（被称为父进程和子进程）。父进程和子进程的内存映像(memory image)，environment string,以及打开文件(open files)都是相同的。通常情况下，子进程会运行execve或者类似的系统调用来改变它的内存映像，然后运行一个新的程序。比如，当我们在命令行打下 sort，shell会fork一个子进程然后这个子进程来运行sort。这样做原因是运行子进程在fork之后能够操作自己的文件描述符(file descriptor)，同时在运行execve之前来完成标准输出，输入，错误(standard input, output,error)的重定向(redirection)。</p><p><font color="powderblue">Note: 文件描述符(file descriptor)-在文件被读写之前，它必须被打开，而且打开的权限会被检查。如果权限允许，系统会返回一个整数，这个整数就是文件描述符。如果权限不允许，就会返回错误代码</font></p><p>在UNIX和windows系统种，当一个进程被创建后，父进程和子进程都有各自不同的地址空间。</p><h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h2><p>天下没有不散的宴席，这句话也适用于进程。通常有4种情况可以结束一个进程：</p><ol><li> 正常退出（自愿）</li><li>   错误退出(自愿)</li><li>   严重错误（非自愿）</li><li>   由其他进程终止（非自愿）</li></ol><p>大多数的进程都是在完成工作后终止。由系统调用（在UNIX里是exit,在windows里是ExitProcess）来终止。</p><p>第二种情况是进程发现了一些错误。比如，如果用户在命令行输入 cc foo.c 但是foo.c这个文件并不存在。这时编译器就会终止。</p><p>第三种情况通常是由于程序的bug，比如处理一些非法指令，指定一些不存在的内存，或者除数为0等。</p><p>第四种情况是由其他进程来终止。在UNIX里被称为kill, 在windows里是TerminateProcess。通常‘killer’会有一定的权限来执行。</p><h2 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h2><p>一个进程可以产生一个或者多个进程，它和它的”后代们”会组成一个进程Group。当用户通过键盘向这个Group 发送一个信号时，所有的成员都可以收到，同时每个进程都有自己的权力来处理这个信号（接收或忽略）。<br>在UNIX系统里，所有的进程可以被看成一个树的结构，且只有一个根，那就是 <strong>init</strong><br>相反在windows系统里，所有的进程都是平等的(有若干个树)。</p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p>尽管所有的进程都是独立存在(有自己的程序计数器，内部状态)。但大部分情况下进程之间都是交互的，一个进程的输出可能会是另一个进程的输入。比如在shell中的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat chapter1 chapter2 chapter3 | grep tree</span><br></pre></td></tr></table></figure><p>第一个进程运行了cat，把3个文件整合起来并输出。第二个进程运行了grep ，选中所有包含”tree”的行。由于程序的复杂度以CPU处理速度等因素，会出现grep以及准备运行但是前面的cat还没有运行完毕。所以这时候，grep就会进入blocked的状态直到接收到前面的输入。</p><p>进程进入blocked状态有两种情况 :第一种就是上文提到的因为接收不到输入。第二种情况就是操作系统会使CPU处理其他的进程。这两种情况是完全不同的。</p><p>一个进程通常有3种状态</p><ol><li><p> running（在这一刻用CPU）</p></li><li><p>   ready（可运行的；等待其他进程运行）</p></li><li><p>blocked（由于一些外部情况不能运行）</p> <img src="/2021/02/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B/Picture1.png" class></li></ol><p>如上图所示，操作系统状态之间的转换过程有4种。过程1表示一个进程发现它不能运行。在UNIX系统里，当进程接收不到输入的时候，它便自动进入blocked。</p><p>过程2和3是由<font color="orange"><strong>进程调度器</strong>(process scheduler)</font>引起的。进程调度器是操作系统自带的。过程2是当一个进程运行时间过长，调度器决定让其他进程运行。过程3是因为其他的进程都有相当的运行时间是，调度器会让第一个进程重新运行(通常是原来停止运行的进程)。<br>过程4是由于一些外部事件的发送（如接收到输入。</p><h2 id="实现进程"><a href="#实现进程" class="headerlink" title="实现进程"></a>实现进程</h2><p>操作系统以数组的结构来管理进程，这个结构通常被称为<font color="orange"><strong>进程表</strong></font>(process table)或者进程控制块(process control blocks)。每一个条目(entry)包含一个进程。这些条目包含了进程的有关信息，包括进程状态，程序计数器，堆栈指针，内存分配，打开文件的状态，调度信息等。下图展示了一个操作系统的进程条目:<br>    <img src="/2021/02/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B/Picture2.png" class></p><p>对于每一个I/O设备(如软盘，硬盘，计时器，终端)有一个对应的地址(通常在内存的底层)被称为<font color="orange"><strong>中断向量</strong>(interrupt vector)</font>,它包含了中断服务的地址。假设一个磁盘的中断在进程3运行时发生，进程3的程序计数器，程序状态，一个或多个寄存器都会被中断硬件推进堆栈。计算机会跳转到磁盘中断向量的地址上。这就是硬件所做的所有工作，剩下的就要交给软件来做，比如中断服务过程。</p><p>所有的中断都要先保存寄存器，通常在目前进程的进程表里。然后被中断硬件推入堆栈的信息会被移除，然后堆栈指针通过进程处理器指向一个临时的堆栈。通常保存寄存器和设定堆栈指针是由汇编语言完成的，然后剩下的工作由C语言完成(大多数的操作系统是由C语言编写的)。</p><p>中断处理以及调度可以总结为以下几个步骤:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">硬件堆入程序计数器等</span><br><span class="line">硬件从中断向量里提取新的程序计数器</span><br><span class="line">汇编语言保存寄存器</span><br><span class="line">汇编语言设立新的堆栈</span><br><span class="line">C语言中断服务运行（通常是读取或者输入）</span><br><span class="line">调度器决定该运行哪个进程</span><br><span class="line">C语言转回汇编语言</span><br><span class="line">由汇编语言开启新的进程</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言2</title>
      <link href="2021/01/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%802/"/>
      <url>2021/01/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%802/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Vessels large may venture more, but little boats should keep near shore.<br>-Benjamin Franklin</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文主要讨论有关寄存器的话题。一个典型的CPU由运算器，控制器，寄存器等器件构成，这些器件靠内部总线连接。在CPU中：</p><ul><li>运算器进行信息处理</li><li>寄存器进行信息存储</li><li>控制器控制各种器件进行工作</li><li>内部总线连接各种器件，在他们之间进行数据的传送。<br>寄存器是CPU中程序员可以用指令读写的部件，程序员通过改变各种寄存器中的内容来实现对CPU的控制。</li></ul><p>不同的CPU，寄存器的个数，结构是不同的。8086CPU中有14个寄存器，每个寄存器有一个名称。这些寄存器是：AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW。</p><h2 id="不同种类的寄存器"><a href="#不同种类的寄存器" class="headerlink" title="不同种类的寄存器"></a>不同种类的寄存器</h2><ol><li><p>通用寄存器</p><ul><li>AX,BX,CX,DX这4个寄存器通常用来存放一般性的数据<img src="/2021/01/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%802/reg.png" class></li><li>如图所示，在8086中，所有的寄存器都是16位。这4个寄存器都能分为两个可以独立使用的8位寄存器<ul><li>AX可以分为AH和AL</li><li>BX可以分为BH和BL</li><li>CX可以分为CH和CL</li><li>DX可以分为DH和DL<br>AX的低8位(0-7位)构成了AL寄存器，高8位构成了AH寄存器。AH和AL是可以独立使用的8位寄存器。</li></ul></li></ul></li><li><p>字(word)在寄存器中的存储</p><ul><li><p>8086CPU可以一次性处理两种尺寸的数据，字节和字(byte and word)</p><ul><li><p>字节：由8个bit组成，可以存在8位寄存器中</p></li><li><p>字：由2个字节组成，这两个字节分别称为这个字的高位字节和低位字节,如下图所示</p><img src="/2021/01/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%802/reg2.png" class></li><li><p>所以例子中的寄存器既可以被看成一个字(大小为20000),也可以看成两个独立的字节(分别是78和32)</p></li></ul></li></ul></li><li><p>汇编指令</p><ul><li>举几个指令的例子<table><thead><tr><th align="left">汇编指令</th><th align="left">控制CPU的操作</th><th align="left">高级语言描述</th></tr></thead><tbody><tr><td align="left">mov ax,18</td><td align="left">将18送入寄存器AX</td><td align="left">AX=18</td></tr><tr><td align="left">mov ah,78</td><td align="left">将78送入寄存器AH</td><td align="left">AH=78</td></tr><tr><td align="left">add ax,8</td><td align="left">将寄存器AX的值加8</td><td align="left">AX=AX+8</td></tr><tr><td align="left">mov ax,bx</td><td align="left">将寄存器BX的值送入AX</td><td align="left">AX=BX</td></tr></tbody></table></li></ul></li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ol><li>mov ax,62627        AX = <u>F4A3H</u>   <font color="orange">#AX为16位寄存器，只能存放4位十六进制的数据,H代表十六进制</font></li><li>mov ah,31H        AX = <u>31A3H</u></li><li>mov al,23H        AX = <u>3123H</u></li><li>add ax,ax        AX = <u>6246H</u></li><li>mov bx,826CH        BX = <u>826CH</u></li><li>mov cx,ax        CX = <u>6246H</u></li><li>mov ax,bx        AX = <u>826CH</u></li><li>add ax,bx        AX = <u>04D8H</u></li><li>mov al,bh        AX = <u>0482H</u></li><li>mov ah,bl       AX = <u>6C82H</u></li></ol><p>关于十六进制的运算,请参考另一篇博客 <a href="/2021/02/01/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8F%8A%E8%BF%90%E7%AE%97/" title="十六进制的转换及运算">十六进制的转换及运算</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言1</title>
      <link href="2021/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801/"/>
      <url>2021/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801/</url>
      
        <content type="html"><![CDATA[<blockquote><p>One man’s ‘magic’ is another man’s engineering.<br>– Robert Heinlein</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这个系列的笔记是关于汇编语言的学习，所用的教材是清华大学出版社出版的<em>汇编语言</em>。主要内容就是来自教科书中的重要概念，练习题以及实验。这本书采用8086CPU来进行教学，学习中用到了DOSBox这款软件。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>汇编语言的核心是汇编指令，汇编语言工作的过程如图：</p><img src="/2021/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801/ass.png" class><ol><li><p>存储器</p><ul><li>又称为内存</li><li>存放指令和数据</li></ul></li><li><p>指令和数据</p><ul><li>是应用上的概念(二进制信息)</li><li>比如，内存中的二进制信息1000100111011000，计算机可以把它看成大小为89D8H的数据，也可以看作是指令 mov ax,bx来执行</li><li>1000100111011000 -&gt; 89D8H (数据)， 1000100111011000 -&gt; mov ax,bx(程序)</li></ul></li><li><p>存储单元<br>|   |   |   |   |   |   |   |   |<br> 0    1   2    …   125  126  127</p><ul><li>存储器被分成若干个存储单元，如一个存储器有128个存储单元，编号从0 - 127</li><li>一个单元可以存储一个byte(8bits), 比如0001 0001。上面的存储器的大小就是128个字节</li><li>1KB=1024B, 1MB=1204KB,1GB=1024MB,1TB=1024GB (B代表Byte)</li></ul></li><li><p>CPU对存储器的读写</p><ul><li>CPU需要和芯片交互3种信息<ol><li>存储单元的地址(地址信息)</li><li>器件的选择，读或写的命令(控制信息)</li><li>读或写的数据(数据信息)</li></ol></li><li>CPU和内存在物理上通过导线交互，通常称为总线；在逻辑上分为地址总线，控制总线和数据总线<img src="/2021/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801/ass2.png" class>上图的具体步骤为:<ol><li>CPU通过地址总线讲地址信息3发出</li><li>CPU通过控制总线发出内存读命令，选中单元，并通知</li><li>存储器将3号单元中的数据08通过数据线送入CPU</li></ol></li><li>举例:<br>  机器码：10100001 00000011 00000000<br>  对应汇编：MOV AX,[3]<br>  含义：传送3号单元的内容到AX</li></ul><p>下面分别对这3个总线进行解释:</p></li><li><p>地址总线</p><ul><li><p>用来指定存储器单元，传送一条信息对应一个单元</p></li><li><p>如果一个CPU有10根地址总线，用二进制表示，就可以传输2^10 = 1024个不同的数据(0-1023)</p></li><li><p>下图展示了具有10根地址线的CPU向内存发出信息地址11时，10根地址线上传送的二进制信息</p><img src="/2021/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801/ass3.png" class></li></ul></li><li><p>数据总线</p><ul><li><p>数据总线的宽度决定了CPU和外界传输的速度，8根总线可以传送一个8位二进制(一个字节)</p></li><li><p>下图展示了8086CPU有16根数据总线，可以传输16位数据</p><img src="/2021/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801/ass4.png" class></li></ul></li><li><p>控制总线</p><ul><li>一根控制总线代表着CPU对外设的一种控制，宽度决定了CPU的控制能力</li><li>读和写操作分别有两根控制线负责。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">汇编指令是机器指令的助记符</span><br><span class="line">每一种CPU都有自己的汇编指令集</span><br><span class="line">CPU可以使用的信息在存储器中存放</span><br><span class="line">在存储器中指令和数据没有区别，都是二进制信息</span><br><span class="line">存储单元从0开始顺序编号</span><br><span class="line">一个存储单元可以存储8个bit,即8位二进制数</span><br><span class="line">1B &#x3D; 8bit, 1KB &#x3D; 1024B, 1MB &#x3D; 1024KB, 1GB &#x3D; 1024 MB</span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>文中所有的概念和图片均来自于王爽的<em>汇编语言</em></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>freeRTOS实时操作系统</title>
      <link href="2021/01/30/freeRTOS%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/01/30/freeRTOS%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>It is not the mountain we conquer but ourselves.<br>– Sir Edmund Hillary</p></blockquote><p>这是一篇总结自己在实习的时候最开始接触的一个项目：把freeRTOS操作系统移植到VEGAboard-一款以RISC-V为架构的开发板。大概是这个样子的：</p><img src="/2021/01/30/freeRTOS%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/vegaboard.jpg" class><p>关于硬件方面以及RISCV指令集，在这篇文章里不会提到。本篇的主要内容是对freeRTOS内核代码的简介，包括从硬件上电到主程序运行的过程。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>FreeRTOS的源码主要可以分成三大部分：1.用于处理任务（task）的代码，有大概一半的freeRTOS的代码用来处理task。其中task.c和task.h文件做了大部分创建和管理任务的工作。2.不同task之间的交流，在queue.c和queue.h文件里，任务或者中断之间可以互相发送数据以及使用semaphores和mutexes来通信和共享信息。3.还有一部分代码是用来沟通软件和硬件之间的代码，如port.c 和portasm.s。本文是以官方提供的blinky demo来举例。</p><h2 id="初始化和复位"><a href="#初始化和复位" class="headerlink" title="初始化和复位"></a>初始化和复位</h2><p>当开发板通电后，驱动程序（device driver）里的startup，以及链接文件用来初始化和复位：</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Reset Handler */</span></span><br><span class="line"><span class="symbol">Reset_Handler:</span></span><br><span class="line">    <span class="comment"># Disable global interrupt. */</span></span><br><span class="line">    csrci mstatus, <span class="number">8</span></span><br><span class="line">    <span class="comment"># initialize stack pointer</span></span><br><span class="line">    la <span class="built_in">sp</span>, __StackTop</span><br><span class="line">    <span class="comment"># initialize global pointer</span></span><br><span class="line">    la gp, __global_pointer</span><br></pre></td></tr></table></figure><p>为了保证整个startup的过程不受外设中断的影响，Reset_Handler首先会关闭全局中断(disable),然后初始化堆栈指针（la sp,__StackTOP)。紧接着，程序会执行SystemInit函数，这个函数的功能主要是相关寄存器的复位以及时钟的初始化，包括关闭看门狗(watchdog),初始化中断向量表的地址。在systemInit()中，下面的两行代码把Flash中的代码拷贝到RAM中运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy_section(&amp;__etext, &amp;__data_start__, &amp;__data_end__);</span><br><span class="line">zero_section(&amp;__bss_start__, &amp;__bss_end__);</span><br></pre></td></tr></table></figure><p>然后跳转到main函数。</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable global interrupt. */</span></span><br><span class="line"><span class="symbol">csrsi</span> mstatus, <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">jal</span> main</span><br></pre></td></tr></table></figure><p>连接文件（RV32M1_ri5cy_flash.ld）用来初始化C语言的堆栈。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   .data : AT(__DATA_ROM)</span><br><span class="line"> &#123;</span><br><span class="line">   . &#x3D; ALIGN(4);</span><br><span class="line">   __DATA_RAM &#x3D; .;</span><br><span class="line">   __data_start__ &#x3D; .;      &#x2F;* create a global symbol at data start *&#x2F;</span><br><span class="line">   *(.data)                 &#x2F;* .data sections *&#x2F;</span><br><span class="line">   *(.data*)                &#x2F;* .data* sections *&#x2F;</span><br><span class="line">   *(.sdata .sdata.*)</span><br><span class="line">   *(.heapsram*)            &#x2F;* This is only for the pulpino official test code. *&#x2F;</span><br><span class="line">   __noncachedata_start__ &#x3D; .;   &#x2F;* create a global symbol at ncache data start *&#x2F;</span><br><span class="line">*(NonCacheable)</span><br><span class="line">   __noncachedata_end__ &#x3D; .;     &#x2F;* define a global symbol at ncache data end *&#x2F;</span><br><span class="line">   KEEP(*(.jcr*))</span><br><span class="line">   . &#x3D; ALIGN(4);</span><br><span class="line">   __data_end__ &#x3D; .;        &#x2F;* define a global symbol at data end *&#x2F;</span><br><span class="line"> &#125; &gt; m_data</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>.data 是C语言中已经初始化的变量，.bss是没有初始化的变量，没有初始化的值为零。以上就完成了变量的初始化。</p><h2 id="接口文件"><a href="#接口文件" class="headerlink" title="接口文件"></a>接口文件</h2><p>操作系统的内核代码（如task.c）通过port.c,portASM.S等文件与底层硬件交流。比如在task.h中有以下一行代码是使一个任务进入critical section来防止其他的任务进入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> taskENTER_CRITICAL()               portENTER_CRITICAL()</span></span><br></pre></td></tr></table></figure><p>这里的portENTER_CRITICAL()就是在portmarco.h里定义的，这样就使得task.c不用与底层的硬件交流，对于不同的硬件设备只需要更改port文件就可以。<br>portASM.S 是一个汇编接口文件，这个文件适用于所有的芯片。但它包含了一个特定于某个芯片的头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;freertos_risc_v_chip_specific_extensions.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>比如在本文中的demo里，这个头文件包含了针对RISC-V-RV32的一些额外寄存器的存储以及复位。这样就可以解决不同的芯片需要一些不同的寄存器。</p><h2 id="安排任务"><a href="#安排任务" class="headerlink" title="安排任务"></a>安排任务</h2><p>每一个任务需要被指定一个优先级，这个优先级的数字从0 到 configMAX_PRIORITIES-1 （在freeRTOSConfig.h里被定义）。如果configMAX_PRIORITIES被设置为5，那么每个任务可以使用0（最低），1，2，3，4（最高）作为优先的等级。<br>FreeRTOS使用一个准备列表（ready list）来收集所有准备运行的任务。定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PRIVILEGED_DATA <span class="keyword">static</span> List_t pxReadyTasksLists[ configMAX_PRIORITIES ];</span><br></pre></td></tr></table></figure><p>比如，pxReadyTasksLists[1]是所有优先级为1且准备运行任务的列表。<br>vTaskSwitchContext()函数会终止现在的任务而选择优先级更高的任务然后把这个任务放入pxCurrentTCB：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> taskSELECT_HIGHEST_PRIORITY_TASK()                                </span></span><br><span class="line">&#123;                                                                         </span><br><span class="line">    UBaseType_t uxTopPriority = uxTopReadyPriority;                       </span><br><span class="line">                                                                          </span><br><span class="line">    <span class="comment">/* Find the highest priority queue that contains ready tasks. */</span>      </span><br><span class="line">    <span class="keyword">while</span>( listLIST_IS_EMPTY( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) ) </span><br><span class="line">    &#123;  </span><br><span class="line">        configASSERT( uxTopPriority );                                    </span><br><span class="line">        --uxTopPriority;                                                  </span><br><span class="line">    &#125;                                                                     </span><br><span class="line">                                                                          </span><br><span class="line">    <span class="comment">/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of </span></span><br><span class="line"><span class="comment">     * the  same priority get an equal share of the processor time. */</span>                    </span><br><span class="line">    listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;( pxReadyTasksLists[ uxTopPriority ] ) ); </span><br><span class="line">    uxTopReadyPriority = uxTopPriority;                                                   </span><br><span class="line">&#125; <span class="comment">/* taskSELECT_HIGHEST_PRIORITY_TASK */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的函数确保了优先级高的任务先执行，首先要确保uxTopReadyPriority大于或等于有最高优先级的等待任务。在while循环里，从uxTopReadyPriority优先级开始，在pxReadyTasksLists[]里寻找准备任务的最高优先级。listGET_OWNER_OF_NEXT_ENTRY()函数可以从ready list里抓取下一个任务。<br>接下来pxCurrentTCB 指向最高优先级的任务，vTaskSwitchContext()就会使硬件执行任务。</p><h2 id="建立任务"><a href="#建立任务" class="headerlink" title="建立任务"></a>建立任务</h2><p>xTaskCreate用于创建新的任务。每一个任务都会有一个对应的TCB(task control block),TCB包含了任务的信息，包括任务名称，优先级，内存地址等。这些TCB都储存在一个堆栈里，pxPortInitialiseStack()函数会在新任务准备运行之前初始化堆栈。<br>以官方提供的demo为例(C:\FreeRTOS_RISCV\FreeRTOS\Demo\RISC-V_RV32M1_Vega_GCC_Eclipse\projects\RTOSDemo_ri5cy)。在main.c文件里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">prvSetupHardware();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The mainCREATE_SIMPLE_BLINKY_DEMO_ONLY setting is described at the top</span></span><br><span class="line"><span class="comment">of this file. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>( mainCREATE_SIMPLE_BLINKY_DEMO_ONLY == 1 )</span></span><br><span class="line">&#123;</span><br><span class="line">main_blinky();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">&#123;</span><br><span class="line">main_full();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>首先prvSetupHardware()用来初始化硬件，然后调用在main_full.c里的main_full()函数（因为mainCREATE_SIMPLE_BLINKY_DEMO_ONLY被设为0）。<br>在main_full()中，有三个任务被创建,其中前两个是 ‘register check’,用来检查register是否正常，他们被设置为最低优先级，以便被其他的任务覆盖。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xTaskCreate( prvRegTestTaskEntry1, <span class="comment">/* The function that implements the task. */</span></span><br><span class="line"><span class="string">&quot;Reg1&quot;</span>, <span class="comment">/* The name of the task. */</span></span><br><span class="line">mainREG_TEST_STACK_SIZE_WORDS,  <span class="comment">/* Size of stack to allocate for the task - in words not bytes!. */</span></span><br><span class="line">mainREG_TEST_TASK_1_PARAMETER,  <span class="comment">/* Parameter passed into the task. */</span></span><br><span class="line">tskIDLE_PRIORITY, <span class="comment">/* Priority of the task. */</span></span><br><span class="line"><span class="literal">NULL</span> );<span class="comment">/* Can be used to pass out a handle to the created task. */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>prvCheckTask()是用来检查所有的demo 任务以及上面的两个register check。当程序运行的时候，prvCheckTask()会在终端显示中打印一个 ‘pass’并且每成功一个循环(所有的demo和2个register test)都会打印一个 ‘.’，而且LED灯闪烁一次。最后 vTaskStartScheduler()使最高优先级的任务进入running mode(运行)。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了硬件上电后初始化的代码(主要为汇编代码)，链接硬件和软件的接口文件(port)。以及最基础的任务运行原理(高优先级替换低优先级)。经过一段时间的学习，我对freeRTOS及操作系统的理解还相对较浅。随着项目的深入和学习，更多关于此话题的文章会更新。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
