<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BFS&amp;DFS算法</title>
      <link href="2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/"/>
      <url>2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>最近遇到问题比较多的算法及其应用，广度优先和深度优先算法，本篇博客的目的是重新梳理一下这两种算法，整理常见的相关算法题。</p><p>两种算法都是图论里的图搜索算法，用来遍历图的每一个结点。</p><h2 id="BFS-广度优先搜索"><a href="#BFS-广度优先搜索" class="headerlink" title="BFS(广度优先搜索)"></a>BFS(广度优先搜索)</h2><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/bfs1.png" class><p>给出以上的一个图，这个图一共有7个结点，假设起点为1，现在要用广度优先搜索来遍历所有的结点。可以从名字中看出，是广度优先，所以第一次的查找就是与起点1相邻的所有点:</p><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/bfs2.png" class><p>蓝色的点为起点，红色的点是已经遍历到的点，所以第一次搜索的结果为2，4，5。<br>第二次搜索可以从上次搜索结果的任意一点开始，这里我们从最小的值2开始。</p><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/bfs3.png" class><p>绿色的点是第二次搜索的结果，结果为3，6，7，这时所有的点都已经遍历，所以广度优先搜索就完成了。所以整个搜索过程所遍历的结点为 1，2，4，5，3，6，7。<br>对于广度优先搜索，一旦找到某个结点的所有邻居后，这个结点就不会再用到，所以可以用队列(queue)这种先进先出的存储方式来记录结点的过程。</p><p>接下来通过一个稍微复杂的例子，完整的记录下广度优先搜索的过程:</p><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/bfs4.png" class><p>整个过程为下图:</p><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/bfs5.png" class><p>这里需要设置一个数组用来储存已经访问过的结点，还有一个队列用来记录，每一个新的结点都会进入队列，当这个结点寻找所有邻居结点前，先要出列，并且记录到已访问的结点。大概的过程就是1-&gt; 4,2,  4-&gt;3, 2-&gt;5,7,8, 3-&gt;9,10, 5-&gt;6。</p><p>用c++实现bfs</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nodes;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;*adjMat;</span><br><span class="line">    <span class="keyword">bool</span> *visited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Graph(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nodes=n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;adjMat = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;[n];</span><br><span class="line">        <span class="keyword">this</span>-&gt;visited=<span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;adjMat[u].push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graph::bfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;nodes;i++)&#123;</span><br><span class="line">        visited[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(n);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> cur=q.front();</span><br><span class="line">        visited[cur]=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;cur&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(it=adjMat[cur].begin();it!=adjMat[cur].end();it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[*it])</span><br><span class="line">                q.push(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">    g.addEdge(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    g.addEdge(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    g.addEdge(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    g.addEdge(<span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    g.bfs(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS(深度优先搜索)"></a>DFS(深度优先搜索)</h2><p>以上一个图为例，深度优先搜索的第一次搜索为: 1,4,3,10</p><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/dfs1.png" class><p>当10不能再继续搜索的时候，需要回到上一个点3，然后搜索，结果为9</p><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/dfs2.png" class><p>9 不能接续搜索，再次回到3,接下来搜2的最大深度:</p><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/dfs3.png" class><p>到这里所有的结点都已经被访问。<br>深度优先用栈(stack)来记录结点。整个过程为:</p><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/dfs4.png" class><p>用C++实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nodes;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;*adjMat;</span><br><span class="line">    <span class="keyword">bool</span> *visited;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Graph(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nodes=n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;adjMat = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;[n];</span><br><span class="line">        <span class="keyword">this</span>-&gt;visited=<span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;adjMat[u].push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Graph::dfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;nodes;i++)&#123;</span><br><span class="line">        visited[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.push(n);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> cur=s.top();</span><br><span class="line">        visited[cur]=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;cur&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">for</span>(it=adjMat[cur].begin();it!=adjMat[cur].end();it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[*it])</span><br><span class="line">                s.push(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">    g.addEdge(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    g.addEdge(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    g.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    g.addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    g.addEdge(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    g.addEdge(<span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    g.dfs(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法比较"><a href="#算法比较" class="headerlink" title="算法比较"></a>算法比较</h2><p>在一般的算法问题中，两种算法都可以使用，只是在特定的情况下各有优劣。</p><p>广度优先搜索:</p><ul><li><p>优点:</p><ul><li>对于解决最短或长最少问题有效，搜寻深度小</li><li>每个结点只访问一次，结点总是以最短路径被访问。</li></ul></li><li><p>缺点:</p><ul><li>内存耗费较大(需要大量的数组单元来存储)</li></ul></li></ul><p>广度优先算法更适合在较大范围或不断扩大遍历范围找到相对最优解。比如走迷宫的最短路径，计算机网络数据链路层最短跳数。</p><p>深度优先搜索:</p><ul><li><p>优点:</p><ul><li>能找出所有解决方案</li><li>内存需求较少</li></ul></li><li><p>缺点：</p><ul><li>需要多次遍历，在时间方面效率不高</li></ul></li></ul><p>深度优先适合有明确目标或范围较小的情况。</p><h2 id="相关算法应用"><a href="#相关算法应用" class="headerlink" title="相关算法应用"></a>相关算法应用</h2><p>如果把图看成数的结构的话，那么广度优先搜索就可以表示二叉树的层序遍历，深度优先搜索就可以表示前序遍历。<br>举例：一个二叉树为</p><img src="/2021/06/18/BFS-DFS%E7%AE%97%E6%B3%95/bt.png" class><ul><li>层序: [3,9,20,null,null,15,7]</li><li>前序: [3,9,20,15,null,null,7]</li><li>中序: [null,9,null,3,15,20,7]</li><li>后序: [null,null,9,15,7,20,3]</li></ul><p>用广度优先算法实现二叉树的层序遍历:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设树结点的数据结构已经给出</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root); <span class="comment">//首先把跟结点加入队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> curSize=q.size();</span><br><span class="line">        ans.push_back(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ());<span class="comment">//记录每一层的结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=curSize;++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> node=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            ans.back().push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; <span class="comment">// [[3],[9,20],[15,7]]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用深度优先实现二叉树的前序遍历:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">        s.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* cur = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        ans.push_back(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">            s.push(cur-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">            s.push(cur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer笔记</title>
      <link href="2021/06/14/C-Primer%E7%AC%94%E8%AE%B0/"/>
      <url>2021/06/14/C-Primer%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h2><h3 id="运算类型"><a href="#运算类型" class="headerlink" title="运算类型"></a>运算类型</h3><p><strong>(Arithmetic types)</strong></p><img src="/2021/06/14/C-Primer%E7%AC%94%E8%AE%B0/arithmetic.png" class><p><strong>运算类型分为两大类：整数类型（包括bool和char)和浮点类型。</strong><br>对于整数类型的大小，语言保证了short &lt;= int &lt;= long &lt;=long long。<br>对于浮点类型, float通常代表一个字(32bits),double代表两个字(64bits)，long double代表三个或四个字（96 or 128bits)。float和double分别产生7和16位有效数字。</p><h3 id="有符号和无符号类型"><a href="#有符号和无符号类型" class="headerlink" title="有符号和无符号类型"></a>有符号和无符号类型</h3><p><strong>(signed and unsigned types)</strong></p><p>除了bool和拓展的char类型(不包括char)，其他的整数类型都可以分为有符号的和无符号的。有符号的整数可以为负数或正数，无符号的整数只能为正数。int,short,long,long long都是有符号的，在其前面加上unsigned就变成无符号的，比如 unsigned long;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">-1</span>; <span class="comment">//unsigned是大于0的</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//打印出来并不是-1</span></span><br></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//conversion</span></span><br><span class="line"><span class="keyword">bool</span> b =<span class="number">42</span>;<span class="comment">// b is 1(true). the result is false if 0 and true otherwise</span></span><br><span class="line"><span class="keyword">int</span> i=b;  <span class="comment">//i=1</span></span><br><span class="line">i=<span class="number">3.14</span>; <span class="comment">//i=3</span></span><br><span class="line"><span class="keyword">double</span> pi=i; <span class="comment">//pi=3.0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c = <span class="number">-1</span>; <span class="comment">//假设一个char为8bits,c=255</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> c2=<span class="number">256</span>; <span class="comment">//假设一个char为8bits，c2 is undefined</span></span><br></pre></td></tr></table></figure><ul><li>如果给unsigned 赋值一个超出数据类型范围的值，如第六行，那么所得的值就是(unsigned)(赋值) % 256。在本例中就是(unsigned)-1 % 256 = 255</li><li>如果如果给signed<br>赋值一个超出数据类型范围的值，如第七行，那么就是undefined,可能为0，也可能出错。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>尽管都是用=符号来表示，初始化(initialize)和赋值(assignment)是两个不同的概念。初始化是在变量创建的时候给予一个值，赋值是消除对象现有的值并替换成一个新的值。<br>四种初始化方法:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中&#123;&#125;稍微特殊一点，如果初始化可能出现数据丢失的情况，那么就报错，比如</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld=<span class="number">3.1415926</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;ld&#125;,b=&#123;ld&#125;;<span class="comment">//错误</span></span><br><span class="line">int c(ld),d=ld; //允许，不过数据会消减</span><br></pre></td></tr></table></figure><h3 id="变量的声明和定义"><a href="#变量的声明和定义" class="headerlink" title="变量的声明和定义"></a>变量的声明和定义</h3><p><strong>(declarations and definitions)</strong></p><p>C++是可以多个文件共同编译的，也就意味着一个文件里可能会用到另一个文件里的变量，比如std::cout和std::cin就是来自于标准库的对象。<br>在C++中，有声明和定义这两个概念。声明就是当一个文件想用在另一个文件中定义的对象，声明明确了一个变量的名称和类型；定义就是创建了相关对象，定义在名称和类型之上，还分配了存储空间(可能会初始化）。<br><strong>定义一定是声明，但声明不一定是定义。</strong><br>为了获得一个声明而不是定义的变量，我们可以在前面加上一个关键字extern，但是不能初始化:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">//声明但没有定义i</span></span><br><span class="line"><span class="keyword">int</span> j; <span class="comment">//声明和定义j</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只要有初始化的值都是定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi=<span class="number">3.14</span>;<span class="comment">//定义，但是不能在函数中使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi=<span class="number">3.14</span>; <span class="comment">//错误</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>变量只能被定义一次，但可以被声明多次。</strong></p><p>在多个文件中，一个变量只能在一个文件中定义，其他文件使用这个变量的时候只能声明，不能定义。</p><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> reused=<span class="number">42</span>; <span class="comment">//global scope</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> unique=<span class="number">0</span>;<span class="comment">//block scope, can only used inside &#123;&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;reused&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;unique&lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//42 0</span></span><br><span class="line">    <span class="keyword">int</span> reused=<span class="number">0</span>; <span class="comment">//new, local object named reused</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;reused&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;unique&lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//0 0</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;::reused&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;unique&lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//42 0 使用全局变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">100</span>,sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 100 45</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h3><p>const 提供了一种只读的变量，也就是不可修改。用来定义像buffer size这样固定不变的值。<br>const变量必须要初始化且不能更改。<br>在默认情况下，const对象只能在本文件使用(local to the file)。为了在多个文件中使用同一个const,需要在定义和声明的时候都加一个关键字extern:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bufsize=<span class="number">512</span>; <span class="comment">//只能在本文件使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//file1.cpp 定义一个可被其他文件使用的const</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufsize=fcn();</span><br><span class="line"></span><br><span class="line"><span class="comment">//file1.h文件中可以使用file1.cpp里定义的bufsize</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufsize;</span><br></pre></td></tr></table></figure><p><strong>引用一个const</strong></p><p>引用一个const和引用一个普通变量是不一样的，首先引用的类型要和const一样，且也不能改变</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1=ci; <span class="comment">//ok, both are const</span></span><br><span class="line">r1=<span class="number">42</span>; <span class="comment">//错误，r1也是一个const 不能更改</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2=ci; <span class="comment">//错误。非const不能引用一个const</span></span><br></pre></td></tr></table></figure><p><strong>引用const的初始化</strong></p><p>引用const初始化的类型几乎是所有类型（只要能满足初始化的类型能够转化成所引用的类型)，比如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1=i; <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2=<span class="number">42</span>; <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3=r1*<span class="number">2</span>; <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4= r1*<span class="number">2</span>; <span class="comment">//error.因为r4是一个nonconst</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dval=<span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri=dval;  <span class="comment">//ok,只不过这里的ri变为了3</span></span><br></pre></td></tr></table></figure><p><strong>指针和const</strong><br>和引用相似，指向一个const意味着这个指针不能再指向别的地方。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="number">3.14</span>; <span class="comment">//pi是一个const,它的值不能改变</span></span><br><span class="line"><span class="keyword">double</span> *ptr=&amp;pi;  <span class="comment">//错误，ptr只是一个普通的指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr=&amp;pi; <span class="comment">//ok</span></span><br><span class="line">*cptr=<span class="number">42</span>; <span class="comment">//错误，不能改变值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dval=<span class="number">3.14</span>; <span class="comment">//dval是double,可以改变值</span></span><br><span class="line">cptr = &amp;dval; <span class="comment">//ok，但是不能通过cptr改变dval</span></span><br></pre></td></tr></table></figure><p>const指针<br>pointer本身也可以是const</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> errNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr=&amp;errNum; <span class="comment">//curErr will always point to errNum</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip=&amp;pi; <span class="comment">//pip is a const pointer to a const object</span></span><br></pre></td></tr></table></figure><p>对于过长的声明，我们可以从右到左来理解。举一个例子，第二行代码，curErr是名字，它的左边是const，说明curErr是一个const对象，再往左是 * ， 说明curErr是一个const指针，最后是int，说明curErr是一个指向int类型的const指针。<br>同样的,pip是一个指向const double类型的一个const pointer。</p><p>const pointer只能说明这个指针指向的位置不能改变，并不代表所指向的值不能改变，所指向的值取决于它的类型，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*pip = <span class="number">2.72</span>; <span class="comment">//error.因为pip所指向的值是一个const</span></span><br><span class="line"><span class="comment">//如果curErr指向的值(errNum)是非0</span></span><br><span class="line"><span class="keyword">if</span>(*curErr)&#123;</span><br><span class="line">    errorHandler();</span><br><span class="line">    *curErr = <span class="number">0</span>; <span class="comment">//ok, 改变errNum的值为0.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C/C++指针和引用</title>
      <link href="2021/06/07/C-C-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/"/>
      <url>2021/06/07/C-C-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>对我来说，C/C++语言中最大的难点就是指针和引用的概念及其应用，为了更好更深入的理解，我找到三本包含C/C++指针和引用的教科书。这篇文章是根据几本经典教材 <em>(reference在文末）</em>，以及网上的一些资料加上自己的理解整理而成。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>内存和地址</strong><br>我们可以把计算机的内存看作一条长街上的一排房屋，每个房屋都可以容纳数据，且有一个独特的房号来标识别。比如：</p><pre>  0   1   2   3  ...｜  ｜  ｜  ｜  ｜ ...</pre><p>这些位置的每一格都被称为字节(byte)，每个字节都包含了存储一个字符所需要的位数。在许多现代机器上(64位),每个字节包含8个位，可以存储无符号值0 - 255，或有符号值 -127 - 128。<br>为了存储更大的值，我们可以把两个或多个字节结合在一起作为一个更大的内存单位。比如</p><pre>    0     4    8   |    |    |    | </pre><p>上图是以4字节的字来表示，内存位置与图一相同。这时每个字(每一格)可以容纳无符号整数范围是 0-4294967295(2^32-1),有符号的整数范围是-2^31 - 2^31-1。<br>总结下来有两点需要注意：</p><ol><li>内存中的每个位置由一个独一无二的地址标识。</li><li>内存中的每个位置都包含一个值。</li></ol><p>需要注意的一点是：名字/编号与内存位置之间的关联并不是由硬件来提供的，而是由编译器为我们实现的。变量给了我们更方便的方法记住地址- <strong>硬件仍然通过地址访问内存地址</strong>。</p><p><strong>指针的定义为：一个存储其他变量地址的变量。</strong></p><p><strong>表达方式</strong></p><ul><li>指针: int * a =b, a 指向b的值。</li><li>在C语言中&amp;符号的代表着取址，这和C++中引用的概念不一样。<br>下面举一个例子：<pre>一段内存地址与值：a    b     c           d     e|112 | -1 | 107852331|100 |108  |a-b是地址的名称，他们分别对应的地址是 a=100,b=104,c=108,d=112,e=116</pre>接下来给出一些声明：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">112</span>,b=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">float</span> c=<span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> *d=&amp;a;  </span><br><span class="line"><span class="keyword">float</span> *e=&amp;c;</span><br></pre></td></tr></table></figure>那么结果为:<table><thead><tr><th align="left">表达式</th><th align="left">右值</th><th align="left">类型</th></tr></thead><tbody><tr><td align="left">a</td><td align="left">112</td><td align="left">int</td></tr><tr><td align="left">b</td><td align="left">-1</td><td align="left">int</td></tr><tr><td align="left">c</td><td align="left">3.14</td><td align="left">float</td></tr><tr><td align="left">d</td><td align="left">100</td><td align="left">int *</td></tr><tr><td align="left">e</td><td align="left">108</td><td align="left">float *</td></tr><tr><td align="left">*d</td><td align="left">112</td><td align="left">int</td></tr><tr><td align="left">*e</td><td align="left">3.14</td><td align="left">float</td></tr></tbody></table></li></ul><p>需要注意的是，d和e被声明为指针并不改变这些表达式的求值方式:一个变量的值就是分配给这个变量内存位置所存储的值。* d的值为112，是因为* d = &amp;a, 可以理解为a地址的内容。因此，d是一个指向整数的指针，* d是一个整数。<br>通过C代码来更一步的了解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a; <span class="comment">//声明一个整数a</span></span><br><span class="line">    <span class="keyword">int</span> *P; <span class="comment">//声明一个指针P</span></span><br><span class="line">    P=&amp;a; <span class="comment">//P 等于 a的地址</span></span><br><span class="line">    a=<span class="number">5</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address of a: %p\n&quot;</span>,&amp;a); <span class="comment">// a的地址，会打印一个十六进制的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address stored in pointer P: %p\n&quot;</span>,P); <span class="comment">//跟上一行打印的一样</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value of *P: %d\n&quot;</span>,*P); <span class="comment">//5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address of P: %p\n&quot;</span>,&amp;P); <span class="comment">//指针P的地址，也是一个十六进制数字</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    *P=<span class="number">8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value of a: %d\n&quot;</span>,a); <span class="comment">//8， a的值变为8</span></span><br><span class="line">    <span class="comment">//因为P是一个地址， *P表示P所指向的地址的值，也就是a</span></span><br><span class="line">    a=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value of a: %d\n&quot;</span>,*P); <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">20</span>; <span class="comment">//定义一个新的整数b=20</span></span><br><span class="line">    *P=b;   <span class="comment">//只是把P所指向地址的值改为20，即a改为20</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address stored in P is %p\n&quot;</span>,P); <span class="comment">//a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value at P is %d\n&quot;</span>,*P); <span class="comment">//20</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value of a: %d\n&quot;</span>,a); <span class="comment">//20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针的类型和运算"><a href="#指针的类型和运算" class="headerlink" title="指针的类型和运算"></a>指针的类型和运算</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    p=&amp;a;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of integer is %d\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">//查看变量int的大小，为4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address stored in p: %d\n&quot;</span>,p); <span class="comment">//打印出p所指向的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address stored in p+1: %d\n&quot;</span>,p+<span class="number">1</span>); <span class="comment">//打印出原来p所指向地址的下一个地址， 比上面的地址大4。 如上一个地址是64，这次打印的就是68</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value at address p+1 is %d\n&quot;</span>,*(p+<span class="number">1</span>)); <span class="comment">//会产生一个随机数，因为在p+1地址上我们并没有定义一个整数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1025</span>;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    p=&amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address at p = %d, value = %d\n&quot;</span>,p,*p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *p0; <span class="comment">//声明一个类型为char的指针</span></span><br><span class="line">    p0=(<span class="keyword">char</span> *)p; <span class="comment">//p0指向和p同一个地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of char is %d byte(s)\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)); <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address at p0 = %d,value = %d\n&quot;</span>,p0,*p0); <span class="comment">//p0的地址和p一样，但是这里的 *p0=1</span></span><br><span class="line">    <span class="comment">//原因如下：1025 如果用32位的二进制表示的话就是</span></span><br><span class="line">    <span class="comment">// 00000000 00000000 00000100 00000001 -&gt; 1+1x2^10 = 1025，总共有4个字节</span></span><br><span class="line">    <span class="comment">//因为p0指向和p相同的地址，而p0是char，只有一个字节的大小，</span></span><br><span class="line">    <span class="comment">//所以p0 只读到了 00000001,即1. (从最低为开始读)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address at p0+1 = %d,value = %d\n&quot;</span>,p0+<span class="number">1</span>,*(p0+<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//p0+1指向的地址比p0大1，这时*(p0+1)=4,因为这时读取第二个字节，也就是00000100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> **q; <span class="comment">// pointer to pointer</span></span><br><span class="line">    q=&amp;p;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p); <span class="comment">//5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address stored in p %d\n&quot;</span>,p); <span class="comment">// x的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*q); <span class="comment">// 指向指针p的值，p的值也就是x的地址，和上面一样</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(*q));<span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常绕，需要多看几遍，多敲几次代码！</p><h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">1</span>&#125;; <span class="comment">// 5x4=20 bytes in total， 数组</span></span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    p=A;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A);  <span class="comment">//数组A第一个元素的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;A[<span class="number">0</span>]); <span class="comment">//数组A第一个元素的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A[<span class="number">0</span>]); <span class="comment">//2，第一个元素的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*A); <span class="comment">//2，第一个元素的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(A+i)); <span class="comment">//2，4，5，8，1 遍历数组</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="C-中的引用-references"><a href="#C-中的引用-references" class="headerlink" title="C++中的引用(references)"></a>C++中的引用(references)</h2><p>声明引用就是某一变量的别名，对引用的操作与对变量直接操作完全一样。与C语言不同， &amp;不是求地址运算，而是起标识作用。比如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival=<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal=ival; <span class="comment">//refVal 是ival的引用，即别名</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal2; <span class="comment">//错误，声明引用必须对其进行初始化。</span></span><br></pre></td></tr></table></figure><ul><li>引用必须对其进行初始化</li><li>声明一个引用，不是定义了一个新变量，它只表示该引用名是目标变量的一个别名，它本身不是一个数据类型，因此不占用存储单元，系统也不会给分配存储单元。所以对引用求地址，就是对目标变量求地址，即 refVal= ival=1024; &amp;refVal=&amp;ival (地址)。</li><li>不能建立数组的引用。因为数组是由若干个元素组成的集合，所以无法建立一个数组的别名。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">refVal=<span class="number">2</span>; <span class="comment">// 给refVal所引用的赋值2，也就是给ival赋值为2</span></span><br><span class="line"><span class="keyword">int</span> ii = refVal; <span class="comment">// 等同于 ii=ival</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal3 = refVal; <span class="comment">// refVal3是refVal的引用，也就是ival的引用</span></span><br><span class="line"><span class="keyword">int</span> i = refVal; <span class="comment">// 初始化i的值为ival</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>定义引用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1024</span>,i2=<span class="number">2048</span>; <span class="comment">//i and i2 both ints</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = i, r2=i2; <span class="comment">//r is a reference bound to i; r2 is an int</span></span><br><span class="line"><span class="keyword">int</span> i3=<span class="number">1024</span>,&amp;ri=i3; <span class="comment">//i3 is int, ri is a reference bound to i3</span></span><br><span class="line"><span class="keyword">int</span> &amp;r3=i3,&amp;r4=i2; <span class="comment">// both r3 and r4 are references</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;refVal4=<span class="number">10</span>; <span class="comment">//错误，初始化必须为一个对象</span></span><br><span class="line"><span class="keyword">double</span> dval=<span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal5=dval; <span class="comment">//错误，这里的初始化必须为int</span></span><br></pre></td></tr></table></figure><h2 id="引用一个指针"><a href="#引用一个指针" class="headerlink" title="引用一个指针"></a>引用一个指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p; <span class="comment">//p是一个指向整数的指针</span></span><br><span class="line"><span class="keyword">int</span> *&amp;r=p; <span class="comment">// r是指针p的引用</span></span><br><span class="line"></span><br><span class="line">r=&amp;i; <span class="comment">//r 引用了一个指针，给r赋值&amp;i 相当于给p赋值&amp;i，也就是p指向i</span></span><br><span class="line">*r=<span class="number">0</span>; <span class="comment">//dereferencing r 产生i,i就是p所指向的，相当于把i变为0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ programming</title>
      <link href="2021/06/04/C-programming/"/>
      <url>2021/06/04/C-programming/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“If you do not change direction, you may end up where you were heading.”<br>– Lao Tzu</p></blockquote><p>本篇的主要框架和内容来自于新南威尔士大学(UNSW)课程COMP6771(Advanced C++ programming),用于记录和总结自己的学习成果,除此之外一些更为详细的补充内容都取自 <em>essential C++(Lippman)</em> 和 <em>C++ primer(Lippman)</em> 这两本经典教科书 (都出自同一人之手）。主要内容分为8部分（每一部分有更详细的划分），分别为:</p><ol><li><a href="#Intro">C++ Introduction</a></li><li><a href="#STL">STL (标准模版库)</a></li><li>Class Types (类&amp;对象)</li><li>Exception Handling (异常处理)</li><li>Resource Management and Smart Pointers (内存管理和智能指针)</li><li>Templates (模版)</li><li>Advanced templates (进阶模版)</li><li>Advanced OO (进阶面向对象编程)</li></ol><p>博客的写作风格以代码为主，语言解释为辅，以知识点为主要框架进行，而且省略了不少细节(有关详细内容请参考另一篇博客C++Primer笔记)。着重记录了自己以前没有接触过的新知识以及容易犯错的知识点。</p><p>Let’s explore the world of C++!</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;   //iostrem 库的相关头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello,world!\n&quot;</span>;  <span class="comment">//print</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="variables"><a href="#variables" class="headerlink" title="variables"></a>variables</h3><p>c++中主要的数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>; <span class="comment">// i is an int</span></span><br><span class="line"><span class="keyword">double</span> j = <span class="number">2.5</span>; <span class="comment">//j is a double</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s= <span class="string">&quot;hello&quot;</span>;<span class="comment">//s is a string</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; <span class="comment">//c is a character</span></span><br><span class="line"><span class="keyword">auto</span> k=<span class="number">3.5</span>; <span class="comment">// k is a double, auto的数据类型取决于等号右边的类型</span></span><br><span class="line"><span class="keyword">auto</span> check = <span class="literal">true</span>; <span class="comment">//check is a boolean, either true or false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;check&lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//打印1. true为1，false为0</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f; <span class="comment">//vector 属于类模版，后面的尖括号定义了vector所包含的元素类型，为数组</span></span><br><span class="line"><span class="keyword">auto</span> a=f;<span class="comment">//  a is a vector (copy of f)</span></span><br><span class="line">f.push_back(<span class="number">5</span>); <span class="comment">// add 5 to f, 此时的f为 [5]</span></span><br><span class="line">f.push_back(<span class="number">4</span>); <span class="comment">//add 4 to f, 此时的f为[5,4]</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f.size() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//f的长度为2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;f[<span class="number">1</span>]&lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//打印结果为4， f[1]=4</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="constant"><a href="#constant" class="headerlink" title="constant"></a>constant</h3><p>只读<strong>const</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i; <span class="comment">// 错误，const初始化必须要赋值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">// i = 1 ，且不可修改</span></span><br><span class="line">i++; <span class="comment">//错误， i不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> m = <span class="number">42</span>; <span class="comment">//m is an int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h3><p>函数的应用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="comment">//求矩形面积的函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">rectangular_area</span><span class="params">(<span class="keyword">double</span> <span class="keyword">const</span> width,<span class="keyword">double</span> <span class="keyword">const</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> width * length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调色盘函数</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">rgb</span><span class="params">(<span class="keyword">short</span> r =<span class="number">0</span>,<span class="keyword">short</span> g=<span class="number">0</span>,<span class="keyword">short</span> b=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::stringsretam my_string;</span><br><span class="line">my_string &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; r &lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;g&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> my_string.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rectangular_area(<span class="number">2.0</span>,<span class="number">4.0</span>) &lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//8.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; rgb(); <span class="comment">// (0,0,0)  默认参数为0</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; rgb(<span class="number">100</span>); <span class="comment">// (100,0,0)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; rgb(<span class="number">100</span>,<span class="number">200</span>); <span class="comment">//(100,200,0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="references"><a href="#references" class="headerlink" title="references"></a>references</h3><p>c++的引用，具体细节在前一篇博客中有描述</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> i= <span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; j= i; <span class="comment">//j只是i的一个别名</span></span><br><span class="line">j= <span class="number">3</span> ; <span class="comment">//相当于i=3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;i &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt;j&lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// print &quot;3 3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> k= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span>&amp; ref= k;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ref&lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//1</span></span><br><span class="line">k++;  <span class="comment">//this is fine</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ref&lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//2</span></span><br><span class="line">ref++; <span class="comment">//错误， 因为ref为const</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span>&amp; mref = m;<span class="comment">// this is ok</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mref &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="enumration"><a href="#enumration" class="headerlink" title="enumration"></a>enumration</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">colors</span> &#123;</span> red = <span class="number">4</span>, black &#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">suit</span> &#123;</span> heart, diamond = <span class="number">8</span>, spade = <span class="number">4</span>, club &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//会打印4，5。 没有赋值的元素就是前一个的值加一（如果前面的元素赋值了）</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The value of color: &quot;</span> &lt;&lt; red &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; black &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">//会打印0，8，4，5。第一个元素没有赋值，所以为0.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The value of suit: &quot;</span> &lt;&lt; heart &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; diamond &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; spade &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; club</span><br><span class="line">          &lt;&lt; <span class="string">&quot;\n &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><ol><li>set中的元素是排序好的</li><li>set中的元素是唯一的，即不重复的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义一个无序set</span></span><br><span class="line"><span class="keyword">auto</span> computer_scientists = <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&#123;</span><br><span class="line"><span class="string">&quot;Lovelace&quot;</span>,</span><br><span class="line"><span class="string">&quot;Babbage&quot;</span>,</span><br><span class="line"><span class="string">&quot;Turing&quot;</span>,</span><br><span class="line"><span class="string">&quot;Hamilton&quot;</span>,</span><br><span class="line"><span class="string">&quot;Church&quot;</span>,</span><br><span class="line"><span class="string">&quot;Borg&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (computer_scientists.contains(<span class="string">&quot;Lovelace&quot;</span>)) &#123;  <span class="comment">//检查set是否包含某个关键值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;yes,Lovelace&quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">computer_scientists.insert(<span class="string">&quot;Gauss&quot;</span>); <span class="comment">//插入一个关键值</span></span><br><span class="line">computer_scientists.erase(<span class="string">&quot;Gauss&quot;</span>); <span class="comment">//删除一个关键值</span></span><br><span class="line"><span class="keyword">auto</span> ada = computer_scientists.find(<span class="string">&quot;Lovelace&quot;</span>); <span class="comment">//找到一个关键值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *ada &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// Lovelace</span></span><br><span class="line">computer_scientists.clear(); <span class="comment">//清空set</span></span><br><span class="line"><span class="keyword">if</span> (computer_scientists.empty()) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;empty set&quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot;\n&quot;</span>;    <span class="comment">// 打印empty set, 此时set 为空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>更多关于set的应用，会在以后的内容中提到。</li></ol><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>首先是array</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt; ages = &#123;<span class="number">18</span>,<span class="number">10</span>,<span class="number">20</span>&#125;; <span class="comment">//array是固定长度的</span></span><br><span class="line"><span class="comment">//介绍3种方法遍历数组</span></span><br><span class="line"><span class="comment">//1.利用数组大小</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ages.size();++i)&#123;  <span class="comment">//因为这里ages.size()的类型是unsigned int</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ages[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.利用array的迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = ages.begin();it!=ages.end();++it)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. const auto&amp;  仅限于C++11以上版本</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; age : ages)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; age&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是vector</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">//vector是不定长的数组</span></span><br><span class="line"><span class="keyword">int</span> input; <span class="comment">//可以自己输入一些数字进入数组</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; input)&#123;</span><br><span class="line">numbers.push_back(input); <span class="comment">//输入数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;1st element: &quot;</span>&lt;&lt; numbers.at(<span class="number">0</span>) &lt;&lt;<span class="string">&quot;\n&quot;</span>;<span class="comment">//1,根据数组的索引来查找</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;1st element: &quot;</span>&lt;&lt; numbers[<span class="number">1</span>] &lt;&lt;<span class="string">&quot;\n&quot;</span>;<span class="comment">//跟上面一样，另一种写法</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max size: &quot;</span> &lt;&lt; numbers.capacity() &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//计算数组的大小</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : numbers) &#123; <span class="comment">//遍历数组</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map被定义为一对数值，key通常是一个字符串，扮演索引的角色，是唯一的，每个key有对应的value(就像字典一样)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; words; <span class="comment">//定义一个map</span></span><br><span class="line"></span><br><span class="line">words[<span class="string">&quot;hello&quot;</span>] = <span class="number">1</span>; <span class="comment">//添加一对数值 (&quot;hello&quot;,1)</span></span><br><span class="line">words.emplace(<span class="string">&quot;cat&quot;</span>, <span class="number">2</span>); <span class="comment">//另一种添加方法</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> tword;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; tword) &#123;     <span class="comment">//向map输入数值，每当输入的key和map中的一样，就在其对应的value上加一</span></span><br><span class="line">words[tword]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = words.begin(); <span class="comment">//map的迭代器</span></span><br><span class="line"><span class="keyword">for</span> (; it != words.end(); ++it) &#123;  <span class="comment">//打印出map中所有的数值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;,value: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>; </span><br><span class="line"><span class="comment">//it -&gt; first 打印每个pair的第一个，也就是key, it-&gt;second打印每个pair的第二个，也就是数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找key</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">it = words.find(<span class="string">&quot;world&quot;</span>); <span class="comment">//find会返回一个迭代器，指向所找到的pair,如果找不着，返回end()</span></span><br><span class="line"><span class="keyword">if</span> (it != words.end()) &#123;</span><br><span class="line">count = it-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><p>迭代器用于检查容器内元素并遍历的一种数据类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; names= &#123;<span class="string">&quot;ada&quot;</span>, <span class="string">&quot;black&quot;</span>, <span class="string">&quot;cindy&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter=names.begin();iter!=names.end();++iter)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *iter&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = names.rbegin(); iter != names.rend(); ++iter) &#123; <span class="comment">//从后往前遍历</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习算法导论</title>
      <link href="2021/05/27/%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
      <url>2021/05/27/%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“I thought clay must feel happy in the good potter’s hand.”<br>– Janet Fitch</p></blockquote><p>这学期结束后，利用短暂的假期，终于开启了著名的 <em>算法导论</em> 学习之旅。学习的时间比较仓促，由于平常还要实习，所以基本只学习了我认为经典和重要的数据结构和算法，耗时大概20天。</p><p>学习的方法就是书上的定义，例子，伪代码并且用python语言实现（可以在博客里的project里面查看代码），有些伪代码难以理解或者例子过于复杂，会选择更简单堆例子来实现。本书最精华也是最难的数学证明部分（证明算法的合法性，运算时间，所占空间等）我是直接跳过了，因为时间的原因。经典的作品是不能只读一遍的，也许在不久的将来，我会利用闲暇的时间再重读此书。第二次阅读的主要目标是巩固第一遍较难的算法。</p><p>首先总结一下学习的内容：</p><ol><li>排序算法。最为基础和经典的算法。书中给出了大约7中排序算法，选取了其中5种最常见的算法：插入，选择，冒泡，合并，堆排序，快速排序。其中较难理解的是合并以及快速排序。</li><li>分治策略。主要以最大子数组为例，没有太深入学习</li><li>基本数据结构。是本次学习中内容占比最大的。涉及到栈和队列，链表，散列表，二叉搜索树，红黑树。这次学习对这些基本的数据结构的实现有一定的理解，但还达不到手写出来的程度。</li><li>动态规划和贪心算法。在面试题中出现频率非常高的题型，有很强的技巧性，难度也通常比较大。通常涉及到最优子问题。</li><li>图论。广度优先搜索和深度优先搜索是非常重要的算法。kruskal和prim算法实现最小生成树，以及经典最短路径算法dijkstra。</li><li>字符串匹配。KMP算法。</li></ol><p>学习完的感受：<br>对这些基本的算法的原理有了一定的理解，也了解到了算法设计的应用及重要性。对于工作中算法的面试也有很大的帮助。由于在学习的过程中深入度不够，以及在很多问题思考不足就直接搜索思路，目前存在的问题是对于算法的理解没有那么深入，在实操的时候也很容易出错（达不到不借助任何辅助来实现这些算法）。由于目前的首要难关是面试中的算法题，所以接下来就是要多刷题，尽可能利用学到的算法来实现。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统经典进程通信问题</title>
      <link href="2021/02/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E9%97%AE%E9%A2%98/"/>
      <url>2021/02/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Rocks in my path? I keep them all. With them, I shall build my castle.</p></blockquote><h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><img src="/2021/02/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E9%97%AE%E9%A2%98/pic1.png" class><p>如图所示，有五位哲学家，每人有一盘意大利面，每两个盘子之前有一个叉子，要想顺利的吃到意大利面，哲学家必须同时使用两个叉子。哲学家的任务就是吃饭和思考，有没有一种方法能让每个哲学家没有停顿的做这两样事？<br>显然，叉子的数量是不能满足五个哲学家同时吃饭的。Dijkstra给出了解答。<br>先设想这么一种情况，一个哲学家先拿起左手边的叉子，然后检查右手边的叉子是否可用，如果不可用，就放下叉子等待，然后过一段时间再重复这个过程。这种情况在一种情况下是行不通的，那就是当五位哲学家同时拿起左手边的叉子（这里假设所有操作的时间都是一致的，比如每个哲学家等待的时间），这样就会导致他们永远拿不到右边的叉子。这种情况称为<font color="orange"><strong>饥饿状态(starvation)</strong></font>。<br>若把等待时间设定为随机的，在一定程度上可以解决这个问题。但在一些应用中，尤其是安全领域，是不行的。<br>最优的解决方法是要满足2个哲学家可以同时就餐。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N           5         <span class="comment">//number of philosophers</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT        (i+N-1)%N <span class="comment">//number of i&#x27;s left neighbor  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT       (i+1)%N  <span class="comment">//number of i&#x27;s right neighbor</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING     0       <span class="comment">//Philosopher is thinking</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGERY      1       <span class="comment">//Philosopher is trying to get forks</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING       2       <span class="comment">//Philosopher is eating</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;       <span class="comment">//semaphores are a special kind of int</span></span><br><span class="line"><span class="keyword">int</span> state[N];                <span class="comment">//array to keep track of everyone&#x27;s state</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;         <span class="comment">//mutual exclusion for critical regions</span></span><br><span class="line">semaphore s[N];              <span class="comment">//one semaphore per philosopher</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span>  <span class="comment">// i philosopher number from 0 to N-1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;         <span class="comment">//repeat forever</span></span><br><span class="line">think();        <span class="comment">// philosopher is thinking</span></span><br><span class="line">take_forks(i);  <span class="comment">//acquire two forks </span></span><br><span class="line">eat();          <span class="comment">//eating </span></span><br><span class="line">put_forks(i);   <span class="comment">//put both forks down</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_forks</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">down(&amp;mutex);        <span class="comment">//enter critical region </span></span><br><span class="line">state[i] = HUNGERY;   <span class="comment">//record that philosopher i is hungery</span></span><br><span class="line">test(i);             <span class="comment">//try to acquire 2 forks</span></span><br><span class="line">up(&amp;mutex);          <span class="comment">//exit critical region</span></span><br><span class="line">down(&amp;s[i]);         <span class="comment">//block if forks were not acquired</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_forks</span><span class="params">(i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">down(&amp;mutex);        <span class="comment">//enter critical region</span></span><br><span class="line">state[i] = THINKING; <span class="comment">//Philosopher has finished eating</span></span><br><span class="line">test(LEFT);          <span class="comment">//see if left neighbor can now eat.</span></span><br><span class="line">test(RIGHT);         <span class="comment">//see if right neighbor can now eat</span></span><br><span class="line">up(&amp;mutex);          <span class="comment">//exit critical region </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(state[i] == HUNGERY &amp;&amp; state[LEFT]!=EATING &amp;&amp; state[RIGHT]!= EATING)&#123;</span><br><span class="line">state[i] = EATING;</span><br><span class="line">up(&amp;s[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读者-作者问题-reader-and-writer-problem"><a href="#读者-作者问题-reader-and-writer-problem" class="headerlink" title="读者-作者问题(reader and writer problem)"></a>读者-作者问题(reader and writer problem)</h2><p>想象一个订票系统，多个进程会在同时读取数据库，当一个进程写入数据库时，其他的进程就不能读写，那么如何解决这个问题？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;    <span class="comment">//use your imagination</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;        <span class="comment">//controls access to &#x27;rc&#x27;</span></span><br><span class="line">semaphore db=<span class="number">1</span>;           <span class="comment">//controls access to the database</span></span><br><span class="line"><span class="keyword">int</span> rc = <span class="number">0</span>;               <span class="comment">//# of processes reading or wanting to </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">down(&amp;mutex);    <span class="comment">//get exclusive access to &#x27;rc&#x27;</span></span><br><span class="line">rc = rc+<span class="number">1</span>;       <span class="comment">//one reader more now</span></span><br><span class="line"><span class="keyword">if</span> (rc==<span class="number">1</span>) down(&amp;db); <span class="comment">//if this is the first reader.</span></span><br><span class="line">up(&amp;mutex);      <span class="comment">//release exclusive access to &#x27;rc&#x27;</span></span><br><span class="line">read_data_base(); <span class="comment">//access the data</span></span><br><span class="line">down(&amp;mutex);    <span class="comment">//get exclusive access to &#x27;rc&#x27;</span></span><br><span class="line">rc = rc<span class="number">-1</span>;        <span class="comment">//one reader fewer now </span></span><br><span class="line">up(&amp;mutex);       <span class="comment">//release exclusive access to &#x27;rc&#x27;</span></span><br><span class="line">use_data_read();   <span class="comment">//noncritical region</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">think_up_data();   <span class="comment">//noncritical region </span></span><br><span class="line">down(&amp;db);         <span class="comment">//get exclusive access</span></span><br><span class="line">write_data_base(); <span class="comment">//update the data</span></span><br><span class="line">up(&amp;db);           <span class="comment">//release exclusive access.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码给出了解答。当第一个读者进入数据库的时候，对数据库进行down操作，接下来的读者仅仅是增加了counter，直到最后一个读者离开的时候，才up database。这时如果有一个blocked writer，就可以进入。当一个读者在处理数据的时候，其他的读者也可以进入。<br>作者只有当读者全部离开的时候才能进入，如果每隔2秒进来一个读者，且每个读者要花5秒来完成工作，那么作者将永远无法进入。<br>为了防止这个问题，可以将持续进来的读者排在正等待的作者之后，也就是说，当一个读者离开临界区的时候，下一个进来的就是等待中的作者而不是另一个读者。</p><h2 id="睡眠理发师问题"><a href="#睡眠理发师问题" class="headerlink" title="睡眠理发师问题"></a>睡眠理发师问题</h2><p>假设一个理发店里有一个理发师，一个理发座椅还有n个顾客座椅。当没有顾客的时候，理发师在椅子上睡着了。如果一个顾客走进来，他需要唤醒理发师，接下来的顾客看到理发师正在工作，他们要么会在椅子上等待，要么就离开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHAIRS  5    <span class="comment">//#chairs for waiting customers</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore   <span class="comment">//use your imagination</span></span><br><span class="line"></span><br><span class="line">semaphore customers = <span class="number">0</span>;    <span class="comment">//# of customers waiting for service</span></span><br><span class="line">semaphore barber = <span class="number">0</span>;      <span class="comment">//# of barbers waiting for customers</span></span><br><span class="line">semaphore mutex =<span class="number">1</span>;      <span class="comment">//for mutual exclusion</span></span><br><span class="line"><span class="keyword">int</span> waiting = <span class="number">0</span>;       <span class="comment">//customers are waiting</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">barber</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">down（&amp;customers);  <span class="comment">//go to sleep if # of customers is 0</span></span><br><span class="line">down(&amp;mutex);       <span class="comment">//acquire access to waiting</span></span><br><span class="line">waiting = waiting01; <span class="comment">//decrement count of waiting customers</span></span><br><span class="line">up(&amp;barbers);       <span class="comment">//one barber is now ready to cut hair</span></span><br><span class="line">up(&amp;mutex);         <span class="comment">//release &quot;waiting&quot;</span></span><br><span class="line">cut_hair();         <span class="comment">//outside critical region</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">customer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">down(&amp;mutex);        <span class="comment">//enter critical region</span></span><br><span class="line"><span class="keyword">if</span>(waiting &lt; CHAIRS)&#123;   <span class="comment">//if no free chairs ,leave</span></span><br><span class="line">waiting = waiting +<span class="number">1</span>; <span class="comment">//increment count of waiting customers</span></span><br><span class="line">up(&amp;customer);     <span class="comment">//wake up barber.</span></span><br><span class="line">up(&amp;mutex);       <span class="comment">//release access to &quot;waiting&quot;</span></span><br><span class="line">down(&amp;barber);    <span class="comment">//go to sleep if # of free barber is 0</span></span><br><span class="line">get_haircut();    <span class="comment">//be seated and be serviced</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">up(&amp;mutex);      <span class="comment">//shop is full, do not wait </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之IPC3</title>
      <link href="2021/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIPC3/"/>
      <url>2021/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIPC3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Even though the future seems far away, it is actually beginning right now.<br>– Mattie Stepanek</p></blockquote><h2 id="互斥-mutexes"><a href="#互斥-mutexes" class="headerlink" title="互斥(mutexes)"></a>互斥(mutexes)</h2><p>互斥可以理解为简化版的信号量。互斥是一个变量，且有两种状态：锁和解锁(locked and unlocked)。在实际情况中，通常用0来表示解锁，其他的整数都表示锁。<br>当一个进程或者线程需要进入临界区，它会调用 <em>mutex_lock</em>。如果互斥是解锁状态(临界区是可以进入的)，线程就可以随意进入临界区。<br>当互斥已经锁住的情况下，线程会block，直到在临界区里的线程完成并且调用mutex_unlock。如果多个线程都被Block, mutex会随机选择一个进入临界区。<br>互斥可以利用TSL 来实现。代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock:</span><br><span class="line">TSL REGISTER,MUTEX        |copy mutex to register and set mutex to 1</span><br><span class="line">CMP REGISTER,#0           |was mutex 0?</span><br><span class="line">JZE ok                    |if it was 0,mutex was unlocked,so return ok</span><br><span class="line">CALL thread_yield         |mutex is busy, schedule another thread</span><br><span class="line">JMP mutex_lock            |try again later</span><br><span class="line">RET  |return to caller;critical region entered</span><br><span class="line"></span><br><span class="line">mutex_unlock:</span><br><span class="line">MOVE MUTEX,#0             |STORE 0</span><br><span class="line">RET                       |return to caller</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="管程（monitor）"><a href="#管程（monitor）" class="headerlink" title="管程（monitor）"></a>管程（monitor）</h2><p>如果操作不当，互斥会产生死锁（deadlock）。所以这里介绍管程的概念。管程是一个集程序，变量，数据结构的结合体。一个进程可以调用管程里的程序但是不能直接访问在管城外定义的数据结构。下面是管程的伪程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Monitor example:</span><br><span class="line">integer i;</span><br><span class="line">condition c;</span><br><span class="line"></span><br><span class="line">Procedure producer();</span><br><span class="line">.</span><br><span class="line">End</span><br><span class="line"></span><br><span class="line">Procedure consumer();</span><br><span class="line">.</span><br><span class="line">End</span><br><span class="line">End monitor;</span><br></pre></td></tr></table></figure><p>在管程中，任何时刻只能有一个进程运行。比如当一个进程调用管程的程序，这个程序会首先检查在管程内是否有其他运行的程序。如果有，进程会被悬挂直到其他进程离开；如果没有，进程可以直接进入。<br>如果缓存(buffer)已经满了，那么producer该如何操作？这里就要引入条件变量（condition variables）的概念，还有两种操作，<em>wait and signal</em>。当管程程序发现不能继续的时候，它就会在条件变量上做wait操作，比如把条件变量变成full。这个操作可以使准备调用的进程block并且会让之前等待的进程进入。<br>同样的，consumer会实行signal操作。为了不让两个进程同时在管程里运行，在signal操作之后就要结束管程。也就是，wait一定实在signal之前的。<br>Wait,signal和sleep,wakeup的区别是：一个进程可能会被同时sleep和wakeup，但wait,signal不会。<br>Java语言可以很好的利用管程解决生产者-消费者的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">100</span>;    <span class="comment">//constant giving the buffer size</span></span><br><span class="line"><span class="keyword">static</span> producer p = <span class="keyword">new</span> producer();   <span class="comment">//instantiate a new producer thread</span></span><br><span class="line"><span class="keyword">static</span> consumer c = <span class="keyword">new</span> consumer();   <span class="comment">//instantiate a new consumer thread</span></span><br><span class="line"><span class="keyword">static</span> our_monitor mon = <span class="keyword">new</span> our_monitor();  <span class="comment">// a new monitor</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">p.start();  <span class="comment">//start the producer thread</span></span><br><span class="line">c.statr();  <span class="comment">// start the consumer thread</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  <span class="comment">//run method contains the thread code.</span></span><br><span class="line"><span class="keyword">int</span> item;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123; <span class="comment">//producer loop</span></span><br><span class="line">item=produce_item();</span><br><span class="line">mon.insert(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">produce_item</span><span class="params">()</span> </span>&#123;...&#125; <span class="comment">// actually produce</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  <span class="comment">//run method contains the thread code.</span></span><br><span class="line"><span class="keyword">int</span> item;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123; <span class="comment">//consumer loop</span></span><br><span class="line">item=mon.remove();</span><br><span class="line">consume_item;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume_item</span><span class="params">()</span> </span>&#123;...&#125; <span class="comment">// actually consume</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">our_monitor</span></span>&#123; <span class="comment">// this is a monitor </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> buffer[] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>,lo=<span class="number">0</span>,hi=<span class="number">0</span>; <span class="comment">//counters and indices</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(count==N) go_to_sleep(); <span class="comment">//if the buffer is full,go to sleep</span></span><br><span class="line">buffer[hi] = val;          <span class="comment">//insert an item into the buffer</span></span><br><span class="line">hi = (hi+<span class="number">1</span>)%N;             <span class="comment">//slot to place net item in.</span></span><br><span class="line">count = count + <span class="number">1</span>;         <span class="comment">// one more item in the buffer now</span></span><br><span class="line"><span class="keyword">if</span>(count ==<span class="number">1</span>) notify();    <span class="comment">// if consumer was sleeping, wake it up</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">if</span>(count==<span class="number">0</span>) go_to_sleep();  <span class="comment">//if the buffer is empty,go to sleep </span></span><br><span class="line">val = buffer[lo];      <span class="comment">//fetch an item from the buffer</span></span><br><span class="line">lo =(lo+<span class="number">1</span>) % N;        <span class="comment">//slot to fetch next item from </span></span><br><span class="line">count = count -<span class="number">1</span>;     <span class="comment">//one few items in the buffer</span></span><br><span class="line"><span class="keyword">if</span>(count == N-<span class="number">1</span>) notify(); <span class="comment">//if producer was sleeping ,wake it up.</span></span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">go_to_sleep</span><span class="params">()</span> </span>&#123;<span class="keyword">try</span> &#123;wait();&#125; carcg（InterruptedException exc)&#123;&#125;;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法之排序1</title>
      <link href="2021/02/08/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F1/"/>
      <url>2021/02/08/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>I’ll be back.</p></blockquote><h2 id="冒泡排序法"><a href="#冒泡排序法" class="headerlink" title="冒泡排序法"></a>冒泡排序法</h2><p>冒泡排序法从第一个元素开始比较，比较相邻元素的大小，若大小顺序有误，则对调后再进行下一个元素的比较。扫描一遍后就可以确保最后一个元素处于正确的顺序，接着进行第二次扫描，直到所有的元素的排序完成为止。</p><p>以数列[55,23,87,62,16]为例</p><ol><li>第一次扫描会比较4组数据<ul><li>23 55 87 62 16</li><li>23 55 87 62 16</li><li>23 55 62 87 16</li><li>23 55 62 16 87</li></ul></li><li>第二次扫描比较3组数据(87的位置以及确定):<ul><li>23 55 62 16 87</li><li>23 55 62 16 87</li><li>23 55 16 62 87</li></ul></li><li>第三次比较2组数据:<ul><li>23 55 16 62 87</li><li>23 16 55 62 87</li></ul></li><li>第四次比较1组数据:<ul><li>16 23 55 62 87</li></ul></li></ol><p>实现代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,tmp;</span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">5</span>] = &#123;<span class="number">55</span>,<span class="number">23</span>,<span class="number">87</span>,<span class="number">62</span>,<span class="number">16</span>&#125;; <span class="comment">//原始数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;冒泡排序法:\n原始数据为: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">4</span>;i&gt;<span class="number">0</span>;i--)&#123;     <span class="comment">//扫描4次</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;i;j++)&#123;  <span class="comment">//每次扫描的比较次数</span></span><br><span class="line">            <span class="keyword">if</span>(data[j]&gt;data[j+<span class="number">1</span>])&#123;   <span class="comment">//交换</span></span><br><span class="line">                tmp = data[j];</span><br><span class="line">                data[j] = data[j+<span class="number">1</span>];</span><br><span class="line">                data[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第 %d 次的排序结果是: &quot;</span>,<span class="number">5</span>-i);</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,data[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序法:</span><br><span class="line">原始数据为:  55 23 87 62 16</span><br><span class="line">第 1 次的排序结果是:  23 55 62 16 87</span><br><span class="line">第 2 次的排序结果是:  23 55 16 62 87</span><br><span class="line">第 3 次的排序结果是:  23 16 55 62 87</span><br><span class="line">第 4 次的排序结果是:  16 23 55 62 87</span><br></pre></td></tr></table></figure><h2 id="选择排序-selection-sort"><a href="#选择排序-selection-sort" class="headerlink" title="选择排序(selection sort)"></a>选择排序(selection sort)</h2><p>选择排序的算法就是反复从未排序的数列中取出最小的元素，加入到另一个数组。如果是从小到大排，最小的就放在第一个位置，如果从大到小，就放在最后一个。<br>依然以[55,23,87,62,16] 为例：</p><ol><li>第一次扫描，发现最小的值为16，把16和第一个数交换:<ul><li>16 55 23 87 62 </li></ul></li><li>第二次扫描，从第二个数开始，发现最小的值为23，把23和第二个数交换:<ul><li>16 23 87 62 55</li></ul></li><li>第三次扫描，从第三个数开始，发现最小的值为55，把55和第三个交换:<ul><li>16 23 55 62 87</li></ul></li><li>第四次扫描，从第三个数开始，发现最小的值为62，把62和第四个数交换(不变):<ul><li>16 23 55 62 87</li></ul></li></ol><p>用C语言实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showdata</span><span class="params">(<span class="keyword">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">5</span>] = &#123;<span class="number">55</span>,<span class="number">23</span>,<span class="number">87</span>,<span class="number">62</span>,<span class="number">16</span>&#125;; <span class="comment">//原始数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;选择排序法:\n原始数据为: &quot;</span>);</span><br><span class="line">    showdata(data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序过程: \n&quot;</span>);</span><br><span class="line">    select(data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最终排序结果: &quot;</span>);</span><br><span class="line">    showdata(data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showdata</span><span class="params">(<span class="keyword">int</span> data[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> data[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,tmp;</span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;    <span class="comment">//扫描4次</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;<span class="number">5</span>;j++)&#123;   <span class="comment">//从i+1开始比较</span></span><br><span class="line">            <span class="keyword">if</span>(data[i]&gt;data[j])&#123;</span><br><span class="line">                tmp = data[i];</span><br><span class="line">                data[i] = data[j];</span><br><span class="line">                data[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        showdata(data);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">选择排序法:</span><br><span class="line">原始数据为:  55 23 87 62 16</span><br><span class="line">排序过程: </span><br><span class="line"> 16 55 87 62 23</span><br><span class="line"> 16 23 87 62 55</span><br><span class="line"> 16 23 55 87 62</span><br><span class="line"> 16 23 55 62 87</span><br><span class="line">最终排序结果:  16 23 55 62 87</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法之递归</title>
      <link href="2021/02/08/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92/"/>
      <url>2021/02/08/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<blockquote><p>The good thing about computers is that they do what you tell them to do. The bad news is that they do what you tell them to do.<br>– Ted Nelson</p></blockquote><p>该系列的学习笔记是关于主要的数据结构和算法,使用的编程语言为C语言。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>如果一个函数或子程序是由自身定义或调用的，就称为<font color="orange"><strong>递归(recursion)</strong></font>。它至少要定义两个条件:</p><ol><li>一个可以反复执行的递归过程</li><li>一个跳出执行的出口。</li></ol><p>以常见的阶乘函数为例，n!=nx(n-1)x(n-2)x…1</p><p>下面把5！运算过程拆开：<br>5!=(5x4!)<br>  &nbsp;&nbsp;=5x(4x3!)<br>  &nbsp;&nbsp;=5x4x(3x2!)<br>  &nbsp;&nbsp;=5x4x3x(2x1)<br>  &nbsp;&nbsp;=5x4x3x2<br>  &nbsp;&nbsp;=5x4x6<br>  &nbsp;&nbsp;=5x24<br>  &nbsp;&nbsp;=120</p><p>用代码表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)     <span class="comment">//递归终止的条件，跳出递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        res = n*factorial(n<span class="number">-1</span>); <span class="comment">//反复执行递归过程</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个经典的递归例子，就是斐波那契数列(Fibonacci polynomial), 就是0,1,1,2,3,5,8… 当前的数字是前两个数字的和。</p><p>如果我们想要通过程序来求第n项的数字:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)          <span class="comment">//第一项永远为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">1</span> || n==<span class="number">2</span>)  <span class="comment">//第二项和第三项也永远为1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>)); <span class="comment">//否则返回前两项之和ss</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之IPC2</title>
      <link href="2021/02/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIPC2/"/>
      <url>2021/02/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIPC2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>If it weren’t for electricity, we’d all be watching television by candlelight.<br>– George Gobel</p></blockquote><h2 id="休眠和唤醒"><a href="#休眠和唤醒" class="headerlink" title="休眠和唤醒"></a>休眠和唤醒</h2><p>前文介绍的互斥方法，peterson或是TSL，的缺点就是会大量两份CPU的时间，而且还会引发一些问题。比如，一个高优先级的进程H，和一个低优先级的进程L, 根据调度规则，高优先级的任务只要在ready的状态就需要运行，假设这时L在临界区内，H需要运行，这时候H就进入了busy waiting(一直在等机会进入临界区)。但是因为L优先级较低，在H运行的时候不会被调度，所以也就不会离开临界区，H就进入了无限循环。这种情况被称为<strong>优先级反转问题</strong>(priority inversion problem)。</p><p>采用Block能解决这个问题。Sleep和wakeup就是一个例子。Sleep 是一个系统调用，它开业使一个进程悬挂起来，直到另一个进程唤醒它。Wakeup可以唤醒一个进程。Sleep和wakeup各有一个参数，那就是用来互相关联的内存地址。</p><h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p>假设有两个进程共享一个固定大小的缓存区(buffer)。其中一个，我们可以称其为生产者，把信息存入缓存里，另一个，称其为消费者，把信息取出。<br>问题是如果缓存已经存满了，生产者就不能继续往里存储信息。所以这时候生产者进入sleep状态，等消费者从缓存中取出信息。相反，如果缓存是空的，消费者就要进入sleep。<br>我们需要一个计数器,count，来记录缓冲里信息的数量。如果一个缓存只能存储N个信息，那么生产者就要首先检查count是否为N，如果是的，就进入sleep。如果不是，加入信息，并且 coun++。<br>同样的，对于消费者，就是检查count是否为0,如果是0,就进入sleep。如果不是，就取出，并且count–。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100    <span class="comment">//number of slots in the buffer</span></span></span><br><span class="line"><span class="meta">#int count = 0<span class="comment">//number of items in the buffer</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">item = produce_item();   <span class="comment">//generate next item</span></span><br><span class="line"><span class="keyword">if</span> (count == N) sleep();</span><br><span class="line">insert_item(item);</span><br><span class="line">count = count+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">1</span>) wakeup(consumer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) sleep();</span><br><span class="line">item = remove_item();</span><br><span class="line">count = count01;</span><br><span class="line"><span class="keyword">if</span> (count == N<span class="number">-1</span>) wakeup(producer);</span><br><span class="line">consume_item(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码可以大概表达出生产者和消费者的运行流程。但是这个代码是有可能产生竞争的，因为count可以无限制访问(by producer and consumer)。最后会导致两者都进入永远的sleep。<br>引起这个原因的根本是wakeup signal的丢失(因为wakeup发给了并没有进入sleep的进程)。解决办法是加入一个 <font color="orange"><strong>wakeup waiting bit</strong></font>。当wakeup信号发送给一个已经唤醒的进程，这个bit就被设定。如果这个进程要进入sleep，如果waiting bit 是设定了的，那么就会被关闭，进程继续保持唤醒。Wakeup waiting bit 就类似于wakeup信号的存钱罐。</p><h2 id="信号量-semaphores"><a href="#信号量-semaphores" class="headerlink" title="信号量(semaphores)"></a>信号量(semaphores)</h2><p>信号量是用来记录wakeup数量的一个变量。如果信号量为0，就代表没有一个wakeup被存储，或者是一个正数，代表着有一个或多个wakeup被保存。<br>Dijkstra （提出著名最短路径算法的科学家）把信号量分成两个操作，down和up（分别代表sleep和wakeup）。Down操作检查信号量的值是否大于0，如果是的话，就减一(确保只有一个wakeup储存)。如果值为0的话，进程就会sleep。<br>检查数值，改变数值，或是进入sleep，所有的操作被看作一个整体且不能分开操作，就被称为<font color="orange"><strong>原子操作(atomic action)</strong></font>。这确保了在一个信号量执行的时候，另一个进程不会进入信号量。原子化在同步问题和避免条件竞争都非常重要。<br>Up操作给信号量的值增加。如果在这个信号量中，有一个或多个进程正在sleeping，且不能完成down操作，其中的一个进程就会被系统随机选择进行down操作。因此，当有sleeping进程的信号量实行up操作之后，信号量依然为0，但是会少一个正在sleeping的进程。这个过程同样也是原子操作。</p><h2 id="用信号量解决生产者-消费者问题"><a href="#用信号量解决生产者-消费者问题" class="headerlink" title="用信号量解决生产者-消费者问题"></a>用信号量解决生产者-消费者问题</h2><p>信号量可以解决wakeup丢失的问题。如下面的代码所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100    <span class="comment">//number of slots in buffer</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;      <span class="comment">//semaphores are a special kind of int</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//control access to critical region</span></span><br><span class="line">semaphore empty = N;<span class="comment">//counts empty buffer slot </span></span><br><span class="line">semaphore full = <span class="number">0</span>;<span class="comment">//counts full buffer slots</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">item = produce_item();    <span class="comment">//generate something to put in buffer</span></span><br><span class="line">down(&amp;empty);  <span class="comment">//decrement empty count</span></span><br><span class="line">down(&amp;mutex);  <span class="comment">//enter critical region</span></span><br><span class="line">insert_item(item);   <span class="comment">//put new item in buffer</span></span><br><span class="line">up(&amp;mutex);  <span class="comment">//leave critical region </span></span><br><span class="line">up(&amp;full);  <span class="comment">//increment count of full slots </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">down(&amp;full);  <span class="comment">//decrement full count</span></span><br><span class="line">down(&amp;mutex);  <span class="comment">//enter critical region</span></span><br><span class="line">item = remove_item(item);   <span class="comment">//remoev item from buffer</span></span><br><span class="line">up(&amp;mutex);  <span class="comment">//leave critical region </span></span><br><span class="line">up(&amp;empty);  <span class="comment">//increment count of empty slots </span></span><br><span class="line">consume_item(item);  <span class="comment">// do something with item.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="powderblue"><strong>互斥的实现是在同一个进程中进行的一对PV操作。<br><br>同步的实现是在两个进程中进行的，在一个进程中执行P操作，在另一个进程中执行V操作。（down和up也可以用P和V来表示)。</strong></font></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言4</title>
      <link href="2021/02/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804/"/>
      <url>2021/02/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804/</url>
      
        <content type="html"><![CDATA[<blockquote><p>There are three things extremely hard: steel, a diamond, and to know one’s self.<br>– Benjamin Franklin</p></blockquote><h2 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h2><ul><li><p>段的划分来自CPU。</p><img src="/2021/02/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%804/pic1.png" class><p>如上图，可以认为该段的起始地址(基础地址)为10000H，段地址为1000H(因为基础地址=段地址x16,在十六进制中向右偏移1位相当于x16)。大小为100H。<br>也可以认为地址10000H - 1007FH，10080H-100FFH的内存单元组成两个段，起始地址(基础地址)为:10000H,10080H,段地址为，1000H，1008H，大小都为80F。</p></li><li><p>用段地址x16定位段段起始地址(基础地址),用偏移地址定位段中的内存单元。有2点需要注意</p><ol><li>起始地址必然是16的倍数</li><li>偏移地址为16位，16位的寻址能力为64KB,所以一个段的长度最大为64KB</li></ol></li></ul><p><font color="powderblue"><strong>(1)CPU可以用不同的段地址和偏移地址形成一个物理地址。<br><br>    SAx16+EA = PA<br><br>    对于8086CPU地址的描述有两种方法:<br><br>    1. 数据存在2000:1F60单元中<br><br>    2. 数据存在内存的2000H段中的1F60H单元中<br><br>    这两种都表示数据在内存21F60H中</strong></font></p><p><font color="powderblue"><strong>(2)如果给定一个段地址，仅通过变化偏移地址来寻址，最多可以定位多少个内存单元？<br><br>偏移地址16位，变化范围为 0-FFFFH，仅用偏移地址最多可以寻64KB个内存单元。</strong><br></font></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ol><li>给定段地址0001H，仅通过偏移地址寻址,CPU的寻址范围为 0010H 到 1000FH<br><font color="orange">解释: 因为偏移地址的范围为0-FFFFH，SAx16为0010H，所以寻址的范围为 0010+0 - 0010+ffff = 0010H - 100FH。</font></li><li>有一数据存放在内存20000H单元中，现给定段地址为SA，若想用偏移地址寻址此单元。SA的范围应是: 1001H - 2000H<br><font color="orange">解释: 由上面的公示可以计算SA。<br><br> SA = (20000H- EA)/16<br><br> SA = 2000H - EA/16<br><br> 最小SA = 2000H - FFFFH/16 = 1001H<br><br> 最大SA = 2000H - 0 / 16 = 2000H</font></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之IPC1</title>
      <link href="2021/02/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIPC1/"/>
      <url>2021/02/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIPC1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Astronomy’s much more fun when you’re not an astronomer.<br>– Brian May</p></blockquote><h2 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h2><p><font color="orange"><strong>进程通信</strong>(interprocess communication)</font>是一种不需要中断的进程之间的交流。可以简称为IPC。关于这个交流，有三个问题是需要我们事先考虑的：</p><ol><li> 一个进程如何向另一个进程传递信息</li><li>   多个线程之间如何做到不互相干扰</li><li>   在交流中如何保证合适的时序性</li></ol><p>线程同样会面临这三个问题，只不过难度不一样。比如线程传递信息更容易因为线程享有相同的地址空间。</p><h2 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h2><p>在很多操作系统中，进程之间会有一个共享的存储空间，这个空间一般在主存里或者其他文件里。举一个例子来说明进程之间是怎样交流的：后台打印程序(print spooler)。当一个进程想要打印一个文件，它会进入一个由后台文件夹下的文件。另一个进程，打印机后台程序，定期检查是否有需要打印的文件，如果有，那就打印，然后把文件的名字从后台文件夹下移除。<br>假设后台文件夹有很多 0，1，2… 每一个文件都可以保存一个文件名。同时有2个共享的变量，一个是out,指向下一个需要打印的文件，一个是in，指向下一个可执行的文件夹(编号)。这两个变量保证了每个文件都至少包含了2个字（WORD）。这时，进程A和进程B都想把一个文件加入打印列队。这个过程如下图所示:</p><img src="/2021/02/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIPC1/pic1.png" class><p>这样就会出现一种情况：进程A读取in并储存7，在一个名为next_free_slot的本地变量中。就在这时，时钟中断出现了因为CPU任务进程A运行太长时间了，要切换成进程B。进程B也读取了in，也就是7, 然后也把7储存到了next_free_slot。这时，两个进程都认为下一个可执行的文件是7号。<br>进程B继续运行，并把文件名字存进文件夹7然后把in升级为8。<br>然后进程A重新运行，从它停止的那一步开始，所以它会把文件名写入7号文件夹，这样就把进程B的文件替换掉了。然后把in升级为8。所以进程B的文件永远不会被打印。<br>对于这种情况，多个进程读写共享的数据而且结果由进程运行的时刻所影响，就叫做<font color="orange"><strong>条件竞争</strong>(race conditions)</font>。</p><h2 id="临界区-critical-regions"><a href="#临界区-critical-regions" class="headerlink" title="临界区(critical regions)"></a>临界区(critical regions)</h2><p>如何避免条件竞争？我们需要引入互斥(mutual exclusion)这种方法，也就是当一个进程在使用共享变量或者文件时，其他的进程就不能做同样的事。这种方法的难点就在于当进程B使用共享变量的时候，进程A还没有完成。<br>一个共享空间的程序被称为<font color="orange"><strong>临界区</strong></font>。如果可以保证两个进程不同时出现在临界区，就可以避免条件竞争.<br>如果想要并行进程更有效率的话，还需要满足4个条件：</p><ol><li> 两个进程不同时出现在临界区里</li><li>   对CPU的速度和数量没有要求</li><li>   在临界区外运行的进程不应该block其他的进程</li><li>   每一个进程都可以进入临界区</li></ol><p>下图展示了在临界区产生的互斥:</p><img src="/2021/02/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8BIPC1/pic2.png" class><h2 id="忙碌等待中的互斥"><a href="#忙碌等待中的互斥" class="headerlink" title="忙碌等待中的互斥"></a>忙碌等待中的互斥</h2><p>下面详细介绍实现互斥的几种方案：</p><ul><li><p><font color="orange"><strong>去使能中断(disable interrupt)</strong></font><br>一个最简单的互斥方法就是在进入临界区后disable每个进程的中断，然后它们离开的时候重新使能(re-enable)。因为CPU只能通过中断(时钟或其他)来从一个进程转到另一个进程，所以关闭中断就保证了CPU不能转换进程。<br>这种方法的问题在于把中断关闭后，如果不把中断再打开就会引发系统的终结。还有一种情况是在多核处理器的情况下，中断能影响到一个CPU。总结下来就是，去使能中断对于操作系统本身很有用，但是对于用户进程就不适合</p></li><li><p><font color="orange"><strong>锁变量(lock variables)</strong></font><br>假如有一个共享(锁)变量，一开始是0。当一个进程想进入临界区之前，要检查这个锁变量。如果锁是0，进程就把它设置为1然后进入临界区，如果锁以及是1了，那就等待锁变为0。0代表着临界区没有进程，1代表了临界区里有进程。<br>这种方法的问题在于如果一个进程在把锁设置为1之前，另一个进程突然进入然后把锁设置为1，这样两个进程都会进入。这是因为在进程2把锁设置为1时，进程1已经检查过了锁(判断为0),所以竞争已经发生。</p></li><li><p><font color="orange"><strong>严格变更(strict alternation)</strong></font><br>下面的两部分代码展示这种方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(True)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">0</span>)</span><br><span class="line">Critical_region();</span><br><span class="line">Turn = <span class="number">1</span>;</span><br><span class="line">Noncritical_region();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="powderblue">process0</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(True)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">1</span>)</span><br><span class="line">Critical_region();</span><br><span class="line">Turn = <span class="number">0</span>;</span><br><span class="line">Noncritical_region();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><font color="powderblue">process1</font><br>Turn 的初始值是0。Process0 检查turn，发现turn是0，所以进入<em>critical_region</em>（不进入while）。Process1检查turn,也发现是0，所以进入循环(因为turn != 1)检查什么时候turn变为1。这种用循环检查值的方法被称为busy waiting,这种方法通常会浪费CPU时间，所以在短时间等待的情况下比较适用。一个用busy waiting的锁被称为<font color="orange"><strong>spin lock（旋转锁）</strong></font>。<br>当process0离开临界区的时候，会把turn设为1来让process1进入临界区，当process1完成任务的时候，就会把turn设为0，并离开临界区。然后process0再次进入循环，设turn为1…<br>如果这时，process0想进入临界区，但process1在临界区外，也就是说turn还是1，所以process0进入不了临界区，只能进入while循环。所以这种方法对于运行速度差异较大的是不适用的。而且违法了上文所提到的第三个条件:process0被临界区之外的进程block。<br>所以这种方法严格要求了两个进程的替换顺序，尽管它能够避免了竞争，但也不是一个很好的解决方法，因为违法了第三个条件。</p></li><li><p><font color="orange"><strong>Peterson’s solution</strong></font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N   2 <span class="comment">/*number of processes*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> turn;</span><br><span class="line"><span class="keyword">int</span> interested[N];  <span class="comment">// all values initially 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter_region</span><span class="params">(<span class="keyword">int</span> process)</span>    <span class="comment">// 1 or 0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> other；                    <span class="comment">//number of other process</span></span><br><span class="line"></span><br><span class="line">other = <span class="number">1</span>-process;  <span class="comment">// the opposite of process</span></span><br><span class="line">interested[process] = TRUE;  <span class="comment">// show that you are interested.</span></span><br><span class="line">turn = process; <span class="comment">//set flag</span></span><br><span class="line"><span class="keyword">while</span> (turn == process &amp;&amp; interested[other] == TRUE)<span class="comment">//null statement</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leave_region</span><span class="params">(<span class="keyword">int</span> process)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">interested[process] = FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><font color="orange"><strong>TSL 指令</strong></font><br>这个方法是需要借助硬件来实现的，一般的计算机都会有指令<br><code>TSL RX,LOCK</code><br>Test and set lock。这个指令把lock的内存放入寄存器RX然后存储一个非零数在lock的内存地址。这个指令保证了在它执行完成之前，其他的处理器都不能进入。<br>下面的汇编代码给出了详细解答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">TSL REGISTER,LOCK              |copy lock to register and set lock to 1</span><br><span class="line">CMP REGISTER,#0       |was lock 0?</span><br><span class="line">JNE enter_region       |if it was non zero, lock was set so loop</span><br><span class="line">RET           |return to caller;critical region entered</span><br><span class="line"></span><br><span class="line">leave_region:</span><br><span class="line">MOVE LOCK,#0       |store 0 in lock </span><br><span class="line">RET       </span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之线程2</title>
      <link href="2021/02/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B2/"/>
      <url>2021/02/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>The Lord made us all out of iron. Then he turns up the heat to forge some of us into steel.<br>– Marie Osmond</p></blockquote><h2 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h2><p>线程表存放在内核中，当一个线程想要创建新的线程或者删除已有的线程，需要从内核中调用。相比于用户层，线程在内核中更容易实现Block，当一个线程进入Block状态，内核有两个选择，一是让同一进程的另一线程来运行，二是让其他进程的线程来运行。<br>内核线程不需要任何新的，非block的系统调用。当一个线程遇到了page fault，内核可以很容易的检查到进程内是否还有其他可运行的线程。这种方法的缺点是系统调用的成本会非常大。</p><h2 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h2><p>把以上两种实现混合起来，就可以结合各自的优点。如图所示，在这种情况下，每一个内核线程上都会有一组用户空间线程。</p><img src="/2021/02/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B2/pic1.png" class><h2 id="调度器激活机制"><a href="#调度器激活机制" class="headerlink" title="调度器激活机制"></a>调度器激活机制</h2><p>用户线程的优点是高性能，内核线程的优点是操作简洁。<font color="orange"><strong>调度器激活</strong>(scheduler activations)</font>很好的把这两种优点结合在一起。<br>调度激活器的主要目的是减少内核线程的工作流程并在同时保证高性能。提高效率的办法就是减少用户和内核中不必要的交互。<br>这种机制就是当调度器激活启动的时候，内核会给每一个进程指定一个虚拟的处理器然后通过用户系统给这些处理器分配线程。同样的，这个机制也可以用于多进程(multiprocessor)，只不过这里的虚拟处理器是真正的CPU。<br>工作原理是当内核知道线程Blocked(通过运行blocking调用或者出现page fault)。内核会通知用户层关于线程的状态，这种通知是通过内核在一个设定好的地址上激活用户层，这种机制称为upcall。<br>在激活后，用户系统会重新安排线程，通常是block现行的线程然后把其他的线程安排到ready list里，初始化它的寄存器然后重启。</p><h2 id="总结-进程和线程的区别"><a href="#总结-进程和线程的区别" class="headerlink" title="总结:进程和线程的区别"></a>总结:进程和线程的区别</h2><font color="orange">1. 线程可以被理解为轻量级的进程<br>2. 进程把所有资源整合在一起，线程是一个个被CPU调度的条目<br>3. 线程有相同的地址空间，它们共享全局变量，打开文件，信号等。<br>...待补充</font>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言3</title>
      <link href="2021/02/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%803/"/>
      <url>2021/02/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%803/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Set your course by the stars, not by the lights of every passing ship.<br>-Omar Bradley</p></blockquote><h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>每一个内存单元在空间中都有唯一的地址，这个唯一的地址就是物理地址</p><h2 id="16位结构的CPU"><a href="#16位结构的CPU" class="headerlink" title="16位结构的CPU"></a>16位结构的CPU</h2><p>CPU特性:</p><ul><li>运算器一次最多可以处理16位的数据</li><li>寄存器的最大宽度为16位</li><li>寄存器和运算器之间的通路为16位</li></ul><h2 id="8086CPU给出物理地址的方法"><a href="#8086CPU给出物理地址的方法" class="headerlink" title="8086CPU给出物理地址的方法"></a>8086CPU给出物理地址的方法</h2><p>8086CPU有20位地址总线，可以传送20位地址，达到1MB的寻址能力。但CPU又是16位结构，在内部一次性处理，传输，暂时存储的地址为16位。<br>所以CPU采用在内部内使用两个16位地址合成方法来形成一个20位的物理地址。CPU的逻辑结构如图所示</p><img src="/2021/02/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%803/pic1.png" class><ol><li>相关部件提供2个16位地址，一个叫段地址，一个叫偏移地址</li><li>段地址和偏移地址通过内部总线送入一个称为地址加法器的部件</li><li>地址加法器将2个16位的地址合成一个20为的物理地址</li><li>通过内部总线将20位物理地址送入输入输出控制电路</li><li>输入输出控制电路将20位物理地址送上地址总线</li><li>20位物理地址被地址总线传送到存储器</li></ol><p><strong>物理地址 = 段地址x16+偏移地址</strong><br>如果CPU要访问地址为123C8H的内存单元，那么过程如下图所示：</p><img src="/2021/02/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%803/pic2.png" class><h2 id="“物理地址-段地址x16-偏移地址”-的本质意义"><a href="#“物理地址-段地址x16-偏移地址”-的本质意义" class="headerlink" title="“物理地址 = 段地址x16+偏移地址” 的本质意义"></a>“物理地址 = 段地址x16+偏移地址” 的本质意义</h2><p>CPU在访问内存时，用一个基础的地址(段地址x16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。</p><p>以2个和CPU无关的例子来说明:<br>第一个比喻说明”基础地址+偏移地址=物理地址”的思想:<br>学校，体育馆和图书馆在一条路上</p><img src="/2021/02/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%803/pic3.png" class><p>有两种方式描述图书馆的地址:</p><ol><li>从学校走2826m到图书馆。这2826m可以认为是图书馆的物理地址</li><li>从学校走2000m到体育馆，从体育馆再走826m到图书馆。第一个2000m相当于是基础地址，第二个826m是相对于基础地址的偏移地址。</li></ol><p>第二个比喻说明了”段地址x16+偏移地址=物理地址”:</p><p>如果只能通过纸条来互相通信，且一张纸条只能写3个数字，所以我不能写下2826这个数字，所以只能用2个纸条，一个写200,一个写826。然后根据我们事先的约定，得到纸条后做这样的运算: 200(段地址)x10+826(偏移地址) = 2826(物理地址)</p><p>8086CPU就是这样只能提供2张3位数据纸条的CPU。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之线程1</title>
      <link href="2021/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B1/"/>
      <url>2021/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>We are all apprentices in a craft where no one ever becomes a master.<br>– Ernest Hemingway</p></blockquote><h2 id="线程介绍"><a href="#线程介绍" class="headerlink" title="线程介绍"></a>线程介绍</h2><p><font color="orange"><strong>线程</strong>(thread)</font>和<font color="orange"><strong>进程</strong>(process)</font>非常相似，但确是完全不同的概念。和进程一样，线程有它的程序计数器，用来追踪下一个指令是什么。线程有寄存器，用来保存正在工作的变量。它有一个堆栈，用来记录运行历史。进程是把所有的资源整合在一起，线程是一个个被调度的条目，等待CPU的处理。<br>多个线程可以共同的运行在一个进程里，这就好比多个进程可以共同运行在一台计算机里。线程可以共享地址空间，打开文件或者其他资源。进程可以共享物理上的内存，硬盘，打印机等。所以线程有时会被理解为<font color="orange"><strong>轻量级进程</strong>(lightweight processes)</font>。<font color="orange"><strong>多线程</strong>(multithreading)</font>是指多个线程在同一个进程里运行。进程和线程的关系如下图：</p><img src="/2021/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B1/pic1.png" class><p>不同于进程的是，线程有相同的地址空间，这也就意味着它们共享相同的全局变量。</p><img src="/2021/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B1/pic2.png" class><p>上图说明了，process items是进程的属性，所以对于thread是共享的而不是独有的。所以第一张图的a是当三个进程完全不相关的，图b是三个线程都是同一个任务的一部分。</p><p>和进程一样，线程也有几种状态:<u>running, blocked,ready or terminated</u>。<br>每个线程都有自己的堆栈(stack)，如图所示</p><img src="/2021/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B1/pic3.png" class><p>每个堆栈包含了以及调用而还没有返回的程序，堆栈里包括了程序的本地变量以及返回时需要的地址。每个线程都会调用不同的程序，也就产生了不同的运行历史。<br>在一个进程里，多线程任务通常都是由单线程开始的。这个单线程可以通过调用库程序(Library procedure), <em>thread_create</em>。因为所有的线程都是相同的，所以不像进程那样有层次之分。<br>当线程完成任务时，会通过调用库程序，<em>thread_exit</em>来结束。<br><em>Thread_yield</em>也是一个重要的程序。这个调用可以让线程自愿放弃CPU使用，来让位给其他线程。</p><h2 id="线程的应用"><a href="#线程的应用" class="headerlink" title="线程的应用"></a>线程的应用</h2><p>我们为什么要用线程，而不是只用进程来处理任务呢？线程相比于进程主要有4点优势：</p><ol><li> 线程的并行能力(parallel ability)更强，因为它们享有共同的地址空间和数据。</li><li>   更容易建立和删除。因为不像进程那样有很多资源附着在上面</li><li>   当有大量的计算或者I/O设备时，线程速度更快因为线程允许这些任务相互覆盖</li><li>   对于多核系统，线程可以实现真正的并行。</li></ol><p>举一个实际的例子，一款文字处理软件通常由三个线程协作完成:它们分别用来交互，整理和保存。比如当用户在第一页删除了一行后，用来交互的线程就会告诉整理线程来重新编排整个文档，这时候交互的线程就可以做其他的操作了。很多文件处理软件运用了保存线程，会每隔一段时间自动保存来防止内容丢失。</p><img src="/2021/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B1/pic4.png" class><p>Web 的服务器也通常使用线程。在一个网站里，一个页面的浏览量通常会大于另一个页面(一般来说主页的浏览量最大)。所以web服务器会把频繁访问的页面放在主内存里而不是硬盘里，这个过程被称为缓存(cache)。<br>下图展示了有一个线程，dispatcher，从网络那边得到了请求，然后把请求交给一个idle worker thread。然后把这个worker thread唤醒，使它从blocked 状态变成ready状态。</p><img src="/2021/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B1/pic5.png" class><p>当worker唤醒后，它会去检查请求是否满足缓存的需求。如果不满足，它就进行read操作来读取硬盘中的页面然后进入Block直到操作完成。当它Block之后，其他的线程就会工作。<br>Dispatcher的程序包含了一个无限循环来接收工作并把它传给worker:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">Get_next_request(&amp;buf);</span><br><span class="line">Handoff_work(&amp;buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Worker的程序包含了一个无限循环来接收请求，检查web缓存来寻找页面是否存在。如果存在，就返回给客户端并且自己进入block状态等待新任务。如果不存在，就从硬盘中查找然后进入block状态等待新任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">Wait_for_work(&amp;buf);</span><br><span class="line">Look_for_page_in_cache(&amp;buf,&amp;page);</span><br><span class="line">If(page_not_in_cache(&amp;page))</span><br><span class="line">Read_page_from_disk(&amp;buf,&amp;page);</span><br><span class="line">return_page(&amp;page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户级"><a href="#用户级" class="headerlink" title="用户级"></a>用户级</h2><p>有两种实现线程的方法: 在用户空间和在内核里。下文给出了这两种方法的解释和优劣。</p><img src="/2021/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%BA%BF%E7%A8%8B1/pic6.png" class><p>如上图所示，当线程被用户空间管理的时候，每个进程需要自己的<font color="orange"><strong>thread table</strong></font>来追踪线程。这个Table就类似于在内核中的进程表(process table)，只不过这个table只追踪thread独有的信息，程序计数器，堆栈指针，寄存器，状态等。当一个进程被移到ready或者Block状态的时候，所需要重启的信息就存在thread table里面。<br>线程跟进程有一个关键的区别。当线程结束的时候，比如，调用<em>thread_yield</em>，<em>thread_yield</em>里的代码会把线程的信息存入到线程表里，这些储存线程状态和调度器(scheduler)的程序都是本地程序，所以调用非常快速。这也就是线程调度速度快的原因。<br>用户层面的线程还有其他的一些优势。比如它可以使每个进程有自己的调度算法，而且不会占用内核的空间。</p><h3 id="用户线程的劣势："><a href="#用户线程的劣势：" class="headerlink" title="用户线程的劣势："></a>用户线程的劣势：</h3><p>Blocking系统调用在线程之间会互相影响<br>当一个线程运行的时候，在这个进程中的其他线程是不能运行的，除非运行的线程自愿放弃。这个问题的解决方法就是使运行的系统每秒产生一个中断，但是这种方法往往太复杂，更低效。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>十六进制的转换及运算</title>
      <link href="2021/02/01/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8F%8A%E8%BF%90%E7%AE%97/"/>
      <url>2021/02/01/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8F%8A%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Don’t reinvent the wheel, just realign it.<br>– Anthony D’Angelo</p></blockquote><h2 id="关于十六进制"><a href="#关于十六进制" class="headerlink" title="关于十六进制"></a>关于十六进制</h2><p>一个字节(byte)包含8bits。如果用二进制表示的话，那么数据的范围为0000 0000 - 1111 1111，如果用十进制表示，那就是 0 - 255(2的8次方-1)。这两种表达方法还不够简洁。所以这时候<font color="orange"><strong>十六进制</strong>(hexadecimal)</font>就派上用场了，十六进制就是当每一位上满16就往前进一位,具体转换方法和运算将在下文中演示。十六进制由数字0到9和字母A到F(A到F分别对应十进制的10到15)16个值组成。下面的表格展示了二进制(binary)，十进制(decimal)和十六进制(hex digit)之间相对应的值:</p><img src="/2021/02/01/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8F%8A%E8%BF%90%E7%AE%97/pic1.png" class><p>这样一个字节用16进制表达的范围就是00-FF。在C语言中，16进制通常以0x或者0X开头来表示，比如0xFF(不区分大小写)。</p><h2 id="十六进制和二进制之间的转换"><a href="#十六进制和二进制之间的转换" class="headerlink" title="十六进制和二进制之间的转换"></a>十六进制和二进制之间的转换</h2><p>比如，给到一个数字 0x173A4C,把它转为二进制应该是：<br>十六进制: 1&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;C<br>二进制: 0001 0111 0011 1010 0100 1100</p><p>同样的，从二进制到十六进制可以使用同样的方法<br>二进制:&nbsp;&nbsp;11 1100 1010 1101 1011 0011<br>十六进制: 3&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;D&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;3</p><p><font color="powderblue">NOTE:如果二进制的最高位为0的话，可以在表达的时候省略，比如上面的例子，0011 可以写为11</font></p><h2 id="十六进制和十进制之间的转换"><a href="#十六进制和十进制之间的转换" class="headerlink" title="十六进制和十进制之间的转换"></a>十六进制和十进制之间的转换</h2><h3 id="一种巧妙算法"><a href="#一种巧妙算法" class="headerlink" title="一种巧妙算法"></a>一种巧妙算法</h3><p>在介绍这两种进制的普遍转换算法之前，先介绍一种巧妙的算法，这种算法限于十进制数为2的n次幂(比如2，4，8，16… 1024),也就是这个数 = 2<sup>n</sup>。我们都了解这种数的二进制就是一个1然后加上n个0(2是10，4是100，8是1000，1024是10000000000)。因为2<sup>4</sup> = 16,所以十六进制的一个0相当于二进制的4个0。所以n可以写成 i + 4j的形式，其中 0&lt;= i =&lt;3。举例说明，x = 2048 = 2<sup>11</sup>, n = 11 = 3+4x2,所以十六进制就可以写成0x800(8表示2<sup>3</sup>,后面跟两个0因为4x2里面的2)。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><table><thead><tr><th align="left">n</th><th align="left">decimal</th><th align="left">hexdecimal</th></tr></thead><tbody><tr><td align="left">9</td><td align="left">512</td><td align="left">0x200</td></tr><tr><td align="left">19</td><td align="left">524288</td><td align="left">0x80000</td></tr><tr><td align="left">16</td><td align="left">65536</td><td align="left">0x10000</td></tr></tbody></table><p><font color="orange">解释: 9 = 1+4x2, 所以十六进制为 2<sup>1</sup> 0 0 = 200<br>19 = 3+4x4,所以十六进制为 2<sup>3</sup> 0 0 0 0 = 80000<br>16 = 0+4x4,所以十六进制为2<sup>0</sup> 0 0 0 0 = 10000</font></p><h3 id="普遍算法"><a href="#普遍算法" class="headerlink" title="普遍算法"></a>普遍算法</h3><p>下面来介绍十进制和十六进制之间的普遍算法:<br>和二进制转换的方法相似，十进制数可以写成 x = qx16+r的形式, q代表商，r为余数。<br>举例说明，把314156转换为十六进制:</p><p>&nbsp;&nbsp;&nbsp;&nbsp;314156 = 19634x16+12&nbsp;&nbsp;&nbsp;&nbsp;(C)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19634 = 1227x16+2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1227 = 76x16+11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(B)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;76 = 4x16+12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(C)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 = 0x16+4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4)</p><p>直到q等于0为止。然后从“下往上”写， 十六进制为 0x4CB2C。</p><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><table><thead><tr><th align="left">decimal</th><th align="left">binary</th><th align="left">hexdecimal</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0000 0000</td><td align="left">0x00</td></tr><tr><td align="left">167</td><td align="left">1010 0111</td><td align="left">0xA7</td></tr><tr><td align="left">62</td><td align="left">1010</td><td align="left">0x3E</td></tr></tbody></table><h2 id="十六进制的加减"><a href="#十六进制的加减" class="headerlink" title="十六进制的加减"></a>十六进制的加减</h2><p>和十进制的运算相似，十六进制的加减包含了进位和借位，只是这些位是16而不是10。<br>比如 0x503c + 0x8<br>&nbsp;&nbsp;&nbsp;5 0 3 c<br>&nbsp;&nbsp;&nbsp;+ &nbsp;&nbsp;&nbsp;&nbsp;8<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>&nbsp;&nbsp;&nbsp;_______<br>&nbsp;&nbsp;&nbsp;5 0 4 4</p><p><font color="orange">解释:从最低位开始加起,c+8,因为c对应的值是12,所以c+8=20。因为满16，所以加4进1位。3加上进的1位就是4，因为不到16，所以不需要继续进位。</font></p><p>减法: 0x503c - 0x40<br>&nbsp;&nbsp;&nbsp;. .<br>&nbsp;&nbsp;&nbsp;5 0 3 c<br>&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;4 0<br>&nbsp;&nbsp;&nbsp;_______<br>&nbsp;&nbsp;&nbsp;4 f f c</p><p><font color="orange">解释:从最低位开始减，c-0=c。因为3小于4，所以要向前借一位，也就是借来16，这时候就是16+3-4 = 15 = f,但0也要向前面的5借一位，并借给了3一位，所以就是16-1 = 15 =f。</font></p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>本文中的概念及图片均来源于 <em>深入理解计算机系统</em> (Randal E.Bryant,David R. O’Hallaron)的2.1.1节。经过修改和提炼形成此文。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统之进程</title>
      <link href="2021/02/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B/"/>
      <url>2021/02/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Writing means sharing. It’s part of the human condition to want to share things – thoughts, ideas, opinions.<br>– Paulo Coelho</p></blockquote><h2 id="进程简介"><a href="#进程简介" class="headerlink" title="进程简介"></a>进程简介</h2><p>在任何操作系统中，最核心的概念就是进程：在抽象的意义上是一个运行的程序。在现代操作系统中，计算机在运行一个程序的同时，可以从磁盘(disk)中读取然后输出到屏幕上。但是严格的来说，在某一个特定的时刻，CPU只能运行一个程序，因为每个程序运行的时间非常短暂(通常以毫秒，也就是10^-3秒，为单位)，所以在1秒的时间里，CPU会运行多个程序，从而使得用户有多个程序同时运行的感觉。</p><p>计算机中所有可运行的程序，有时甚至包括操作系统本身，都可以被称为<font color="orange"><strong>进程</strong>(processes)</font>。CPU在不同的程序之间快速切换，被称为<font color="orange"><strong>多道程序</strong>(multiprogramming)</font>。</p><p>前文提到过进程是抽象意义上的<font color="orange"><strong>程序</strong>(program)</font>，但两者之间还是有细微的区别。书中给出一个很形象的类比来解释这两个概念，比如有一位父亲想给他的女儿做一个蛋糕，但他只是一个程序员并不是一个专业的蛋糕师。所以他需要找到一份做蛋糕的配方，以及原料：比如鸡蛋，牛奶，糖等。在这个情况下，配方就相当于程序(program)，这位父亲就是CPU，原料就是输入的数据，然而进程是指他做蛋糕的整个过程：包括阅读配方，加入原料以及放入烤箱。</p><p>继续我们的类比，假设这时这位程序员的儿子跑了进来，并说他在踢球时受伤了。所以程序员会暂停阅读蛋糕配方(正在进行的进程被保存)，找出急救指南(关于如何包扎伤口)，然后按指示给儿子包扎。在这里，CPU（程序员）从一个进程（做蛋糕）切换到优先级更高的进程（包扎伤口），每个进程都有不同的程序（蛋糕配方和急救指南）。当他处理完伤口，然后会去继续完成他的蛋糕制作。</p><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>有四个基本的事件可以创建进程:</p><ol><li> 系统的初始化</li><li> 通过一个正在运行的进程系统调用(system call)创建一个进程</li><li>   用户要求创建一个新的进程</li><li>   开始一个Batch job</li></ol><p>下面分别对这四种情况进行详细解释:<br>当操作系统启动的时候，一些进程会被创建，这些进程包括前台进程（与用户交互的一些进程），以及<font color="orange"><strong>后台进程</strong>(daemons)</font>。后台进程一般包括邮件的接收，web的创建以及打印等。在UNIX系统种，ps可以查看正在运行的进程，在windows系统中，可以通过任务管理器(task manage)来查看。</p><p>一个正在运行的进程可以通过系统调用来创建一个新的进程来协助它的工作。比如，想要通过网络来接收大量的数据，一个进程可以接收数据并且把它们放在一个共享的缓冲(buffer)里，第二个进程可以移除这些数据并且处理。</p><p>在一个交互的系统里(现在大部分使用的操作系统都是)，用户可以通过命令行或者双击图标来开始一个进程。</p><p>最后一种情况就是利用batch system(通常在大型的主机上)创建进程。</p><p>笼统的讲，所有的进程都是由一个已经存在的进程所创建的。在UNIX系统里，只有一个系统调用可以创建新的进程：<font color="orange"><strong>fork</strong></font>，它会克隆一个被调用的进程（被称为父进程和子进程）。父进程和子进程的内存映像(memory image)，environment string,以及打开文件(open files)都是相同的。通常情况下，子进程会运行execve或者类似的系统调用来改变它的内存映像，然后运行一个新的程序。比如，当我们在命令行打下 sort，shell会fork一个子进程然后这个子进程来运行sort。这样做原因是运行子进程在fork之后能够操作自己的文件描述符(file descriptor)，同时在运行execve之前来完成标准输出，输入，错误(standard input, output,error)的重定向(redirection)。</p><p><font color="powderblue">Note: 文件描述符(file descriptor)-在文件被读写之前，它必须被打开，而且打开的权限会被检查。如果权限允许，系统会返回一个整数，这个整数就是文件描述符。如果权限不允许，就会返回错误代码</font></p><p>在UNIX和windows系统种，当一个进程被创建后，父进程和子进程都有各自不同的地址空间。</p><h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h2><p>天下没有不散的宴席，这句话也适用于进程。通常有4种情况可以结束一个进程：</p><ol><li> 正常退出（自愿）</li><li>   错误退出(自愿)</li><li>   严重错误（非自愿）</li><li>   由其他进程终止（非自愿）</li></ol><p>大多数的进程都是在完成工作后终止。由系统调用（在UNIX里是exit,在windows里是ExitProcess）来终止。</p><p>第二种情况是进程发现了一些错误。比如，如果用户在命令行输入 cc foo.c 但是foo.c这个文件并不存在。这时编译器就会终止。</p><p>第三种情况通常是由于程序的bug，比如处理一些非法指令，指定一些不存在的内存，或者除数为0等。</p><p>第四种情况是由其他进程来终止。在UNIX里被称为kill, 在windows里是TerminateProcess。通常‘killer’会有一定的权限来执行。</p><h2 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h2><p>一个进程可以产生一个或者多个进程，它和它的”后代们”会组成一个进程Group。当用户通过键盘向这个Group 发送一个信号时，所有的成员都可以收到，同时每个进程都有自己的权力来处理这个信号（接收或忽略）。<br>在UNIX系统里，所有的进程可以被看成一个树的结构，且只有一个根，那就是 <strong>init</strong><br>相反在windows系统里，所有的进程都是平等的(有若干个树)。</p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p>尽管所有的进程都是独立存在(有自己的程序计数器，内部状态)。但大部分情况下进程之间都是交互的，一个进程的输出可能会是另一个进程的输入。比如在shell中的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat chapter1 chapter2 chapter3 | grep tree</span><br></pre></td></tr></table></figure><p>第一个进程运行了cat，把3个文件整合起来并输出。第二个进程运行了grep ，选中所有包含”tree”的行。由于程序的复杂度以CPU处理速度等因素，会出现grep以及准备运行但是前面的cat还没有运行完毕。所以这时候，grep就会进入blocked的状态直到接收到前面的输入。</p><p>进程进入blocked状态有两种情况 :第一种就是上文提到的因为接收不到输入。第二种情况就是操作系统会使CPU处理其他的进程。这两种情况是完全不同的。</p><p>一个进程通常有3种状态</p><ol><li><p> running（在这一刻用CPU）</p></li><li><p>   ready（可运行的；等待其他进程运行）</p></li><li><p>blocked（由于一些外部情况不能运行）</p> <img src="/2021/02/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B/Picture1.png" class></li></ol><p>如上图所示，操作系统状态之间的转换过程有4种。过程1表示一个进程发现它不能运行。在UNIX系统里，当进程接收不到输入的时候，它便自动进入blocked。</p><p>过程2和3是由<font color="orange"><strong>进程调度器</strong>(process scheduler)</font>引起的。进程调度器是操作系统自带的。过程2是当一个进程运行时间过长，调度器决定让其他进程运行。过程3是因为其他的进程都有相当的运行时间是，调度器会让第一个进程重新运行(通常是原来停止运行的进程)。<br>过程4是由于一些外部事件的发送（如接收到输入。</p><h2 id="实现进程"><a href="#实现进程" class="headerlink" title="实现进程"></a>实现进程</h2><p>操作系统以数组的结构来管理进程，这个结构通常被称为<font color="orange"><strong>进程表</strong></font>(process table)或者进程控制块(process control blocks)。每一个条目(entry)包含一个进程。这些条目包含了进程的有关信息，包括进程状态，程序计数器，堆栈指针，内存分配，打开文件的状态，调度信息等。下图展示了一个操作系统的进程条目:<br>    <img src="/2021/02/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B/Picture2.png" class></p><p>对于每一个I/O设备(如软盘，硬盘，计时器，终端)有一个对应的地址(通常在内存的底层)被称为<font color="orange"><strong>中断向量</strong>(interrupt vector)</font>,它包含了中断服务的地址。假设一个磁盘的中断在进程3运行时发生，进程3的程序计数器，程序状态，一个或多个寄存器都会被中断硬件推进堆栈。计算机会跳转到磁盘中断向量的地址上。这就是硬件所做的所有工作，剩下的就要交给软件来做，比如中断服务过程。</p><p>所有的中断都要先保存寄存器，通常在目前进程的进程表里。然后被中断硬件推入堆栈的信息会被移除，然后堆栈指针通过进程处理器指向一个临时的堆栈。通常保存寄存器和设定堆栈指针是由汇编语言完成的，然后剩下的工作由C语言完成(大多数的操作系统是由C语言编写的)。</p><p>中断处理以及调度可以总结为以下几个步骤:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">硬件堆入程序计数器等</span><br><span class="line">硬件从中断向量里提取新的程序计数器</span><br><span class="line">汇编语言保存寄存器</span><br><span class="line">汇编语言设立新的堆栈</span><br><span class="line">C语言中断服务运行（通常是读取或者输入）</span><br><span class="line">调度器决定该运行哪个进程</span><br><span class="line">C语言转回汇编语言</span><br><span class="line">由汇编语言开启新的进程</span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>本系列关于操作系统的理论知识及图片来源于<em>现代操作系统</em> (Andrew S. Tanenbaum, Herbert Bos)。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言2</title>
      <link href="2021/01/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%802/"/>
      <url>2021/01/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%802/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Vessels large may venture more, but little boats should keep near shore.<br>-Benjamin Franklin</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文主要讨论有关寄存器的话题。一个典型的CPU由运算器，控制器，寄存器等器件构成，这些器件靠内部总线连接。在CPU中：</p><ul><li>运算器进行信息处理</li><li>寄存器进行信息存储</li><li>控制器控制各种器件进行工作</li><li>内部总线连接各种器件，在他们之间进行数据的传送。<br>寄存器是CPU中程序员可以用指令读写的部件，程序员通过改变各种寄存器中的内容来实现对CPU的控制。</li></ul><p>不同的CPU，寄存器的个数，结构是不同的。8086CPU中有14个寄存器，每个寄存器有一个名称。这些寄存器是：AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW。</p><h2 id="不同种类的寄存器"><a href="#不同种类的寄存器" class="headerlink" title="不同种类的寄存器"></a>不同种类的寄存器</h2><ol><li><p>通用寄存器</p><ul><li>AX,BX,CX,DX这4个寄存器通常用来存放一般性的数据<img src="/2021/01/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%802/reg.png" class></li><li>如图所示，在8086中，所有的寄存器都是16位。这4个寄存器都能分为两个可以独立使用的8位寄存器<ul><li>AX可以分为AH和AL</li><li>BX可以分为BH和BL</li><li>CX可以分为CH和CL</li><li>DX可以分为DH和DL<br>AX的低8位(0-7位)构成了AL寄存器，高8位构成了AH寄存器。AH和AL是可以独立使用的8位寄存器。</li></ul></li></ul></li><li><p>字(word)在寄存器中的存储</p><ul><li><p>8086CPU可以一次性处理两种尺寸的数据，字节和字(byte and word)</p><ul><li><p>字节：由8个bit组成，可以存在8位寄存器中</p></li><li><p>字：由2个字节组成，这两个字节分别称为这个字的高位字节和低位字节,如下图所示</p><img src="/2021/01/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%802/reg2.png" class></li><li><p>所以例子中的寄存器既可以被看成一个字(大小为20000),也可以看成两个独立的字节(分别是78和32)</p></li></ul></li></ul></li><li><p>汇编指令</p><ul><li>举几个指令的例子<table><thead><tr><th align="left">汇编指令</th><th align="left">控制CPU的操作</th><th align="left">高级语言描述</th></tr></thead><tbody><tr><td align="left">mov ax,18</td><td align="left">将18送入寄存器AX</td><td align="left">AX=18</td></tr><tr><td align="left">mov ah,78</td><td align="left">将78送入寄存器AH</td><td align="left">AH=78</td></tr><tr><td align="left">add ax,8</td><td align="left">将寄存器AX的值加8</td><td align="left">AX=AX+8</td></tr><tr><td align="left">mov ax,bx</td><td align="left">将寄存器BX的值送入AX</td><td align="left">AX=BX</td></tr></tbody></table></li></ul></li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ol><li>mov ax,62627        AX = <u>F4A3H</u>   <font color="orange">#AX为16位寄存器，只能存放4位十六进制的数据,H代表十六进制</font></li><li>mov ah,31H        AX = <u>31A3H</u></li><li>mov al,23H        AX = <u>3123H</u></li><li>add ax,ax        AX = <u>6246H</u></li><li>mov bx,826CH        BX = <u>826CH</u></li><li>mov cx,ax        CX = <u>6246H</u></li><li>mov ax,bx        AX = <u>826CH</u></li><li>add ax,bx        AX = <u>04D8H</u></li><li>mov al,bh        AX = <u>0482H</u></li><li>mov ah,bl       AX = <u>6C82H</u></li></ol><p>关于十六进制的运算,请参考另一篇博客 <a href="/2021/02/01/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%8F%8A%E8%BF%90%E7%AE%97/" title="十六进制的转换及运算">十六进制的转换及运算</a></p><p>例题2:<br>用目前学过的汇编指令，最多使用4条指令，编程计算2的4次方。<br><font color="orange">解答：<br>    mov ax,2&nbsp;&nbsp;&nbsp;&nbsp;ax=2<br>    add ax,ax&nbsp;&nbsp;&nbsp;ax=4<br>    add ax,ax&nbsp;&nbsp;&nbsp;ax=8<br>    add ax,ax&nbsp;&nbsp;&nbsp;ax=16<br></font></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言1</title>
      <link href="2021/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801/"/>
      <url>2021/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801/</url>
      
        <content type="html"><![CDATA[<blockquote><p>One man’s ‘magic’ is another man’s engineering.<br>– Robert Heinlein</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这个系列的笔记是关于汇编语言的学习，所用的教材是清华大学出版社出版的<em>汇编语言</em>。主要内容就是来自教科书中的重要概念，练习题以及实验。这本书采用8086CPU来进行教学，学习中用到了DOSBox这款软件。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>汇编语言的核心是汇编指令，汇编语言工作的过程如图：</p><img src="/2021/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801/ass.png" class><ol><li><p>存储器</p><ul><li>又称为内存</li><li>存放指令和数据</li></ul></li><li><p>指令和数据</p><ul><li>是应用上的概念(二进制信息)</li><li>比如，内存中的二进制信息1000100111011000，计算机可以把它看成大小为89D8H的数据，也可以看作是指令 mov ax,bx来执行</li><li>1000100111011000 -&gt; 89D8H (数据)， 1000100111011000 -&gt; mov ax,bx(程序)</li></ul></li><li><p>存储单元<br>|   |   |   |   |   |   |   |   |<br> 0    1   2    …   125  126  127</p><ul><li>存储器被分成若干个存储单元，如一个存储器有128个存储单元，编号从0 - 127</li><li>一个单元可以存储一个byte(8bits), 比如0001 0001。上面的存储器的大小就是128个字节</li><li>1KB=1024B, 1MB=1204KB,1GB=1024MB,1TB=1024GB (B代表Byte)</li></ul></li><li><p>CPU对存储器的读写</p><ul><li>CPU需要和芯片交互3种信息<ol><li>存储单元的地址(地址信息)</li><li>器件的选择，读或写的命令(控制信息)</li><li>读或写的数据(数据信息)</li></ol></li><li>CPU和内存在物理上通过导线交互，通常称为总线；在逻辑上分为地址总线，控制总线和数据总线<img src="/2021/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801/ass2.png" class>上图的具体步骤为:<ol><li>CPU通过地址总线讲地址信息3发出</li><li>CPU通过控制总线发出内存读命令，选中单元，并通知</li><li>存储器将3号单元中的数据08通过数据线送入CPU</li></ol></li><li>举例:<br>  机器码：10100001 00000011 00000000<br>  对应汇编：MOV AX,[3]<br>  含义：传送3号单元的内容到AX</li></ul><p>下面分别对这3个总线进行解释:</p></li><li><p>地址总线</p><ul><li><p>用来指定存储器单元，传送一条信息对应一个单元</p></li><li><p>如果一个CPU有10根地址总线，用二进制表示，就可以传输2^10 = 1024个不同的数据(0-1023)</p></li><li><p>下图展示了具有10根地址线的CPU向内存发出信息地址11时，10根地址线上传送的二进制信息</p><img src="/2021/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801/ass3.png" class></li></ul></li><li><p>数据总线</p><ul><li><p>数据总线的宽度决定了CPU和外界传输的速度，8根总线可以传送一个8位二进制(一个字节)</p></li><li><p>下图展示了8086CPU有16根数据总线，可以传输16位数据</p><img src="/2021/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%801/ass4.png" class></li></ul></li><li><p>控制总线</p><ul><li>一根控制总线代表着CPU对外设的一种控制，宽度决定了CPU的控制能力</li><li>读和写操作分别有两根控制线负责。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">汇编指令是机器指令的助记符</span><br><span class="line">每一种CPU都有自己的汇编指令集</span><br><span class="line">CPU可以使用的信息在存储器中存放</span><br><span class="line">在存储器中指令和数据没有区别，都是二进制信息</span><br><span class="line">存储单元从0开始顺序编号</span><br><span class="line">一个存储单元可以存储8个bit,即8位二进制数</span><br><span class="line">1B &#x3D; 8bit, 1KB &#x3D; 1024B, 1MB &#x3D; 1024KB, 1GB &#x3D; 1024 MB</span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>文中所有的概念和图片均来自于王爽的<em>汇编语言</em></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>freeRTOS实时操作系统</title>
      <link href="2021/01/30/freeRTOS%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/01/30/freeRTOS%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>It is not the mountain we conquer but ourselves.<br>– Sir Edmund Hillary</p></blockquote><p>这是一篇总结自己在实习的时候最开始接触的一个项目：把freeRTOS操作系统移植到VEGAboard-一款以RISC-V为架构的开发板。大概是这个样子的：</p><img src="/2021/01/30/freeRTOS%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/vegaboard.jpg" class><p>关于硬件方面以及RISCV指令集，在这篇文章里不会提到。本篇的主要内容是对freeRTOS内核代码的简介，包括从硬件上电到主程序运行的过程。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>FreeRTOS的源码主要可以分成三大部分：1.用于处理任务（task）的代码，有大概一半的freeRTOS的代码用来处理task。其中task.c和task.h文件做了大部分创建和管理任务的工作。2.不同task之间的交流，在queue.c和queue.h文件里，任务或者中断之间可以互相发送数据以及使用semaphores和mutexes来通信和共享信息。3.还有一部分代码是用来沟通软件和硬件之间的代码，如port.c 和portasm.s。本文是以官方提供的blinky demo来举例。</p><h2 id="初始化和复位"><a href="#初始化和复位" class="headerlink" title="初始化和复位"></a>初始化和复位</h2><p>当开发板通电后，驱动程序（device driver）里的startup，以及链接文件用来初始化和复位：</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Reset Handler */</span></span><br><span class="line"><span class="symbol">Reset_Handler:</span></span><br><span class="line">    <span class="comment"># Disable global interrupt. */</span></span><br><span class="line">    csrci mstatus, <span class="number">8</span></span><br><span class="line">    <span class="comment"># initialize stack pointer</span></span><br><span class="line">    la <span class="built_in">sp</span>, __StackTop</span><br><span class="line">    <span class="comment"># initialize global pointer</span></span><br><span class="line">    la gp, __global_pointer</span><br></pre></td></tr></table></figure><p>为了保证整个startup的过程不受外设中断的影响，Reset_Handler首先会关闭全局中断(disable),然后初始化堆栈指针（la sp,__StackTOP)。紧接着，程序会执行SystemInit函数，这个函数的功能主要是相关寄存器的复位以及时钟的初始化，包括关闭看门狗(watchdog),初始化中断向量表的地址。在systemInit()中，下面的两行代码把Flash中的代码拷贝到RAM中运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy_section(&amp;__etext, &amp;__data_start__, &amp;__data_end__);</span><br><span class="line">zero_section(&amp;__bss_start__, &amp;__bss_end__);</span><br></pre></td></tr></table></figure><p>然后跳转到main函数。</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable global interrupt. */</span></span><br><span class="line"><span class="symbol">csrsi</span> mstatus, <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">jal</span> main</span><br></pre></td></tr></table></figure><p>连接文件（RV32M1_ri5cy_flash.ld）用来初始化C语言的堆栈。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   .data : AT(__DATA_ROM)</span><br><span class="line"> &#123;</span><br><span class="line">   . &#x3D; ALIGN(4);</span><br><span class="line">   __DATA_RAM &#x3D; .;</span><br><span class="line">   __data_start__ &#x3D; .;      &#x2F;* create a global symbol at data start *&#x2F;</span><br><span class="line">   *(.data)                 &#x2F;* .data sections *&#x2F;</span><br><span class="line">   *(.data*)                &#x2F;* .data* sections *&#x2F;</span><br><span class="line">   *(.sdata .sdata.*)</span><br><span class="line">   *(.heapsram*)            &#x2F;* This is only for the pulpino official test code. *&#x2F;</span><br><span class="line">   __noncachedata_start__ &#x3D; .;   &#x2F;* create a global symbol at ncache data start *&#x2F;</span><br><span class="line">*(NonCacheable)</span><br><span class="line">   __noncachedata_end__ &#x3D; .;     &#x2F;* define a global symbol at ncache data end *&#x2F;</span><br><span class="line">   KEEP(*(.jcr*))</span><br><span class="line">   . &#x3D; ALIGN(4);</span><br><span class="line">   __data_end__ &#x3D; .;        &#x2F;* define a global symbol at data end *&#x2F;</span><br><span class="line"> &#125; &gt; m_data</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>.data 是C语言中已经初始化的变量，.bss是没有初始化的变量，没有初始化的值为零。以上就完成了变量的初始化。</p><h2 id="接口文件"><a href="#接口文件" class="headerlink" title="接口文件"></a>接口文件</h2><p>操作系统的内核代码（如task.c）通过port.c,portASM.S等文件与底层硬件交流。比如在task.h中有以下一行代码是使一个任务进入critical section来防止其他的任务进入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> taskENTER_CRITICAL()               portENTER_CRITICAL()</span></span><br></pre></td></tr></table></figure><p>这里的portENTER_CRITICAL()就是在portmarco.h里定义的，这样就使得task.c不用与底层的硬件交流，对于不同的硬件设备只需要更改port文件就可以。<br>portASM.S 是一个汇编接口文件，这个文件适用于所有的芯片。但它包含了一个特定于某个芯片的头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;freertos_risc_v_chip_specific_extensions.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>比如在本文中的demo里，这个头文件包含了针对RISC-V-RV32的一些额外寄存器的存储以及复位。这样就可以解决不同的芯片需要一些不同的寄存器。</p><h2 id="安排任务"><a href="#安排任务" class="headerlink" title="安排任务"></a>安排任务</h2><p>每一个任务需要被指定一个优先级，这个优先级的数字从0 到 configMAX_PRIORITIES-1 （在freeRTOSConfig.h里被定义）。如果configMAX_PRIORITIES被设置为5，那么每个任务可以使用0（最低），1，2，3，4（最高）作为优先的等级。<br>FreeRTOS使用一个准备列表（ready list）来收集所有准备运行的任务。定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PRIVILEGED_DATA <span class="keyword">static</span> List_t pxReadyTasksLists[ configMAX_PRIORITIES ];</span><br></pre></td></tr></table></figure><p>比如，pxReadyTasksLists[1]是所有优先级为1且准备运行任务的列表。<br>vTaskSwitchContext()函数会终止现在的任务而选择优先级更高的任务然后把这个任务放入pxCurrentTCB：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> taskSELECT_HIGHEST_PRIORITY_TASK()                                </span></span><br><span class="line">&#123;                                                                         </span><br><span class="line">    UBaseType_t uxTopPriority = uxTopReadyPriority;                       </span><br><span class="line">                                                                          </span><br><span class="line">    <span class="comment">/* Find the highest priority queue that contains ready tasks. */</span>      </span><br><span class="line">    <span class="keyword">while</span>( listLIST_IS_EMPTY( &amp;( pxReadyTasksLists[ uxTopPriority ] ) ) ) </span><br><span class="line">    &#123;  </span><br><span class="line">        configASSERT( uxTopPriority );                                    </span><br><span class="line">        --uxTopPriority;                                                  </span><br><span class="line">    &#125;                                                                     </span><br><span class="line">                                                                          </span><br><span class="line">    <span class="comment">/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of </span></span><br><span class="line"><span class="comment">     * the  same priority get an equal share of the processor time. */</span>                    </span><br><span class="line">    listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &amp;( pxReadyTasksLists[ uxTopPriority ] ) ); </span><br><span class="line">    uxTopReadyPriority = uxTopPriority;                                                   </span><br><span class="line">&#125; <span class="comment">/* taskSELECT_HIGHEST_PRIORITY_TASK */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的函数确保了优先级高的任务先执行，首先要确保uxTopReadyPriority大于或等于有最高优先级的等待任务。在while循环里，从uxTopReadyPriority优先级开始，在pxReadyTasksLists[]里寻找准备任务的最高优先级。listGET_OWNER_OF_NEXT_ENTRY()函数可以从ready list里抓取下一个任务。<br>接下来pxCurrentTCB 指向最高优先级的任务，vTaskSwitchContext()就会使硬件执行任务。</p><h2 id="建立任务"><a href="#建立任务" class="headerlink" title="建立任务"></a>建立任务</h2><p>xTaskCreate用于创建新的任务。每一个任务都会有一个对应的TCB(task control block),TCB包含了任务的信息，包括任务名称，优先级，内存地址等。这些TCB都储存在一个堆栈里，pxPortInitialiseStack()函数会在新任务准备运行之前初始化堆栈。<br>以官方提供的demo为例(C:\FreeRTOS_RISCV\FreeRTOS\Demo\RISC-V_RV32M1_Vega_GCC_Eclipse\projects\RTOSDemo_ri5cy)。在main.c文件里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">prvSetupHardware();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The mainCREATE_SIMPLE_BLINKY_DEMO_ONLY setting is described at the top</span></span><br><span class="line"><span class="comment">of this file. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>( mainCREATE_SIMPLE_BLINKY_DEMO_ONLY == 1 )</span></span><br><span class="line">&#123;</span><br><span class="line">main_blinky();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">&#123;</span><br><span class="line">main_full();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>首先prvSetupHardware()用来初始化硬件，然后调用在main_full.c里的main_full()函数（因为mainCREATE_SIMPLE_BLINKY_DEMO_ONLY被设为0）。<br>在main_full()中，有三个任务被创建,其中前两个是 ‘register check’,用来检查register是否正常，他们被设置为最低优先级，以便被其他的任务覆盖。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xTaskCreate( prvRegTestTaskEntry1, <span class="comment">/* The function that implements the task. */</span></span><br><span class="line"><span class="string">&quot;Reg1&quot;</span>, <span class="comment">/* The name of the task. */</span></span><br><span class="line">mainREG_TEST_STACK_SIZE_WORDS,  <span class="comment">/* Size of stack to allocate for the task - in words not bytes!. */</span></span><br><span class="line">mainREG_TEST_TASK_1_PARAMETER,  <span class="comment">/* Parameter passed into the task. */</span></span><br><span class="line">tskIDLE_PRIORITY, <span class="comment">/* Priority of the task. */</span></span><br><span class="line"><span class="literal">NULL</span> );<span class="comment">/* Can be used to pass out a handle to the created task. */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>prvCheckTask()是用来检查所有的demo 任务以及上面的两个register check。当程序运行的时候，prvCheckTask()会在终端显示中打印一个 ‘pass’并且每成功一个循环(所有的demo和2个register test)都会打印一个 ‘.’，而且LED灯闪烁一次。最后 vTaskStartScheduler()使最高优先级的任务进入running mode(运行)。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了硬件上电后初始化的代码(主要为汇编代码)，链接硬件和软件的接口文件(port)。以及最基础的任务运行原理(高优先级替换低优先级)。经过一段时间的学习，我对freeRTOS及操作系统的理解还相对较浅。随着项目的深入和学习，更多关于此话题的文章会更新。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
